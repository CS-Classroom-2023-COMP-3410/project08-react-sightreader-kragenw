import {
  __commonJS
} from "./chunk-EQCVQC35.js";

// node_modules/abcjs/version.js
var require_version = __commonJS({
  "node_modules/abcjs/version.js"(exports, module) {
    var version = "5.12.0";
    module.exports = version;
  }
});

// node_modules/abcjs/src/write/abc_spacing.js
var require_abc_spacing = __commonJS({
  "node_modules/abcjs/src/write/abc_spacing.js"(exports, module) {
    var spacing = {};
    spacing.FONTEM = 360;
    spacing.FONTSIZE = 30;
    spacing.STEP = spacing.FONTSIZE * 93 / 720;
    spacing.SPACE = 10;
    spacing.TOPNOTE = 15;
    spacing.STAVEHEIGHT = 100;
    spacing.INDENT = 50;
    module.exports = spacing;
  }
});

// node_modules/abcjs/src/parse/abc_common.js
var require_abc_common = __commonJS({
  "node_modules/abcjs/src/parse/abc_common.js"(exports, module) {
    var parseCommon = {};
    parseCommon.clone = function(source) {
      var destination = {};
      for (var property in source)
        if (source.hasOwnProperty(property))
          destination[property] = source[property];
      return destination;
    };
    parseCommon.cloneArray = function(source) {
      var destination = [];
      for (var i = 0; i < source.length; i++) {
        destination.push(parseCommon.clone(source[i]));
      }
      return destination;
    };
    parseCommon.cloneHashOfHash = function(source) {
      var destination = {};
      for (var property in source)
        if (source.hasOwnProperty(property))
          destination[property] = parseCommon.clone(source[property]);
      return destination;
    };
    parseCommon.cloneHashOfArrayOfHash = function(source) {
      var destination = {};
      for (var property in source)
        if (source.hasOwnProperty(property))
          destination[property] = parseCommon.cloneArray(source[property]);
      return destination;
    };
    parseCommon.gsub = function(source, pattern, replacement) {
      return source.split(pattern).join(replacement);
    };
    parseCommon.strip = function(str) {
      return str.replace(/^\s+/, "").replace(/\s+$/, "");
    };
    parseCommon.startsWith = function(str, pattern) {
      return str.indexOf(pattern) === 0;
    };
    parseCommon.endsWith = function(str, pattern) {
      var d = str.length - pattern.length;
      return d >= 0 && str.lastIndexOf(pattern) === d;
    };
    parseCommon.each = function(arr, iterator, context) {
      for (var i = 0, length = arr.length; i < length; i++)
        iterator.apply(context, [arr[i], i]);
    };
    parseCommon.last = function(arr) {
      if (arr.length === 0)
        return null;
      return arr[arr.length - 1];
    };
    parseCommon.compact = function(arr) {
      var output = [];
      for (var i = 0; i < arr.length; i++) {
        if (arr[i])
          output.push(arr[i]);
      }
      return output;
    };
    parseCommon.detect = function(arr, iterator) {
      for (var i = 0; i < arr.length; i++) {
        if (iterator(arr[i]))
          return true;
      }
      return false;
    };
    (function(arr) {
      arr.forEach(function(item) {
        if (item.hasOwnProperty("remove")) {
          return;
        }
        Object.defineProperty(item, "remove", {
          configurable: true,
          enumerable: true,
          writable: true,
          value: function remove() {
            if (this.parentNode !== null)
              this.parentNode.removeChild(this);
          }
        });
      });
    })([Element.prototype, CharacterData.prototype, DocumentType.prototype]);
    module.exports = parseCommon;
  }
});

// node_modules/abcjs/src/api/abc_timing_callbacks.js
var require_abc_timing_callbacks = __commonJS({
  "node_modules/abcjs/src/api/abc_timing_callbacks.js"(exports, module) {
    var TimingCallbacks = function(target, params) {
      var self = this;
      if (!params) params = {};
      self.qpm = params.qpm ? parseInt(params.qpm, 10) : null;
      if (!self.qpm) {
        var tempo = target.metaText ? target.metaText.tempo : null;
        self.qpm = target.getBpm(tempo);
      }
      self.extraMeasuresAtBeginning = params.extraMeasuresAtBeginning ? parseInt(params.extraMeasuresAtBeginning, 10) : 0;
      self.beatCallback = params.beatCallback;
      self.eventCallback = params.eventCallback;
      self.lineEndCallback = params.lineEndCallback;
      self.lineEndAnticipation = params.lineEndAnticipation ? parseInt(params.lineEndAnticipation, 10) : 0;
      self.beatSubdivisions = params.beatSubdivisions ? parseInt(params.beatSubdivisions, 10) : 1;
      self.replaceTarget = function(newTarget) {
        newTarget.setTiming(self.qpm, self.extraMeasuresAtBeginning);
        if (newTarget.noteTimings.length === 0)
          newTarget.setTiming(0, 0);
        if (self.lineEndCallback) {
          self.lineEndTimings = getLineEndTimings(newTarget.noteTimings, self.lineEndAnticipation);
        }
        self.noteTimings = newTarget.noteTimings;
      };
      self.replaceTarget(target);
      if (self.noteTimings.length === 0)
        return;
      self.noteTimings = target.noteTimings;
      self.millisecondsPerBeat = 1e3 / (self.qpm / 60) / self.beatSubdivisions;
      self.lastMoment = self.noteTimings[self.noteTimings.length - 1].milliseconds;
      self.totalBeats = Math.round(self.lastMoment / self.millisecondsPerBeat);
      self.startTime = null;
      self.currentBeat = 0;
      self.currentEvent = 0;
      self.isPaused = false;
      self.isRunning = false;
      self.pausedTime = null;
      self.justUnpaused = false;
      self.newSeekPercent = 0;
      self.justSeeked = false;
      function setCurrentLocation(timestamp) {
        var currentPercent = (timestamp - self.startTime) / self.lastMoment;
        var percentDifference = currentPercent - self.newSeekPercent;
        var timeDifference = self.lastMoment * percentDifference;
        self.startTime = self.startTime + timeDifference;
        var currentTime = timestamp - self.startTime;
        currentTime += 50;
        var oldBeat = self.currentBeat;
        self.currentBeat = Math.floor(currentTime / self.millisecondsPerBeat);
        if (self.beatCallback && oldBeat !== self.currentBeat)
          self.beatCallback(self.currentBeat / self.beatSubdivisions, self.totalBeats / self.beatSubdivisions, self.lastMoment);
        self.currentEvent = 0;
        while (self.noteTimings.length > self.currentEvent && self.noteTimings[self.currentEvent].milliseconds < currentTime) {
          self.currentEvent++;
        }
        if (self.eventCallback && self.currentEvent > 0 && self.noteTimings[self.currentEvent - 1].type === "event")
          self.eventCallback(self.noteTimings[self.currentEvent - 1]);
      }
      self.doTiming = function(timestamp) {
        if (!self.startTime) {
          self.startTime = timestamp;
        } else if (self.justUnpaused) {
          var timePaused = timestamp - self.pausedTime;
          self.startTime += timePaused;
        }
        self.justUnpaused = false;
        if (self.justSeeked) {
          setCurrentLocation(timestamp);
          self.justSeeked = false;
        }
        if (self.isPaused) {
          self.pausedTime = timestamp;
        } else if (self.isRunning) {
          var currentTime = timestamp - self.startTime;
          currentTime += 50;
          while (self.noteTimings.length > self.currentEvent && self.noteTimings[self.currentEvent].milliseconds < currentTime) {
            if (self.eventCallback && self.noteTimings[self.currentEvent].type === "event")
              self.eventCallback(self.noteTimings[self.currentEvent]);
            self.currentEvent++;
          }
          if (currentTime < self.lastMoment) {
            requestAnimationFrame(self.doTiming);
            if (self.currentBeat * self.millisecondsPerBeat < currentTime) {
              if (self.beatCallback)
                self.beatCallback(self.currentBeat / self.beatSubdivisions, self.totalBeats / self.beatSubdivisions, self.lastMoment);
              self.currentBeat++;
            }
          } else if (self.currentBeat <= self.totalBeats) {
            if (self.beatCallback) {
              self.beatCallback(self.currentBeat / self.beatSubdivisions, self.totalBeats / self.beatSubdivisions, self.lastMoment);
              self.currentBeat++;
              requestAnimationFrame(self.doTiming);
            }
          }
          if (self.lineEndCallback && self.lineEndTimings.length && self.lineEndTimings[0].milliseconds <= currentTime) {
            self.lineEndCallback(self.lineEndTimings[0]);
            self.lineEndTimings.shift();
          }
          if (currentTime >= self.lastMoment && self.eventCallback)
            self.eventCallback(null);
        }
      };
      self.start = function() {
        self.isRunning = true;
        if (self.isPaused) {
          self.isPaused = false;
          self.justUnpaused = true;
        }
        requestAnimationFrame(self.doTiming);
      };
      self.pause = function() {
        self.isPaused = true;
        self.isRunning = false;
      };
      self.reset = function() {
        self.currentBeat = 0;
        self.currentEvent = 0;
        self.startTime = null;
        self.pausedTime = null;
        if (self.lineEndCallback) {
          self.lineEndTimings = getLineEndTimings(self.noteTimings, self.lineEndAnticipation);
        }
      };
      self.stop = function() {
        self.pause();
        self.reset();
      };
      self.setProgress = function(percent) {
        if (percent < 0) percent = 0;
        if (percent > 1) percent = 1;
        self.newSeekPercent = percent;
        self.justSeeked = true;
        requestAnimationFrame(self.doTiming);
      };
    };
    function getLineEndTimings(timings, anticipation) {
      var callbackTimes = [];
      var lastTop = null;
      for (var i = 0; i < timings.length; i++) {
        var timing = timings[i];
        if (timing.top !== lastTop) {
          callbackTimes.push({ milliseconds: timing.milliseconds - anticipation, top: timing.top, bottom: timing.top + timing.height });
          lastTop = timing.top;
        }
      }
      return callbackTimes;
    }
    module.exports = TimingCallbacks;
  }
});

// node_modules/abcjs/src/api/abc_animation.js
var require_abc_animation = __commonJS({
  "node_modules/abcjs/src/api/abc_animation.js"(exports, module) {
    var spacing = require_abc_spacing();
    var parseCommon = require_abc_common();
    var TimingCallbacks = require_abc_timing_callbacks();
    var animation = {};
    (function() {
      "use strict";
      var timer;
      var cursor;
      animation.startAnimation = function(paper, tune, options) {
        if (timer) {
          timer.stop();
          timer = void 0;
        }
        if (options.showCursor) {
          cursor = paper.querySelector(".abcjs-cursor");
          if (!cursor) {
            cursor = document.createElement("DIV");
            cursor.className = "abcjs-cursor cursor";
            cursor.style.position = "absolute";
            paper.appendChild(cursor);
            paper.style.position = "relative";
          }
        }
        function hideMeasures(elements) {
          for (var i = 0; i < elements.length; i++) {
            var element = elements[i];
            if (!element.classList.contains("abcjs-bar"))
              element.style.display = "none";
          }
        }
        var lastMeasure;
        function disappearMeasuresAfter(selector) {
          if (lastMeasure) {
            var elements = paper.querySelectorAll(lastMeasure);
            hideMeasures(elements);
          }
          lastMeasure = selector;
        }
        function disappearMeasuresBefore(selector) {
          var elements = paper.querySelectorAll(selector);
          hideMeasures(elements);
        }
        function measureCallback(selector) {
          if (options.hideCurrentMeasure) {
            disappearMeasuresBefore(selector);
          } else if (options.hideFinishedMeasures) {
            disappearMeasuresAfter(selector);
          }
        }
        function getLineAndMeasure(element) {
          return ".abcjs-l" + element.line + ".abcjs-m" + element.measureNumber;
        }
        function setCursor(range) {
          if (range) {
            if (range.measureStart) {
              var selector = getLineAndMeasure(range);
              if (selector)
                measureCallback(selector);
            }
            if (cursor) {
              cursor.style.left = range.left + "px";
              cursor.style.top = range.top + "px";
              cursor.style.width = range.width + "px";
              cursor.style.height = range.height + "px";
            }
          } else {
            timer.stop();
            timer = void 0;
          }
        }
        timer = new TimingCallbacks(tune, {
          qpm: options.bpm,
          eventCallback: setCursor
        });
        timer.start();
      };
      animation.pauseAnimation = function(pause) {
        if (timer) {
          if (pause)
            timer.pause();
          else
            timer.start();
        }
      };
      animation.stopAnimation = function() {
        if (timer) {
          timer.stop();
          timer = void 0;
        }
      };
    })();
    module.exports = animation;
  }
});

// node_modules/abcjs/src/parse/abc_parse_directive.js
var require_abc_parse_directive = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse_directive.js"(exports, module) {
    var parseCommon = require_abc_common();
    var parseDirective = {};
    (function() {
      "use strict";
      var tokenizer;
      var warn;
      var multilineVars;
      var tune;
      parseDirective.initialize = function(tokenizer_, warn_, multilineVars_, tune_) {
        tokenizer = tokenizer_;
        warn = warn_;
        multilineVars = multilineVars_;
        tune = tune_;
        initializeFonts();
      };
      function initializeFonts() {
        multilineVars.annotationfont = { face: "Helvetica", size: 12, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.gchordfont = { face: "Helvetica", size: 12, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.historyfont = { face: '"Times New Roman"', size: 16, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.infofont = { face: '"Times New Roman"', size: 14, weight: "normal", style: "italic", decoration: "none" };
        multilineVars.measurefont = { face: '"Times New Roman"', size: 14, weight: "normal", style: "italic", decoration: "none" };
        multilineVars.partsfont = { face: '"Times New Roman"', size: 15, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.repeatfont = { face: '"Times New Roman"', size: 13, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.textfont = { face: '"Times New Roman"', size: 16, weight: "normal", style: "normal", decoration: "none" };
        multilineVars.tripletfont = { face: "Times", size: 11, weight: "normal", style: "italic", decoration: "none" };
        multilineVars.vocalfont = { face: '"Times New Roman"', size: 13, weight: "bold", style: "normal", decoration: "none" };
        multilineVars.wordsfont = { face: '"Times New Roman"', size: 16, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.composerfont = { face: '"Times New Roman"', size: 14, weight: "normal", style: "italic", decoration: "none" };
        tune.formatting.subtitlefont = { face: '"Times New Roman"', size: 16, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.tempofont = { face: '"Times New Roman"', size: 15, weight: "bold", style: "normal", decoration: "none" };
        tune.formatting.titlefont = { face: '"Times New Roman"', size: 20, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.footerfont = { face: '"Times New Roman"', size: 12, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.headerfont = { face: '"Times New Roman"', size: 12, weight: "normal", style: "normal", decoration: "none" };
        tune.formatting.voicefont = { face: '"Times New Roman"', size: 13, weight: "bold", style: "normal", decoration: "none" };
        tune.formatting.annotationfont = multilineVars.annotationfont;
        tune.formatting.gchordfont = multilineVars.gchordfont;
        tune.formatting.historyfont = multilineVars.historyfont;
        tune.formatting.infofont = multilineVars.infofont;
        tune.formatting.measurefont = multilineVars.measurefont;
        tune.formatting.partsfont = multilineVars.partsfont;
        tune.formatting.repeatfont = multilineVars.repeatfont;
        tune.formatting.textfont = multilineVars.textfont;
        tune.formatting.tripletfont = multilineVars.tripletfont;
        tune.formatting.vocalfont = multilineVars.vocalfont;
        tune.formatting.wordsfont = multilineVars.wordsfont;
      }
      var fontTypeCanHaveBox = { gchordfont: true, measurefont: true, partsfont: true };
      var fontTranslation = function(fontFace) {
        switch (fontFace) {
          case "Arial-Italic":
            return { face: "Arial", weight: "normal", style: "italic", decoration: "none" };
          case "Arial-Bold":
            return { face: "Arial", weight: "bold", style: "normal", decoration: "none" };
          case "Bookman-Demi":
            return { face: "Bookman,serif", weight: "bold", style: "normal", decoration: "none" };
          case "Bookman-DemiItalic":
            return { face: "Bookman,serif", weight: "bold", style: "italic", decoration: "none" };
          case "Bookman-Light":
            return { face: "Bookman,serif", weight: "normal", style: "normal", decoration: "none" };
          case "Bookman-LightItalic":
            return { face: "Bookman,serif", weight: "normal", style: "italic", decoration: "none" };
          case "Courier":
            return { face: '"Courier New"', weight: "normal", style: "normal", decoration: "none" };
          case "Courier-Oblique":
            return { face: '"Courier New"', weight: "normal", style: "italic", decoration: "none" };
          case "Courier-Bold":
            return { face: '"Courier New"', weight: "bold", style: "normal", decoration: "none" };
          case "Courier-BoldOblique":
            return { face: '"Courier New"', weight: "bold", style: "italic", decoration: "none" };
          case "AvantGarde-Book":
            return { face: "AvantGarde,Arial", weight: "normal", style: "normal", decoration: "none" };
          case "AvantGarde-BookOblique":
            return { face: "AvantGarde,Arial", weight: "normal", style: "italic", decoration: "none" };
          case "AvantGarde-Demi":
          case "Avant-Garde-Demi":
            return { face: "AvantGarde,Arial", weight: "bold", style: "normal", decoration: "none" };
          case "AvantGarde-DemiOblique":
            return { face: "AvantGarde,Arial", weight: "bold", style: "italic", decoration: "none" };
          case "Helvetica-Oblique":
            return { face: "Helvetica", weight: "normal", style: "italic", decoration: "none" };
          case "Helvetica-Bold":
            return { face: "Helvetica", weight: "bold", style: "normal", decoration: "none" };
          case "Helvetica-BoldOblique":
            return { face: "Helvetica", weight: "bold", style: "italic", decoration: "none" };
          case "Helvetica-Narrow":
            return { face: '"Helvetica Narrow",Helvetica', weight: "normal", style: "normal", decoration: "none" };
          case "Helvetica-Narrow-Oblique":
            return { face: '"Helvetica Narrow",Helvetica', weight: "normal", style: "italic", decoration: "none" };
          case "Helvetica-Narrow-Bold":
            return { face: '"Helvetica Narrow",Helvetica', weight: "bold", style: "normal", decoration: "none" };
          case "Helvetica-Narrow-BoldOblique":
            return { face: '"Helvetica Narrow",Helvetica', weight: "bold", style: "italic", decoration: "none" };
          case "Palatino-Roman":
            return { face: "Palatino", weight: "normal", style: "normal", decoration: "none" };
          case "Palatino-Italic":
            return { face: "Palatino", weight: "normal", style: "italic", decoration: "none" };
          case "Palatino-Bold":
            return { face: "Palatino", weight: "bold", style: "normal", decoration: "none" };
          case "Palatino-BoldItalic":
            return { face: "Palatino", weight: "bold", style: "italic", decoration: "none" };
          case "NewCenturySchlbk-Roman":
            return { face: '"New Century",serif', weight: "normal", style: "normal", decoration: "none" };
          case "NewCenturySchlbk-Italic":
            return { face: '"New Century",serif', weight: "normal", style: "italic", decoration: "none" };
          case "NewCenturySchlbk-Bold":
            return { face: '"New Century",serif', weight: "bold", style: "normal", decoration: "none" };
          case "NewCenturySchlbk-BoldItalic":
            return { face: '"New Century",serif', weight: "bold", style: "italic", decoration: "none" };
          case "Times":
          case "Times-Roman":
          case "Times-Narrow":
          case "Times-Courier":
          case "Times-New-Roman":
            return { face: '"Times New Roman"', weight: "normal", style: "normal", decoration: "none" };
          case "Times-Italic":
          case "Times-Italics":
            return { face: '"Times New Roman"', weight: "normal", style: "italic", decoration: "none" };
          case "Times-Bold":
            return { face: '"Times New Roman"', weight: "bold", style: "normal", decoration: "none" };
          case "Times-BoldItalic":
            return { face: '"Times New Roman"', weight: "bold", style: "italic", decoration: "none" };
          case "ZapfChancery-MediumItalic":
            return { face: '"Zapf Chancery",cursive,serif', weight: "normal", style: "normal", decoration: "none" };
          default:
            return null;
        }
      };
      var getFontParameter = function(tokens, currentSetting, str, position, cmd) {
        function processNumberOnly() {
          var size2 = parseInt(tokens[0].token);
          tokens.shift();
          if (!currentSetting) {
            warn("Can't set just the size of the font since there is no default value.", str, position);
            return { face: '"Times New Roman"', weight: "normal", style: "normal", decoration: "none", size: size2 };
          }
          if (tokens.length === 0) {
            return { face: currentSetting.face, weight: currentSetting.weight, style: currentSetting.style, decoration: currentSetting.decoration, size: size2 };
          }
          if (tokens.length === 1 && tokens[0].token === "box" && fontTypeCanHaveBox[cmd])
            return { face: currentSetting.face, weight: currentSetting.weight, style: currentSetting.style, decoration: currentSetting.decoration, size: size2, box: true };
          warn("Extra parameters in font definition.", str, position);
          return { face: currentSetting.face, weight: currentSetting.weight, style: currentSetting.style, decoration: currentSetting.decoration, size: size2 };
        }
        if (tokens[0].token === "*") {
          tokens.shift();
          if (tokens[0].type === "number")
            return processNumberOnly();
          else {
            warn("Expected font size number after *.", str, position);
          }
        }
        if (tokens[0].type === "number") {
          return processNumberOnly();
        }
        var face = [];
        var size;
        var weight = "normal";
        var style = "normal";
        var decoration = "none";
        var box = false;
        var state = "face";
        var hyphenLast = false;
        while (tokens.length) {
          var currToken = tokens.shift();
          var word = currToken.token.toLowerCase();
          switch (state) {
            case "face":
              if (hyphenLast || word !== "utf" && currToken.type !== "number" && word !== "bold" && word !== "italic" && word !== "underline" && word !== "box") {
                if (face.length > 0 && currToken.token === "-") {
                  hyphenLast = true;
                  face[face.length - 1] = face[face.length - 1] + currToken.token;
                } else {
                  if (hyphenLast) {
                    hyphenLast = false;
                    face[face.length - 1] = face[face.length - 1] + currToken.token;
                  } else
                    face.push(currToken.token);
                }
              } else {
                if (currToken.type === "number") {
                  if (size) {
                    warn("Font size specified twice in font definition.", str, position);
                  } else {
                    size = currToken.token;
                  }
                  state = "modifier";
                } else if (word === "bold")
                  weight = "bold";
                else if (word === "italic")
                  style = "italic";
                else if (word === "underline")
                  decoration = "underline";
                else if (word === "box") {
                  if (fontTypeCanHaveBox[cmd])
                    box = true;
                  else
                    warn(`This font style doesn't support "box"`, str, position);
                  state = "finished";
                } else if (word === "utf") {
                  currToken = tokens.shift();
                  state = "size";
                } else
                  warn("Unknown parameter " + currToken.token + " in font definition.", str, position);
              }
              break;
            case "size":
              if (currToken.type === "number") {
                if (size) {
                  warn("Font size specified twice in font definition.", str, position);
                } else {
                  size = currToken.token;
                }
              } else {
                warn("Expected font size in font definition.", str, position);
              }
              state = "modifier";
              break;
            case "modifier":
              if (word === "bold")
                weight = "bold";
              else if (word === "italic")
                style = "italic";
              else if (word === "underline")
                decoration = "underline";
              else if (word === "box") {
                if (fontTypeCanHaveBox[cmd])
                  box = true;
                else
                  warn(`This font style doesn't support "box"`, str, position);
                state = "finished";
              } else
                warn("Unknown parameter " + currToken.token + " in font definition.", str, position);
              break;
            case "finished":
              warn('Extra characters found after "box" in font definition.', str, position);
              break;
          }
        }
        if (size === void 0) {
          if (!currentSetting) {
            warn("Must specify the size of the font since there is no default value.", str, position);
            size = 12;
          } else
            size = currentSetting.size;
        } else
          size = parseFloat(size);
        face = face.join(" ");
        var psFont = fontTranslation(face);
        var font = {};
        if (psFont) {
          font.face = psFont.face;
          font.weight = psFont.weight;
          font.style = psFont.style;
          font.decoration = psFont.decoration;
          font.size = size;
          if (box)
            font.box = true;
          return font;
        }
        font.face = face;
        font.weight = weight;
        font.style = style;
        font.decoration = decoration;
        font.size = size;
        if (box)
          font.box = true;
        return font;
      };
      var getChangingFont = function(cmd, tokens, str) {
        if (tokens.length === 0)
          return 'Directive "' + cmd + '" requires a font as a parameter.';
        multilineVars[cmd] = getFontParameter(tokens, multilineVars[cmd], str, 0, cmd);
        if (multilineVars.is_in_header)
          tune.formatting[cmd] = multilineVars[cmd];
        return null;
      };
      var getGlobalFont = function(cmd, tokens, str) {
        if (tokens.length === 0)
          return 'Directive "' + cmd + '" requires a font as a parameter.';
        tune.formatting[cmd] = getFontParameter(tokens, tune.formatting[cmd], str, 0, cmd);
        return null;
      };
      var setScale = function(cmd, tokens) {
        var scratch = "";
        parseCommon.each(tokens, function(tok) {
          scratch += tok.token;
        });
        var num = parseFloat(scratch);
        if (isNaN(num) || num === 0)
          return 'Directive "' + cmd + '" requires a number as a parameter.';
        tune.formatting.scale = num;
      };
      var getRequiredMeasurement = function(cmd, tokens) {
        var points = tokenizer.getMeasurement(tokens);
        if (points.used === 0 || tokens.length !== 0)
          return { error: 'Directive "' + cmd + '" requires a measurement as a parameter.' };
        return points.value;
      };
      var oneParameterMeasurement = function(cmd, tokens) {
        var points = tokenizer.getMeasurement(tokens);
        if (points.used === 0 || tokens.length !== 0)
          return 'Directive "' + cmd + '" requires a measurement as a parameter.';
        tune.formatting[cmd] = points.value;
        return null;
      };
      var addMultilineVar = function(key, cmd, tokens, min, max) {
        if (tokens.length !== 1 || tokens[0].type !== "number")
          return 'Directive "' + cmd + '" requires a number as a parameter.';
        var i = tokens[0].intt;
        if (min !== void 0 && i < min)
          return 'Directive "' + cmd + '" requires a number greater than or equal to ' + min + " as a parameter.";
        if (max !== void 0 && i > max)
          return 'Directive "' + cmd + '" requires a number less than or equal to ' + max + " as a parameter.";
        multilineVars[key] = i;
        return null;
      };
      var addMultilineVarBool = function(key, cmd, tokens) {
        if (tokens.length === 1 && (tokens[0].token === "true" || tokens[0].token === "false")) {
          multilineVars[key] = tokens[0].token === "true";
          return null;
        }
        var str = addMultilineVar(key, cmd, tokens, 0, 1);
        if (str !== null) return str;
        multilineVars[key] = multilineVars[key] === 1;
        return null;
      };
      var addMultilineVarOneParamChoice = function(key, cmd, tokens, choices) {
        if (tokens.length !== 1)
          return 'Directive "' + cmd + '" requires one of [ ' + choices.join(", ") + " ] as a parameter.";
        var choice = tokens[0].token;
        var found = false;
        for (var i = 0; !found && i < choices.length; i++) {
          if (choices[i] === choice)
            found = true;
        }
        if (!found)
          return 'Directive "' + cmd + '" requires one of [ ' + choices.join(", ") + " ] as a parameter.";
        multilineVars[key] = choice;
        return null;
      };
      var midiCmdParam0 = [
        "nobarlines",
        "barlines",
        "beataccents",
        "nobeataccents",
        "droneon",
        "droneoff",
        "drumon",
        "drumoff",
        "fermatafixed",
        "fermataproportional",
        "gchordon",
        "gchordoff",
        "controlcombo",
        "temperamentnormal",
        "noportamento"
      ];
      var midiCmdParam1String = [
        "gchord",
        "ptstress",
        "beatstring"
      ];
      var midiCmdParam1Integer = [
        "bassvol",
        "chordvol",
        "c",
        "channel",
        "beatmod",
        "deltaloudness",
        "drumbars",
        "gracedivider",
        "makechordchannels",
        "randomchordattack",
        "chordattack",
        "stressmodel",
        "transpose",
        "rtranspose",
        "vol",
        "volinc"
      ];
      var midiCmdParam1Integer1OptionalInteger = [
        "program"
      ];
      var midiCmdParam2Integer = [
        "ratio",
        "snt",
        "bendvelocity",
        "pitchbend",
        "control",
        "temperamentlinear"
      ];
      var midiCmdParam4Integer = [
        "beat"
      ];
      var midiCmdParam5Integer = [
        "drone"
      ];
      var midiCmdParam1IntegerOptionalOctave = [
        "bassprog",
        "chordprog"
      ];
      var midiCmdParam1String1Integer = [
        "portamento"
      ];
      var midiCmdParamFraction = [
        "expand",
        "grace",
        "trim"
      ];
      var midiCmdParam1StringVariableIntegers = [
        "drum",
        "chordname"
      ];
      var parseMidiCommand = function(midi, tune2, restOfString) {
        var midi_cmd = midi.shift().token;
        var midi_params = [];
        if (midiCmdParam0.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 0)
            warn("Unexpected parameter in MIDI " + midi_cmd, restOfString, 0);
        } else if (midiCmdParam1String.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 1)
            warn("Expected one parameter in MIDI " + midi_cmd, restOfString, 0);
          else
            midi_params.push(midi[0].token);
        } else if (midiCmdParam1Integer.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 1)
            warn("Expected one parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number")
            warn("Expected one integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else
            midi_params.push(midi[0].intt);
        } else if (midiCmdParam1Integer1OptionalInteger.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 1 && midi.length !== 2)
            warn("Expected one or two parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number")
            warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi.length === 2 && midi[1].type !== "number")
            warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            if (midi.length === 2)
              midi_params.push(midi[1].intt);
          }
        } else if (midiCmdParam2Integer.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 2)
            warn("Expected two parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number" || midi[1].type !== "number")
            warn("Expected two integer parameters in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            midi_params.push(midi[1].intt);
          }
        } else if (midiCmdParam1String1Integer.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 2)
            warn("Expected two parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "alpha" || midi[1].type !== "number")
            warn("Expected one string and one integer parameters in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].token);
            midi_params.push(midi[1].intt);
          }
        } else if (midi_cmd === "drummap") {
          if (midi.length === 2 && midi[0].type === "alpha" && midi[1].type === "number") {
            if (!tune2.formatting) tune2.formatting = {};
            if (!tune2.formatting.midi) tune2.formatting.midi = {};
            if (!tune2.formatting.midi.drummap) tune2.formatting.midi.drummap = {};
            tune2.formatting.midi.drummap[midi[0].token] = midi[1].intt;
            midi_params = tune2.formatting.midi.drummap;
          } else if (midi.length === 3 && midi[0].type === "punct" && midi[1].type === "alpha" && midi[2].type === "number") {
            if (!tune2.formatting) tune2.formatting = {};
            if (!tune2.formatting.midi) tune2.formatting.midi = {};
            if (!tune2.formatting.midi.drummap) tune2.formatting.midi.drummap = {};
            tune2.formatting.midi.drummap[midi[0].token + midi[1].token] = midi[2].intt;
            midi_params = tune2.formatting.midi.drummap;
          } else {
            warn("Expected one note name and one integer parameter in MIDI " + midi_cmd, restOfString, 0);
          }
        } else if (midiCmdParamFraction.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 3)
            warn("Expected fraction parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number" || midi[1].token !== "/" || midi[2].type !== "number")
            warn("Expected fraction parameter in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            midi_params.push(midi[2].intt);
          }
        } else if (midiCmdParam4Integer.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 4)
            warn("Expected four parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number" || midi[1].type !== "number" || midi[2].type !== "number" || midi[3].type !== "number")
            warn("Expected four integer parameters in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            midi_params.push(midi[1].intt);
            midi_params.push(midi[2].intt);
            midi_params.push(midi[3].intt);
          }
        } else if (midiCmdParam5Integer.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 5)
            warn("Expected five parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number" || midi[1].type !== "number" || midi[2].type !== "number" || midi[3].type !== "number" || midi[4].type !== "number")
            warn("Expected five integer parameters in MIDI " + midi_cmd, restOfString, 0);
          else {
            midi_params.push(midi[0].intt);
            midi_params.push(midi[1].intt);
            midi_params.push(midi[2].intt);
            midi_params.push(midi[3].intt);
            midi_params.push(midi[4].intt);
          }
        } else if (midiCmdParam1Integer1OptionalInteger.indexOf(midi_cmd) >= 0) {
          if (midi.length !== 1 || midi.length !== 4)
            warn("Expected one or two parameters in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "number")
            warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi.length === 4) {
            if (midi[1].token !== "octave")
              warn("Expected octave parameter in MIDI " + midi_cmd, restOfString, 0);
            if (midi[2].token !== "=")
              warn("Expected octave parameter in MIDI " + midi_cmd, restOfString, 0);
            if (midi[3].type !== "number")
              warn("Expected integer parameter for octave in MIDI " + midi_cmd, restOfString, 0);
          } else {
            midi_params.push(midi[0].intt);
            if (midi.length === 4)
              midi_params.push(midi[3].intt);
          }
        } else if (midiCmdParam1StringVariableIntegers.indexOf(midi_cmd) >= 0) {
          if (midi.length < 2)
            warn("Expected string parameter and at least one integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else if (midi[0].type !== "alpha")
            warn("Expected string parameter and at least one integer parameter in MIDI " + midi_cmd, restOfString, 0);
          else {
            var p = midi.shift();
            midi_params.push(p.token);
            while (midi.length > 0) {
              p = midi.shift();
              if (p.type !== "number")
                warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
              midi_params.push(p.intt);
            }
          }
        }
        if (tune2.hasBeginMusic())
          tune2.appendElement("midi", -1, -1, { cmd: midi_cmd, params: midi_params });
        else {
          if (tune2.formatting["midi"] === void 0)
            tune2.formatting["midi"] = {};
          tune2.formatting["midi"][midi_cmd] = midi_params;
        }
      };
      parseDirective.parseFontChangeLine = function(textstr) {
        var textParts = textstr.split("$");
        if (textParts.length > 1 && multilineVars.setfont) {
          var textarr = [{ text: textParts[0] }];
          for (var i = 1; i < textParts.length; i++) {
            if (textParts[i].charAt(0) === "0")
              textarr.push({ text: textParts[i].substring(1) });
            else if (textParts[i].charAt(0) === "1" && multilineVars.setfont[1])
              textarr.push({ font: multilineVars.setfont[1], text: textParts[i].substring(1) });
            else if (textParts[i].charAt(0) === "2" && multilineVars.setfont[2])
              textarr.push({ font: multilineVars.setfont[2], text: textParts[i].substring(1) });
            else if (textParts[i].charAt(0) === "3" && multilineVars.setfont[3])
              textarr.push({ font: multilineVars.setfont[3], text: textParts[i].substring(1) });
            else if (textParts[i].charAt(0) === "4" && multilineVars.setfont[4])
              textarr.push({ font: multilineVars.setfont[4], text: textParts[i].substring(1) });
            else
              textarr[textarr.length - 1].text += "$" + textParts[i];
          }
          if (textarr.length > 1)
            return textarr;
        }
        return textstr;
      };
      var positionChoices = ["auto", "above", "below", "hidden"];
      parseDirective.addDirective = function(str) {
        var tokens = tokenizer.tokenize(str, 0, str.length);
        if (tokens.length === 0 || tokens[0].type !== "alpha") return null;
        var restOfString = str.substring(str.indexOf(tokens[0].token) + tokens[0].token.length);
        restOfString = tokenizer.stripComment(restOfString);
        var cmd = tokens.shift().token.toLowerCase();
        var scratch = "";
        switch (cmd) {
          // The following directives were added to abc_parser_lint, but haven't been implemented here.
          // Most of them are direct translations from the directives that will be parsed in. See abcm2ps's format.txt for info on each of these.
          //					alignbars: { type: "number", optional: true },
          //					aligncomposer: { type: "string", Enum: [ 'left', 'center','right' ], optional: true },
          //					bstemdown: { type: "boolean", optional: true },
          //					continueall: { type: "boolean", optional: true },
          //					dynalign: { type: "boolean", optional: true },
          //					exprabove: { type: "boolean", optional: true },
          //					exprbelow: { type: "boolean", optional: true },
          //					gchordbox: { type: "boolean", optional: true },
          //					graceslurs: { type: "boolean", optional: true },
          //					gracespacebefore: { type: "number", optional: true },
          //					gracespaceinside: { type: "number", optional: true },
          //					gracespaceafter: { type: "number", optional: true },
          //					infospace: { type: "number", optional: true },
          //					lineskipfac: { type: "number", optional: true },
          //					maxshrink: { type: "number", optional: true },
          //					maxstaffsep: { type: "number", optional: true },
          //					maxsysstaffsep: { type: "number", optional: true },
          //					notespacingfactor: { type: "number", optional: true },
          //					parskipfac: { type: "number", optional: true },
          //					slurheight: { type: "number", optional: true },
          //					splittune: { type: "boolean", optional: true },
          //					squarebreve: { type: "boolean", optional: true },
          //					stemheight: { type: "number", optional: true },
          //					straightflags: { type: "boolean", optional: true },
          //					stretchstaff: { type: "boolean", optional: true },
          //					titleformat: { type: "string", optional: true },
          case "bagpipes":
            tune.formatting.bagpipes = true;
            break;
          case "flatbeams":
            tune.formatting.flatbeams = true;
            break;
          case "landscape":
            multilineVars.landscape = true;
            break;
          case "papersize":
            multilineVars.papersize = restOfString;
            break;
          case "slurgraces":
            tune.formatting.slurgraces = true;
            break;
          case "stretchlast":
            tune.formatting.stretchlast = true;
            break;
          case "titlecaps":
            multilineVars.titlecaps = true;
            break;
          case "titleleft":
            tune.formatting.titleleft = true;
            break;
          case "measurebox":
            tune.formatting.measurebox = true;
            break;
          case "vocal":
            return addMultilineVarOneParamChoice("vocalPosition", cmd, tokens, positionChoices);
          case "dynamic":
            return addMultilineVarOneParamChoice("dynamicPosition", cmd, tokens, positionChoices);
          case "gchord":
            return addMultilineVarOneParamChoice("chordPosition", cmd, tokens, positionChoices);
          case "ornament":
            return addMultilineVarOneParamChoice("ornamentPosition", cmd, tokens, positionChoices);
          case "volume":
            return addMultilineVarOneParamChoice("volumePosition", cmd, tokens, positionChoices);
          case "botmargin":
          case "botspace":
          case "composerspace":
          case "indent":
          case "leftmargin":
          case "linesep":
          case "musicspace":
          case "partsspace":
          case "pageheight":
          case "pagewidth":
          case "rightmargin":
          case "staffsep":
          case "staffwidth":
          case "subtitlespace":
          case "sysstaffsep":
          case "systemsep":
          case "textspace":
          case "titlespace":
          case "topmargin":
          case "topspace":
          case "vocalspace":
          case "wordsspace":
            return oneParameterMeasurement(cmd, tokens);
          case "voicescale":
            if (tokens.length !== 1 || tokens[0].type !== "number")
              return "voicescale requires one float as a parameter";
            var voiceScale = tokens.shift();
            if (multilineVars.currentVoice) {
              multilineVars.currentVoice.scale = voiceScale.floatt;
              tune.changeVoiceScale(multilineVars.currentVoice.scale);
            }
            return null;
          case "vskip":
            var vskip = getRequiredMeasurement(cmd, tokens);
            if (vskip.error)
              return vskip.error;
            tune.addSpacing(vskip);
            return null;
          case "scale":
            setScale(cmd, tokens);
            break;
          case "sep":
            if (tokens.length === 0)
              tune.addSeparator();
            else {
              var points = tokenizer.getMeasurement(tokens);
              if (points.used === 0)
                return 'Directive "' + cmd + '" requires 3 numbers: space above, space below, length of line';
              var spaceAbove = points.value;
              points = tokenizer.getMeasurement(tokens);
              if (points.used === 0)
                return 'Directive "' + cmd + '" requires 3 numbers: space above, space below, length of line';
              var spaceBelow = points.value;
              points = tokenizer.getMeasurement(tokens);
              if (points.used === 0 || tokens.length !== 0)
                return 'Directive "' + cmd + '" requires 3 numbers: space above, space below, length of line';
              var lenLine = points.value;
              tune.addSeparator(spaceAbove, spaceBelow, lenLine);
            }
            break;
          case "barsperstaff":
            scratch = addMultilineVar("barsperstaff", cmd, tokens);
            if (scratch !== null) return scratch;
            break;
          case "staffnonote":
            if (tokens.length !== 1)
              return "Directive staffnonote requires one parameter: 0 or 1";
            if (tokens[0].token === "0")
              multilineVars.staffnonote = true;
            else if (tokens[0].token === "1")
              multilineVars.staffnonote = false;
            else
              return "Directive staffnonote requires one parameter: 0 or 1 (received " + tokens[0].token + ")";
            break;
          case "printtempo":
            scratch = addMultilineVarBool("printTempo", cmd, tokens);
            if (scratch !== null) return scratch;
            break;
          case "partsbox":
            scratch = addMultilineVarBool("partsBox", cmd, tokens);
            if (scratch !== null) return scratch;
            multilineVars.partsfont.box = multilineVars.partsBox;
            break;
          case "freegchord":
            scratch = addMultilineVarBool("freegchord", cmd, tokens);
            if (scratch !== null) return scratch;
            break;
          case "measurenb":
          case "barnumbers":
            scratch = addMultilineVar("barNumbers", cmd, tokens);
            if (scratch !== null) return scratch;
            break;
          case "setbarnb":
            if (tokens.length !== 1 || tokens[0].type !== "number") {
              return "Directive setbarnb requires a number as a parameter.";
            }
            multilineVars.currBarNumber = tune.setBarNumberImmediate(tokens[0].intt);
            break;
          case "begintext":
            multilineVars.inTextBlock = true;
            break;
          case "continueall":
            multilineVars.continueall = true;
            break;
          case "beginps":
            multilineVars.inPsBlock = true;
            warn("Postscript ignored", str, 0);
            break;
          case "deco":
            if (restOfString.length > 0)
              multilineVars.ignoredDecorations.push(restOfString.substring(0, restOfString.indexOf(" ")));
            warn("Decoration redefinition ignored", str, 0);
            break;
          case "text":
            var textstr = tokenizer.translateString(restOfString);
            tune.addText(parseDirective.parseFontChangeLine(textstr));
            break;
          case "center":
            var centerstr = tokenizer.translateString(restOfString);
            tune.addCentered(parseDirective.parseFontChangeLine(centerstr));
            break;
          case "font":
            break;
          case "setfont":
            var sfTokens = tokenizer.tokenize(restOfString, 0, restOfString.length);
            if (sfTokens.length >= 4) {
              if (sfTokens[0].token === "-" && sfTokens[1].type === "number") {
                var sfNum = parseInt(sfTokens[1].token);
                if (sfNum >= 1 && sfNum <= 4) {
                  if (!multilineVars.setfont)
                    multilineVars.setfont = [];
                  sfTokens.shift();
                  sfTokens.shift();
                  multilineVars.setfont[sfNum] = getFontParameter(sfTokens, multilineVars.setfont[sfNum], str, 0, "setfont");
                }
              }
            }
            break;
          case "gchordfont":
          case "partsfont":
          case "tripletfont":
          case "vocalfont":
          case "textfont":
          case "annotationfont":
          case "historyfont":
          case "infofont":
          case "measurefont":
          case "repeatfont":
          case "wordsfont":
            return getChangingFont(cmd, tokens, str);
          case "composerfont":
          case "subtitlefont":
          case "tempofont":
          case "titlefont":
          case "voicefont":
          case "footerfont":
          case "headerfont":
            return getGlobalFont(cmd, tokens, str);
          case "barlabelfont":
          case "barnumberfont":
          case "barnumfont":
            return getChangingFont("measurefont", tokens, str);
          case "staves":
          case "score":
            multilineVars.score_is_present = true;
            var addVoice = function(id, newStaff2, bracket2, brace2, continueBar2) {
              if (newStaff2 || multilineVars.staves.length === 0) {
                multilineVars.staves.push({ index: multilineVars.staves.length, numVoices: 0 });
              }
              var staff = parseCommon.last(multilineVars.staves);
              if (bracket2 !== void 0) staff.bracket = bracket2;
              if (brace2 !== void 0) staff.brace = brace2;
              if (continueBar2) staff.connectBarLines = "end";
              if (multilineVars.voices[id] === void 0) {
                multilineVars.voices[id] = { staffNum: staff.index, index: staff.numVoices };
                staff.numVoices++;
              }
            };
            var openParen = false;
            var openBracket = false;
            var openBrace = false;
            var justOpenParen = false;
            var justOpenBracket = false;
            var justOpenBrace = false;
            var continueBar = false;
            var lastVoice;
            var addContinueBar = function() {
              continueBar = true;
              if (lastVoice) {
                var ty = "start";
                if (lastVoice.staffNum > 0) {
                  if (multilineVars.staves[lastVoice.staffNum - 1].connectBarLines === "start" || multilineVars.staves[lastVoice.staffNum - 1].connectBarLines === "continue")
                    ty = "continue";
                }
                multilineVars.staves[lastVoice.staffNum].connectBarLines = ty;
              }
            };
            while (tokens.length) {
              var t = tokens.shift();
              switch (t.token) {
                case "(":
                  if (openParen) warn("Can't nest parenthesis in %%score", str, t.start);
                  else {
                    openParen = true;
                    justOpenParen = true;
                  }
                  break;
                case ")":
                  if (!openParen || justOpenParen) warn("Unexpected close parenthesis in %%score", str, t.start);
                  else openParen = false;
                  break;
                case "[":
                  if (openBracket) warn("Can't nest brackets in %%score", str, t.start);
                  else {
                    openBracket = true;
                    justOpenBracket = true;
                  }
                  break;
                case "]":
                  if (!openBracket || justOpenBracket) warn("Unexpected close bracket in %%score", str, t.start);
                  else {
                    openBracket = false;
                    multilineVars.staves[lastVoice.staffNum].bracket = "end";
                  }
                  break;
                case "{":
                  if (openBrace) warn("Can't nest braces in %%score", str, t.start);
                  else {
                    openBrace = true;
                    justOpenBrace = true;
                  }
                  break;
                case "}":
                  if (!openBrace || justOpenBrace) warn("Unexpected close brace in %%score", str, t.start);
                  else {
                    openBrace = false;
                    multilineVars.staves[lastVoice.staffNum].brace = "end";
                  }
                  break;
                case "|":
                  addContinueBar();
                  break;
                default:
                  var vc = "";
                  while (t.type === "alpha" || t.type === "number") {
                    vc += t.token;
                    if (t.continueId)
                      t = tokens.shift();
                    else
                      break;
                  }
                  var newStaff = !openParen || justOpenParen;
                  var bracket = justOpenBracket ? "start" : openBracket ? "continue" : void 0;
                  var brace = justOpenBrace ? "start" : openBrace ? "continue" : void 0;
                  addVoice(vc, newStaff, bracket, brace, continueBar);
                  justOpenParen = false;
                  justOpenBracket = false;
                  justOpenBrace = false;
                  continueBar = false;
                  lastVoice = multilineVars.voices[vc];
                  if (cmd === "staves")
                    addContinueBar();
                  break;
              }
            }
            break;
          case "newpage":
            var pgNum = tokenizer.getInt(restOfString);
            tune.addNewPage(pgNum.digits === 0 ? -1 : pgNum.value);
            break;
          case "abc":
            var arr = restOfString.split(" ");
            switch (arr[0]) {
              case "-copyright":
              case "-creator":
              case "-edited-by":
              case "-version":
              case "-charset":
                var subCmd = arr.shift();
                tune.addMetaText(cmd + subCmd, arr.join(" "));
                break;
              default:
                return "Unknown directive: " + cmd + arr[0];
            }
            break;
          case "header":
          case "footer":
            var footerStr = tokenizer.getMeat(restOfString, 0, restOfString.length);
            footerStr = restOfString.substring(footerStr.start, footerStr.end);
            if (footerStr.charAt(0) === '"' && footerStr.charAt(footerStr.length - 1) === '"')
              footerStr = footerStr.substring(1, footerStr.length - 1);
            var footerArr = footerStr.split("	");
            var footer = {};
            if (footerArr.length === 1)
              footer = { left: "", center: footerArr[0], right: "" };
            else if (footerArr.length === 2)
              footer = { left: footerArr[0], center: footerArr[1], right: "" };
            else
              footer = { left: footerArr[0], center: footerArr[1], right: footerArr[2] };
            if (footerArr.length > 3)
              warn("Too many tabs in " + cmd + ": " + footerArr.length + " found.", restOfString, 0);
            tune.addMetaTextObj(cmd, footer);
            break;
          case "midi":
            var midi = tokenizer.tokenize(restOfString, 0, restOfString.length, true);
            if (midi.length > 0 && midi[0].token === "=")
              midi.shift();
            if (midi.length === 0)
              warn("Expected midi command", restOfString, 0);
            else
              parseMidiCommand(midi, tune, restOfString);
            break;
          case "map":
          case "percmap":
          case "playtempo":
          case "auquality":
          case "continuous":
          case "nobarcheck":
            tune.formatting[cmd] = restOfString;
            break;
          default:
            return "Unknown directive: " + cmd;
        }
        return null;
      };
      parseDirective.globalFormatting = function(formatHash) {
        for (var cmd in formatHash) {
          if (formatHash.hasOwnProperty(cmd)) {
            var value = "" + formatHash[cmd];
            var tokens = tokenizer.tokenize(value, 0, value.length);
            var scratch;
            switch (cmd) {
              case "titlefont":
              case "gchordfont":
              case "composerfont":
              case "footerfont":
              case "headerfont":
              case "historyfont":
              case "infofont":
              case "measurefont":
              case "partsfont":
              case "repeatfont":
              case "subtitlefont":
              case "tempofont":
              case "textfont":
              case "voicefont":
              case "tripletfont":
              case "vocalfont":
              case "wordsfont":
              case "annotationfont":
                getChangingFont(cmd, tokens, value);
                break;
              case "scale":
                setScale(cmd, tokens);
                break;
              case "partsbox":
                scratch = addMultilineVarBool("partsBox", cmd, tokens);
                if (scratch !== null) warn(scratch);
                multilineVars.partsfont.box = multilineVars.partsBox;
                break;
              case "freegchord":
                scratch = addMultilineVarBool("freegchord", cmd, tokens);
                if (scratch !== null) warn(scratch);
              default:
                warn("Formatting directive unrecognized: ", cmd, 0);
            }
          }
        }
      };
    })();
    module.exports = parseDirective;
  }
});

// node_modules/abcjs/src/parse/abc_transpose.js
var require_abc_transpose = __commonJS({
  "node_modules/abcjs/src/parse/abc_transpose.js"(exports, module) {
    var transpose = {};
    var keyIndex = {
      "C": 0,
      "C#": 1,
      "Db": 1,
      "D": 2,
      "D#": 3,
      "Eb": 3,
      "E": 4,
      "F": 5,
      "F#": 6,
      "Gb": 6,
      "G": 7,
      "G#": 8,
      "Ab": 8,
      "A": 9,
      "A#": 10,
      "Bb": 10,
      "B": 11
    };
    var newKey = ["C", "Db", "D", "Eb", "E", "F", "F#", "G", "Ab", "A", "Bb", "B"];
    var newKeyMinor = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "Bb", "B"];
    transpose.keySignature = function(multilineVars, keys, keyName, root, acc, localTranspose) {
      if (!localTranspose) localTranspose = 0;
      multilineVars.localTransposeVerticalMovement = 0;
      multilineVars.localTransposePreferFlats = false;
      var k = keys[keyName];
      if (!k) return multilineVars.key;
      multilineVars.localTranspose = (multilineVars.globalTranspose ? multilineVars.globalTranspose : 0) + localTranspose;
      if (!multilineVars.localTranspose)
        return { accidentals: k, root, acc };
      multilineVars.globalTransposeOrigKeySig = k;
      if (multilineVars.localTranspose % 12 === 0) {
        multilineVars.localTransposeVerticalMovement = multilineVars.localTranspose / 12 * 7;
        return { accidentals: k, root, acc };
      }
      var baseKey = keyName[0];
      if (keyName[1] === "b" || keyName[1] === "#") {
        baseKey += keyName[1];
        keyName = keyName.substr(2);
      } else
        keyName = keyName.substr(1);
      var index = keyIndex[baseKey] + multilineVars.localTranspose;
      while (index < 0) index += 12;
      if (index > 11) index = index % 12;
      var newKeyName = keyName[0] === "m" ? newKeyMinor[index] : newKey[index];
      var transposedKey = newKeyName + keyName;
      var newKeySig = keys[transposedKey];
      if (newKeySig.length > 0 && newKeySig[0].acc === "flat")
        multilineVars.localTransposePreferFlats = true;
      var distance = transposedKey.charCodeAt(0) - baseKey.charCodeAt(0);
      if (multilineVars.localTranspose > 0) {
        if (distance < 0)
          distance += 7;
        else if (distance === 0) {
          if (baseKey[1] === "#" || transposedKey[1] === "b")
            distance += 7;
        }
      } else if (multilineVars.localTranspose < 0) {
        if (distance > 0)
          distance -= 7;
        else if (distance === 0) {
          if (baseKey[1] === "b" || transposedKey[1] === "#")
            distance -= 7;
        }
      }
      if (multilineVars.localTranspose > 0)
        multilineVars.localTransposeVerticalMovement = distance + Math.floor(multilineVars.localTranspose / 12) * 7;
      else
        multilineVars.localTransposeVerticalMovement = distance + Math.ceil(multilineVars.localTranspose / 12) * 7;
      return { accidentals: newKeySig, root: newKeyName[0], acc: newKeyName.length > 1 ? newKeyName[1] : "" };
    };
    var sharpChords = ["C", "C", "D", "D", "E", "F", "F", "G", "G", "A", "A", "B"];
    var flatChords = ["C", "D", "D", "E", "E", "F", "G", "G", "A", "A", "B", "B"];
    var sharpChordsFree = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    var flatChordsFree = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
    transpose.chordName = function(multilineVars, chord) {
      if (multilineVars.localTranspose && multilineVars.localTranspose % 12 !== 0) {
        var transposeFactor = multilineVars.localTranspose;
        while (transposeFactor < 0) transposeFactor += 12;
        if (transposeFactor > 11) transposeFactor = transposeFactor % 12;
        if (multilineVars.freegchord) {
          chord = chord.replace(/Cb/g, "`~11`");
          chord = chord.replace(/Db/g, "`~1`");
          chord = chord.replace(/Eb/g, "`~3`");
          chord = chord.replace(/Fb/g, "`~4`");
          chord = chord.replace(/Gb/g, "`~6`");
          chord = chord.replace(/Ab/g, "`~8`");
          chord = chord.replace(/Bb/g, "`~10`");
          chord = chord.replace(/C#/g, "`~1`");
          chord = chord.replace(/D#/g, "`~3`");
          chord = chord.replace(/E#/g, "`~5`");
          chord = chord.replace(/F#/g, "`~6`");
          chord = chord.replace(/G#/g, "`~8`");
          chord = chord.replace(/A#/g, "`~10`");
          chord = chord.replace(/B#/g, "`~0`");
        } else {
          chord = chord.replace(/C/g, "`~11`");
          chord = chord.replace(/D/g, "`~1`");
          chord = chord.replace(/E/g, "`~3`");
          chord = chord.replace(/F/g, "`~4`");
          chord = chord.replace(/G/g, "`~6`");
          chord = chord.replace(/A/g, "`~8`");
          chord = chord.replace(/B/g, "`~10`");
          chord = chord.replace(/C/g, "`~1`");
          chord = chord.replace(/D/g, "`~3`");
          chord = chord.replace(/E/g, "`~5`");
          chord = chord.replace(/F/g, "`~6`");
          chord = chord.replace(/G/g, "`~8`");
          chord = chord.replace(/A/g, "`~10`");
          chord = chord.replace(/B/g, "`~0`");
        }
        chord = chord.replace(/C/g, "`~0`");
        chord = chord.replace(/D/g, "`~2`");
        chord = chord.replace(/E/g, "`~4`");
        chord = chord.replace(/F/g, "`~5`");
        chord = chord.replace(/G/g, "`~7`");
        chord = chord.replace(/A/g, "`~9`");
        chord = chord.replace(/B/g, "`~11`");
        var arr = chord.split("`");
        for (var i = 0; i < arr.length; i++) {
          if (arr[i][0] === "~") {
            var chordNum = parseInt(arr[i].substr(1), 10);
            chordNum += transposeFactor;
            if (chordNum > 11) chordNum -= 12;
            if (multilineVars.freegchord)
              arr[i] = multilineVars.localTransposePreferFlats ? flatChordsFree[chordNum] : sharpChordsFree[chordNum];
            else
              arr[i] = multilineVars.localTransposePreferFlats ? flatChords[chordNum] : sharpChords[chordNum];
          }
        }
        chord = arr.join("");
      }
      return chord;
    };
    var pitchToLetter = ["c", "d", "e", "f", "g", "a", "b"];
    function accidentalChange(origPitch, newPitch, accidental, origKeySig, newKeySig) {
      var origPitchLetter = pitchToLetter[(origPitch + 49) % 7];
      var origAccidental = 0;
      for (var i = 0; i < origKeySig.length; i++) {
        if (origKeySig[i].note.toLowerCase() === origPitchLetter)
          origAccidental = accidentals[origKeySig[i].acc];
      }
      var currentAccidental = accidentals[accidental];
      var delta = currentAccidental - origAccidental;
      var newPitchLetter = pitchToLetter[(newPitch + 49) % 7];
      var newAccidental = 0;
      for (var j = 0; j < newKeySig.accidentals.length; j++) {
        if (newKeySig.accidentals[j].note.toLowerCase() === newPitchLetter)
          newAccidental = accidentals[newKeySig.accidentals[j].acc];
      }
      var calcAccidental = delta + newAccidental;
      if (calcAccidental < -2) {
        newPitch--;
        calcAccidental += newPitchLetter === "c" || newPitchLetter === "f" ? 1 : 2;
      }
      if (calcAccidental > 2) {
        newPitch++;
        calcAccidental -= newPitchLetter === "b" || newPitchLetter === "e" ? 1 : 2;
      }
      return [newPitch, calcAccidental];
    }
    var accidentals = {
      dblflat: -2,
      flat: -1,
      natural: 0,
      sharp: 1,
      dblsharp: 2
    };
    var accidentals2 = {
      "-2": "dblflat",
      "-1": "flat",
      "0": "natural",
      "1": "sharp",
      "2": "dblsharp"
    };
    transpose.note = function(multilineVars, el) {
      if (!multilineVars.localTranspose)
        return;
      var origPitch = el.pitch;
      el.pitch = el.pitch + multilineVars.localTransposeVerticalMovement;
      if (el.accidental) {
        var ret = accidentalChange(origPitch, el.pitch, el.accidental, multilineVars.globalTransposeOrigKeySig, multilineVars.targetKey);
        el.pitch = ret[0];
        el.accidental = accidentals2[ret[1]];
      }
    };
    module.exports = transpose;
  }
});

// node_modules/abcjs/src/parse/abc_parse_key_voice.js
var require_abc_parse_key_voice = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse_key_voice.js"(exports, module) {
    var parseCommon = require_abc_common();
    var parseDirective = require_abc_parse_directive();
    var transpose = require_abc_transpose();
    var parseKeyVoice = {};
    (function() {
      var tokenizer;
      var warn;
      var multilineVars;
      var tune;
      parseKeyVoice.initialize = function(tokenizer_, warn_, multilineVars_, tune_) {
        tokenizer = tokenizer_;
        warn = warn_;
        multilineVars = multilineVars_;
        tune = tune_;
      };
      parseKeyVoice.standardKey = function(keyName, root, acc, localTranspose) {
        var key1sharp = { acc: "sharp", note: "f" };
        var key2sharp = { acc: "sharp", note: "c" };
        var key3sharp = { acc: "sharp", note: "g" };
        var key4sharp = { acc: "sharp", note: "d" };
        var key5sharp = { acc: "sharp", note: "A" };
        var key6sharp = { acc: "sharp", note: "e" };
        var key7sharp = { acc: "sharp", note: "B" };
        var key1flat = { acc: "flat", note: "B" };
        var key2flat = { acc: "flat", note: "e" };
        var key3flat = { acc: "flat", note: "A" };
        var key4flat = { acc: "flat", note: "d" };
        var key5flat = { acc: "flat", note: "G" };
        var key6flat = { acc: "flat", note: "c" };
        var key7flat = { acc: "flat", note: "F" };
        var keys = {
          "C#": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
          "A#m": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
          "G#Mix": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
          "D#Dor": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
          "E#Phr": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
          "F#Lyd": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
          "B#Loc": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp],
          "F#": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp],
          "D#m": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp],
          "C#Mix": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp],
          "G#Dor": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp],
          "A#Phr": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp],
          "BLyd": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp],
          "E#Loc": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp],
          "B": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp],
          "G#m": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp],
          "F#Mix": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp],
          "C#Dor": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp],
          "D#Phr": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp],
          "ELyd": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp],
          "A#Loc": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp],
          "E": [key1sharp, key2sharp, key3sharp, key4sharp],
          "C#m": [key1sharp, key2sharp, key3sharp, key4sharp],
          "BMix": [key1sharp, key2sharp, key3sharp, key4sharp],
          "F#Dor": [key1sharp, key2sharp, key3sharp, key4sharp],
          "G#Phr": [key1sharp, key2sharp, key3sharp, key4sharp],
          "ALyd": [key1sharp, key2sharp, key3sharp, key4sharp],
          "D#Loc": [key1sharp, key2sharp, key3sharp, key4sharp],
          "A": [key1sharp, key2sharp, key3sharp],
          "F#m": [key1sharp, key2sharp, key3sharp],
          "EMix": [key1sharp, key2sharp, key3sharp],
          "BDor": [key1sharp, key2sharp, key3sharp],
          "C#Phr": [key1sharp, key2sharp, key3sharp],
          "DLyd": [key1sharp, key2sharp, key3sharp],
          "G#Loc": [key1sharp, key2sharp, key3sharp],
          "D": [key1sharp, key2sharp],
          "Bm": [key1sharp, key2sharp],
          "AMix": [key1sharp, key2sharp],
          "EDor": [key1sharp, key2sharp],
          "F#Phr": [key1sharp, key2sharp],
          "GLyd": [key1sharp, key2sharp],
          "C#Loc": [key1sharp, key2sharp],
          "G": [key1sharp],
          "Em": [key1sharp],
          "DMix": [key1sharp],
          "ADor": [key1sharp],
          "BPhr": [key1sharp],
          "CLyd": [key1sharp],
          "F#Loc": [key1sharp],
          "C": [],
          "Am": [],
          "GMix": [],
          "DDor": [],
          "EPhr": [],
          "FLyd": [],
          "BLoc": [],
          "F": [key1flat],
          "Dm": [key1flat],
          "CMix": [key1flat],
          "GDor": [key1flat],
          "APhr": [key1flat],
          "BbLyd": [key1flat],
          "ELoc": [key1flat],
          "Bb": [key1flat, key2flat],
          "Gm": [key1flat, key2flat],
          "FMix": [key1flat, key2flat],
          "CDor": [key1flat, key2flat],
          "DPhr": [key1flat, key2flat],
          "EbLyd": [key1flat, key2flat],
          "ALoc": [key1flat, key2flat],
          "Eb": [key1flat, key2flat, key3flat],
          "Cm": [key1flat, key2flat, key3flat],
          "BbMix": [key1flat, key2flat, key3flat],
          "FDor": [key1flat, key2flat, key3flat],
          "GPhr": [key1flat, key2flat, key3flat],
          "AbLyd": [key1flat, key2flat, key3flat],
          "DLoc": [key1flat, key2flat, key3flat],
          "Ab": [key1flat, key2flat, key3flat, key4flat],
          "Fm": [key1flat, key2flat, key3flat, key4flat],
          "EbMix": [key1flat, key2flat, key3flat, key4flat],
          "BbDor": [key1flat, key2flat, key3flat, key4flat],
          "CPhr": [key1flat, key2flat, key3flat, key4flat],
          "DbLyd": [key1flat, key2flat, key3flat, key4flat],
          "GLoc": [key1flat, key2flat, key3flat, key4flat],
          "Db": [key1flat, key2flat, key3flat, key4flat, key5flat],
          "Bbm": [key1flat, key2flat, key3flat, key4flat, key5flat],
          "AbMix": [key1flat, key2flat, key3flat, key4flat, key5flat],
          "EbDor": [key1flat, key2flat, key3flat, key4flat, key5flat],
          "FPhr": [key1flat, key2flat, key3flat, key4flat, key5flat],
          "GbLyd": [key1flat, key2flat, key3flat, key4flat, key5flat],
          "CLoc": [key1flat, key2flat, key3flat, key4flat, key5flat],
          "Gb": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat],
          "Ebm": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat],
          "DbMix": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat],
          "AbDor": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat],
          "BbPhr": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat],
          "CbLyd": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat],
          "FLoc": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat],
          "Cb": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat],
          "Abm": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat],
          "GbMix": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat],
          "DbDor": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat],
          "EbPhr": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat],
          "FbLyd": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat],
          "BbLoc": [key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat],
          // The following are not in the 2.0 spec, but seem normal enough.
          // TODO-PER: These SOUND the same as what's written, but they aren't right
          "A#": [key1flat, key2flat],
          "B#": [],
          "D#": [key1flat, key2flat, key3flat],
          "E#": [key1flat],
          "G#": [key1flat, key2flat, key3flat, key4flat],
          "Gbm": [key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp]
        };
        return transpose.keySignature(multilineVars, keys, keyName, root, acc, localTranspose);
      };
      var clefLines = {
        "treble": { clef: "treble", pitch: 4, mid: 0 },
        "treble+8": { clef: "treble+8", pitch: 4, mid: 0 },
        "treble-8": { clef: "treble-8", pitch: 4, mid: 0 },
        "treble^8": { clef: "treble+8", pitch: 4, mid: 0 },
        "treble_8": { clef: "treble-8", pitch: 4, mid: 0 },
        "treble1": { clef: "treble", pitch: 2, mid: 2 },
        "treble2": { clef: "treble", pitch: 4, mid: 0 },
        "treble3": { clef: "treble", pitch: 6, mid: -2 },
        "treble4": { clef: "treble", pitch: 8, mid: -4 },
        "treble5": { clef: "treble", pitch: 10, mid: -6 },
        "perc": { clef: "perc", pitch: 6, mid: 0 },
        "none": { clef: "none", mid: 0 },
        "bass": { clef: "bass", pitch: 8, mid: -12 },
        "bass+8": { clef: "bass+8", pitch: 8, mid: -12 },
        "bass-8": { clef: "bass-8", pitch: 8, mid: -12 },
        "bass^8": { clef: "bass+8", pitch: 8, mid: -12 },
        "bass_8": { clef: "bass-8", pitch: 8, mid: -12 },
        "bass+16": { clef: "bass", pitch: 8, mid: -12 },
        "bass-16": { clef: "bass", pitch: 8, mid: -12 },
        "bass^16": { clef: "bass", pitch: 8, mid: -12 },
        "bass_16": { clef: "bass", pitch: 8, mid: -12 },
        "bass1": { clef: "bass", pitch: 2, mid: -6 },
        "bass2": { clef: "bass", pitch: 4, mid: -8 },
        "bass3": { clef: "bass", pitch: 6, mid: -10 },
        "bass4": { clef: "bass", pitch: 8, mid: -12 },
        "bass5": { clef: "bass", pitch: 10, mid: -14 },
        "tenor": { clef: "alto", pitch: 8, mid: -8 },
        "tenor1": { clef: "alto", pitch: 2, mid: -2 },
        "tenor2": { clef: "alto", pitch: 4, mid: -4 },
        "tenor3": { clef: "alto", pitch: 6, mid: -6 },
        "tenor4": { clef: "alto", pitch: 8, mid: -8 },
        "tenor5": { clef: "alto", pitch: 10, mid: -10 },
        "alto": { clef: "alto", pitch: 6, mid: -6 },
        "alto1": { clef: "alto", pitch: 2, mid: -2 },
        "alto2": { clef: "alto", pitch: 4, mid: -4 },
        "alto3": { clef: "alto", pitch: 6, mid: -6 },
        "alto4": { clef: "alto", pitch: 8, mid: -8 },
        "alto5": { clef: "alto", pitch: 10, mid: -10 },
        "alto+8": { clef: "alto+8", pitch: 6, mid: -6 },
        "alto-8": { clef: "alto-8", pitch: 6, mid: -6 },
        "alto^8": { clef: "alto+8", pitch: 6, mid: -6 },
        "alto_8": { clef: "alto-8", pitch: 6, mid: -6 }
      };
      var calcMiddle = function(clef, oct) {
        var value = clefLines[clef];
        var mid = value ? value.mid : 0;
        return mid + oct;
      };
      parseKeyVoice.fixClef = function(clef) {
        var value = clefLines[clef.type];
        if (value) {
          clef.clefPos = value.pitch;
          clef.type = value.clef;
        }
      };
      parseKeyVoice.deepCopyKey = function(key) {
        var ret = { accidentals: [], root: key.root, acc: key.acc, mode: key.mode };
        parseCommon.each(key.accidentals, function(k) {
          ret.accidentals.push(parseCommon.clone(k));
        });
        return ret;
      };
      var pitches = { A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11 };
      parseKeyVoice.addPosToKey = function(clef, key) {
        var mid = clef.verticalPos;
        parseCommon.each(key.accidentals, function(acc) {
          var pitch = pitches[acc.note];
          pitch = pitch - mid;
          acc.verticalPos = pitch;
        });
        if (key.impliedNaturals)
          parseCommon.each(key.impliedNaturals, function(acc) {
            var pitch = pitches[acc.note];
            pitch = pitch - mid;
            acc.verticalPos = pitch;
          });
        if (mid < -10) {
          parseCommon.each(key.accidentals, function(acc) {
            acc.verticalPos -= 7;
            if (acc.verticalPos >= 11 || acc.verticalPos === 10 && acc.acc === "flat")
              acc.verticalPos -= 7;
            if (acc.note === "A" && acc.acc === "sharp")
              acc.verticalPos -= 7;
            if ((acc.note === "G" || acc.note === "F") && acc.acc === "flat")
              acc.verticalPos -= 7;
          });
          if (key.impliedNaturals)
            parseCommon.each(key.impliedNaturals, function(acc) {
              acc.verticalPos -= 7;
              if (acc.verticalPos >= 11 || acc.verticalPos === 10 && acc.acc === "flat")
                acc.verticalPos -= 7;
              if (acc.note === "A" && acc.acc === "sharp")
                acc.verticalPos -= 7;
              if ((acc.note === "G" || acc.note === "F") && acc.acc === "flat")
                acc.verticalPos -= 7;
            });
        } else if (mid < -4) {
          parseCommon.each(key.accidentals, function(acc) {
            acc.verticalPos -= 7;
            if (mid === -8 && (acc.note === "f" || acc.note === "g") && acc.acc === "sharp")
              acc.verticalPos -= 7;
          });
          if (key.impliedNaturals)
            parseCommon.each(key.impliedNaturals, function(acc) {
              acc.verticalPos -= 7;
              if (mid === -8 && (acc.note === "f" || acc.note === "g") && acc.acc === "sharp")
                acc.verticalPos -= 7;
            });
        } else if (mid >= 7) {
          parseCommon.each(key.accidentals, function(acc) {
            acc.verticalPos += 7;
          });
          if (key.impliedNaturals)
            parseCommon.each(key.impliedNaturals, function(acc) {
              acc.verticalPos += 7;
            });
        }
      };
      parseKeyVoice.fixKey = function(clef, key) {
        var fixedKey = parseCommon.clone(key);
        parseKeyVoice.addPosToKey(clef, fixedKey);
        return fixedKey;
      };
      var parseMiddle = function(str) {
        var i = 0;
        var p = str.charAt(i++);
        if (p === "^" || p === "_")
          p = str.charAt(i++);
        var mid = pitches[p];
        if (mid === void 0)
          mid = 6;
        for (; i < str.length; i++) {
          if (str.charAt(i) === ",") mid -= 7;
          else if (str.charAt(i) === "'") mid += 7;
          else break;
        }
        return { mid: mid - 6, str: str.substring(i) };
      };
      var normalizeAccidentals = function(accs) {
        for (var i = 0; i < accs.length; i++) {
          if (accs[i].note === "b")
            accs[i].note = "B";
          else if (accs[i].note === "a")
            accs[i].note = "A";
          else if (accs[i].note === "F")
            accs[i].note = "f";
          else if (accs[i].note === "E")
            accs[i].note = "e";
          else if (accs[i].note === "D")
            accs[i].note = "d";
          else if (accs[i].note === "C")
            accs[i].note = "c";
          else if (accs[i].note === "G" && accs[i].acc === "sharp")
            accs[i].note = "g";
          else if (accs[i].note === "g" && accs[i].acc === "flat")
            accs[i].note = "G";
        }
      };
      parseKeyVoice.parseKey = function(str) {
        if (str.length === 0) {
          str = "none";
        }
        var tokens = tokenizer.tokenize(str, 0, str.length);
        var ret = {};
        switch (tokens[0].token) {
          case "HP":
            parseDirective.addDirective("bagpipes");
            multilineVars.key = { root: "HP", accidentals: [], acc: "", mode: "" };
            ret.foundKey = true;
            tokens.shift();
            break;
          case "Hp":
            parseDirective.addDirective("bagpipes");
            multilineVars.key = { root: "Hp", accidentals: [{ acc: "natural", note: "g" }, { acc: "sharp", note: "f" }, { acc: "sharp", note: "c" }], acc: "", mode: "" };
            ret.foundKey = true;
            tokens.shift();
            break;
          case "none":
            multilineVars.key = { root: "none", accidentals: [], acc: "", mode: "" };
            ret.foundKey = true;
            tokens.shift();
            break;
          default:
            var retPitch = tokenizer.getKeyPitch(tokens[0].token);
            if (retPitch.len > 0) {
              ret.foundKey = true;
              var acc = "";
              var mode = "";
              if (tokens[0].token.length > 1)
                tokens[0].token = tokens[0].token.substring(1);
              else
                tokens.shift();
              var key = retPitch.token;
              if (tokens.length > 0) {
                var retAcc = tokenizer.getSharpFlat(tokens[0].token);
                if (retAcc.len > 0) {
                  if (tokens[0].token.length > 1)
                    tokens[0].token = tokens[0].token.substring(1);
                  else
                    tokens.shift();
                  key += retAcc.token;
                  acc = retAcc.token;
                }
                if (tokens.length > 0) {
                  var retMode = tokenizer.getMode(tokens[0].token);
                  if (retMode.len > 0) {
                    tokens.shift();
                    key += retMode.token;
                    mode = retMode.token;
                  }
                }
                if (parseKeyVoice.standardKey(key, retPitch.token, acc, 0) === void 0) {
                  warn("Unsupported key signature: " + key, str, 0);
                  return ret;
                }
              }
              var oldKey = parseKeyVoice.deepCopyKey(multilineVars.key);
              var keyCompensate = multilineVars.globalTranspose ? -multilineVars.globalTranspose : 0;
              multilineVars.key = parseKeyVoice.deepCopyKey(parseKeyVoice.standardKey(key, retPitch.token, acc, keyCompensate));
              multilineVars.key.mode = mode;
              if (oldKey) {
                var kk;
                for (var k = 0; k < multilineVars.key.accidentals.length; k++) {
                  for (kk = 0; kk < oldKey.accidentals.length; kk++) {
                    if (oldKey.accidentals[kk].note && multilineVars.key.accidentals[k].note.toLowerCase() === oldKey.accidentals[kk].note.toLowerCase())
                      oldKey.accidentals[kk].note = null;
                  }
                }
                for (kk = 0; kk < oldKey.accidentals.length; kk++) {
                  if (oldKey.accidentals[kk].note) {
                    if (!multilineVars.key.impliedNaturals)
                      multilineVars.key.impliedNaturals = [];
                    multilineVars.key.impliedNaturals.push({ acc: "natural", note: oldKey.accidentals[kk].note });
                  }
                }
              }
            }
            break;
        }
        if (tokens.length === 0) return ret;
        if (tokens[0].token === "exp") tokens.shift();
        if (tokens.length === 0) return ret;
        if (tokens[0].token === "oct") tokens.shift();
        if (tokens.length === 0) return ret;
        var accs = tokenizer.getKeyAccidentals2(tokens);
        if (accs.warn)
          warn(accs.warn, str, 0);
        if (accs.accs) {
          if (!ret.foundKey) {
            ret.foundKey = true;
            multilineVars.key = { root: "none", acc: "", mode: "", accidentals: [] };
          }
          normalizeAccidentals(accs.accs);
          for (var i = 0; i < accs.accs.length; i++) {
            var found = false;
            for (var j = 0; j < multilineVars.key.accidentals.length && !found; j++) {
              if (multilineVars.key.accidentals[j].note === accs.accs[i].note) {
                found = true;
                if (multilineVars.key.accidentals[j].acc !== accs.accs[i].acc) {
                  multilineVars.key.accidentals[j].acc = accs.accs[i].acc;
                  if (!multilineVars.key.explicitAccidentals)
                    multilineVars.key.explicitAccidentals = [];
                  multilineVars.key.explicitAccidentals.push(accs.accs[i]);
                }
              }
            }
            if (!found) {
              if (!multilineVars.key.explicitAccidentals)
                multilineVars.key.explicitAccidentals = [];
              multilineVars.key.explicitAccidentals.push(accs.accs[i]);
              multilineVars.key.accidentals.push(accs.accs[i]);
              if (multilineVars.key.impliedNaturals) {
                for (var kkk = 0; kkk < multilineVars.key.impliedNaturals.length; kkk++) {
                  if (multilineVars.key.impliedNaturals[kkk].note === accs.accs[i].note)
                    multilineVars.key.impliedNaturals.splice(kkk, 1);
                }
              }
            }
          }
        }
        var token;
        while (tokens.length > 0) {
          switch (tokens[0].token) {
            case "m":
            case "middle":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after middle", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after middle", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after middle=", str, 0);
                return ret;
              }
              var pitch = tokenizer.getPitchFromTokens(tokens);
              if (pitch.warn)
                warn(pitch.warn, str, 0);
              if (pitch.position)
                multilineVars.clef.verticalPos = pitch.position - 6;
              break;
            case "transpose":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after transpose", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after transpose", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after transpose=", str, 0);
                return ret;
              }
              if (tokens[0].type !== "number") {
                warn("Expected number after transpose", str, tokens[0].start);
                break;
              }
              multilineVars.clef.transpose = tokens[0].intt;
              tokens.shift();
              break;
            case "stafflines":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after stafflines", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after stafflines", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after stafflines=", str, 0);
                return ret;
              }
              if (tokens[0].type !== "number") {
                warn("Expected number after stafflines", str, tokens[0].start);
                break;
              }
              multilineVars.clef.stafflines = tokens[0].intt;
              tokens.shift();
              break;
            case "staffscale":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after staffscale", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after staffscale", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after staffscale=", str, 0);
                return ret;
              }
              if (tokens[0].type !== "number") {
                warn("Expected number after staffscale", str, tokens[0].start);
                break;
              }
              multilineVars.clef.staffscale = tokens[0].floatt;
              tokens.shift();
              break;
            case "style":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after style", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after style", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after style=", str, 0);
                return ret;
              }
              switch (tokens[0].token) {
                case "normal":
                case "harmonic":
                case "rhythm":
                case "x":
                  multilineVars.style = tokens[0].token;
                  tokens.shift();
                  break;
                default:
                  warn("error parsing style element: " + tokens[0].token, str, tokens[0].start);
                  break;
              }
              break;
            case "clef":
              tokens.shift();
              if (tokens.length === 0) {
                warn("Expected = after clef", str, 0);
                return ret;
              }
              token = tokens.shift();
              if (token.token !== "=") {
                warn("Expected = after clef", str, token.start);
                break;
              }
              if (tokens.length === 0) {
                warn("Expected parameter after clef=", str, 0);
                return ret;
              }
            //break; yes, we want to fall through. That allows "clef=" to be optional.
            case "treble":
            case "bass":
            case "alto":
            case "tenor":
            case "perc":
              var clef = tokens.shift();
              switch (clef.token) {
                case "treble":
                case "tenor":
                case "alto":
                case "bass":
                case "perc":
                case "none":
                  break;
                case "C":
                  clef.token = "alto";
                  break;
                case "F":
                  clef.token = "bass";
                  break;
                case "G":
                  clef.token = "treble";
                  break;
                case "c":
                  clef.token = "alto";
                  break;
                case "f":
                  clef.token = "bass";
                  break;
                case "g":
                  clef.token = "treble";
                  break;
                default:
                  warn("Expected clef name. Found " + clef.token, str, clef.start);
                  break;
              }
              if (tokens.length > 0 && tokens[0].type === "number") {
                clef.token += tokens[0].token;
                tokens.shift();
              }
              if (tokens.length > 1 && (tokens[0].token === "-" || tokens[0].token === "+" || tokens[0].token === "^" || tokens[0].token === "_") && tokens[1].token === "8") {
                clef.token += tokens[0].token + tokens[1].token;
                tokens.shift();
                tokens.shift();
              }
              multilineVars.clef = { type: clef.token, verticalPos: calcMiddle(clef.token, 0) };
              if (multilineVars.currentVoice && multilineVars.currentVoice.transpose !== void 0)
                multilineVars.clef.transpose = multilineVars.currentVoice.transpose;
              ret.foundClef = true;
              break;
            default:
              warn("Unknown parameter: " + tokens[0].token, str, tokens[0].start);
              tokens.shift();
          }
        }
        return ret;
      };
      var setCurrentVoice = function(id) {
        multilineVars.currentVoice = multilineVars.voices[id];
        tune.setCurrentVoice(multilineVars.currentVoice.staffNum, multilineVars.currentVoice.index);
      };
      parseKeyVoice.parseVoice = function(line, i, e) {
        var ret = tokenizer.getMeat(line, i, e);
        var start = ret.start;
        var end = ret.end;
        var id = tokenizer.getToken(line, start, end);
        if (id.length === 0) {
          warn("Expected a voice id", line, start);
          return;
        }
        var isNew = false;
        if (multilineVars.voices[id] === void 0) {
          multilineVars.voices[id] = {};
          isNew = true;
          if (multilineVars.score_is_present)
            warn("Can't have an unknown V: id when the %score directive is present", line, start);
        }
        start += id.length;
        start += tokenizer.eatWhiteSpace(line, start);
        var staffInfo = { startStaff: isNew };
        var addNextTokenToStaffInfo = function(name) {
          var attr2 = tokenizer.getVoiceToken(line, start, end);
          if (attr2.warn !== void 0)
            warn("Expected value for " + name + " in voice: " + attr2.warn, line, start);
          else if (attr2.token.length === 0 && line.charAt(start) !== '"')
            warn("Expected value for " + name + " in voice", line, start);
          else
            staffInfo[name] = attr2.token;
          start += attr2.len;
        };
        var addNextTokenToVoiceInfo = function(id2, name, type) {
          var attr2 = tokenizer.getVoiceToken(line, start, end);
          if (attr2.warn !== void 0)
            warn("Expected value for " + name + " in voice: " + attr2.warn, line, start);
          else if (attr2.token.length === 0 && line.charAt(start) !== '"')
            warn("Expected value for " + name + " in voice", line, start);
          else {
            if (type === "number")
              attr2.token = parseFloat(attr2.token);
            multilineVars.voices[id2][name] = attr2.token;
          }
          start += attr2.len;
        };
        var getNextToken = function(name, type) {
          var attr2 = tokenizer.getVoiceToken(line, start, end);
          if (attr2.warn !== void 0)
            warn("Expected value for " + name + " in voice: " + attr2.warn, line, start);
          else if (attr2.token.length === 0 && line.charAt(start) !== '"')
            warn("Expected value for " + name + " in voice", line, start);
          else {
            if (type === "number")
              attr2.token = parseFloat(attr2.token);
            return attr2.token;
          }
          start += attr2.len;
        };
        var addNextNoteTokenToVoiceInfo = function(id2, name) {
          var noteToTransposition = {
            "_B": 2,
            "_E": 9,
            "_b": -10,
            "_e": -3
          };
          var attr2 = tokenizer.getVoiceToken(line, start, end);
          if (attr2.warn !== void 0)
            warn("Expected one of (_B, _E, _b, _e) for " + name + " in voice: " + attr2.warn, line, start);
          else if (attr2.token.length === 0 && line.charAt(start) !== '"')
            warn("Expected one of (_B, _E, _b, _e) for " + name + " in voice", line, start);
          else {
            var t = noteToTransposition[attr2.token];
            if (!t)
              warn("Expected one of (_B, _E, _b, _e) for " + name + " in voice", line, start);
            else
              multilineVars.voices[id2][name] = t;
          }
          start += attr2.len;
        };
        while (start < end) {
          var token = tokenizer.getVoiceToken(line, start, end);
          start += token.len;
          if (token.warn) {
            warn("Error parsing voice: " + token.warn, line, start);
          } else {
            var attr = null;
            switch (token.token) {
              case "clef":
              case "cl":
                addNextTokenToStaffInfo("clef");
                var oct = 0;
                if (staffInfo.clef !== void 0) {
                  staffInfo.clef = staffInfo.clef.replace(/[',]/g, "");
                  if (staffInfo.clef.indexOf("+16") !== -1) {
                    oct += 14;
                    staffInfo.clef = staffInfo.clef.replace("+16", "");
                  }
                  staffInfo.verticalPos = calcMiddle(staffInfo.clef, oct);
                }
                break;
              case "treble":
              case "bass":
              case "tenor":
              case "alto":
              case "perc":
              case "none":
              case "treble'":
              case "bass'":
              case "tenor'":
              case "alto'":
              case "none'":
              case "treble''":
              case "bass''":
              case "tenor''":
              case "alto''":
              case "none''":
              case "treble,":
              case "bass,":
              case "tenor,":
              case "alto,":
              case "none,":
              case "treble,,":
              case "bass,,":
              case "tenor,,":
              case "alto,,":
              case "none,,":
                var oct2 = 0;
                staffInfo.clef = token.token.replace(/[',]/g, "");
                staffInfo.verticalPos = calcMiddle(staffInfo.clef, oct2);
                multilineVars.voices[id].clef = token.token;
                break;
              case "staves":
              case "stave":
              case "stv":
                addNextTokenToStaffInfo("staves");
                break;
              case "brace":
              case "brc":
                addNextTokenToStaffInfo("brace");
                break;
              case "bracket":
              case "brk":
                addNextTokenToStaffInfo("bracket");
                break;
              case "name":
              case "nm":
                addNextTokenToStaffInfo("name");
                break;
              case "subname":
              case "sname":
              case "snm":
                addNextTokenToStaffInfo("subname");
                break;
              case "merge":
                staffInfo.startStaff = false;
                break;
              case "stem":
              case "stems":
                attr = tokenizer.getVoiceToken(line, start, end);
                if (attr.warn !== void 0)
                  warn("Expected value for stems in voice: " + attr.warn, line, start);
                else if (attr.token === "up" || attr.token === "down")
                  multilineVars.voices[id].stem = attr.token;
                else
                  warn("Expected up or down for voice stem", line, start);
                start += attr.len;
                break;
              case "up":
              case "down":
                multilineVars.voices[id].stem = token.token;
                break;
              case "middle":
              case "m":
                addNextTokenToStaffInfo("verticalPos");
                staffInfo.verticalPos = parseMiddle(staffInfo.verticalPos).mid;
                break;
              case "gchords":
              case "gch":
                multilineVars.voices[id].suppressChords = true;
                attr = tokenizer.getVoiceToken(line, start, end);
                if (attr.token === "0")
                  start = start + attr.len;
                break;
              case "space":
              case "spc":
                addNextTokenToStaffInfo("spacing");
                break;
              case "scale":
                addNextTokenToVoiceInfo(id, "scale", "number");
                break;
              case "score":
                addNextNoteTokenToVoiceInfo(id, "scoreTranspose");
                break;
              case "transpose":
                addNextTokenToVoiceInfo(id, "transpose", "number");
                break;
              case "stafflines":
                addNextTokenToVoiceInfo(id, "stafflines", "number");
                break;
              case "staffscale":
                addNextTokenToVoiceInfo(id, "staffscale", "number");
                break;
              case "octave":
                addNextTokenToVoiceInfo(id, "octave", "number");
                break;
              case "volume":
                addNextTokenToVoiceInfo(id, "volume", "number");
                break;
              case "cue":
                var cue = getNextToken("cue", "string");
                if (cue === "on")
                  multilineVars.voices[id].scale = 0.6;
                else multilineVars.voices[id].scale = 1;
                break;
              case "style":
                attr = tokenizer.getVoiceToken(line, start, end);
                if (attr.warn !== void 0)
                  warn("Expected value for style in voice: " + attr.warn, line, start);
                else if (attr.token === "normal" || attr.token === "harmonic" || attr.token === "rhythm" || attr.token === "x")
                  multilineVars.voices[id].style = attr.token;
                else
                  warn("Expected one of [normal, harmonic, rhythm, x] for voice style", line, start);
                start += attr.len;
                break;
            }
          }
          start += tokenizer.eatWhiteSpace(line, start);
        }
        if (staffInfo.startStaff || multilineVars.staves.length === 0) {
          multilineVars.staves.push({ index: multilineVars.staves.length, meter: multilineVars.origMeter });
          if (!multilineVars.score_is_present)
            multilineVars.staves[multilineVars.staves.length - 1].numVoices = 0;
        }
        if (multilineVars.voices[id].staffNum === void 0) {
          multilineVars.voices[id].staffNum = multilineVars.staves.length - 1;
          var vi = 0;
          for (var v in multilineVars.voices) {
            if (multilineVars.voices.hasOwnProperty(v)) {
              if (multilineVars.voices[v].staffNum === multilineVars.voices[id].staffNum)
                vi++;
            }
          }
          multilineVars.voices[id].index = vi - 1;
        }
        var s = multilineVars.staves[multilineVars.voices[id].staffNum];
        if (!multilineVars.score_is_present)
          s.numVoices++;
        if (staffInfo.clef) s.clef = { type: staffInfo.clef, verticalPos: staffInfo.verticalPos };
        if (staffInfo.spacing) s.spacing_below_offset = staffInfo.spacing;
        if (staffInfo.verticalPos) s.verticalPos = staffInfo.verticalPos;
        if (staffInfo.name) {
          if (s.name) s.name.push(staffInfo.name);
          else s.name = [staffInfo.name];
        }
        if (staffInfo.subname) {
          if (s.subname) s.subname.push(staffInfo.subname);
          else s.subname = [staffInfo.subname];
        }
        setCurrentVoice(id);
      };
    })();
    module.exports = parseKeyVoice;
  }
});

// node_modules/abcjs/src/parse/abc_parse_header.js
var require_abc_parse_header = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse_header.js"(exports, module) {
    var parseCommon = require_abc_common();
    var parseDirective = require_abc_parse_directive();
    var parseKeyVoice = require_abc_parse_key_voice();
    var ParseHeader = function(tokenizer, warn, multilineVars, tune) {
      this.reset = function(tokenizer2, warn2, multilineVars2, tune2) {
        parseKeyVoice.initialize(tokenizer2, warn2, multilineVars2, tune2);
        parseDirective.initialize(tokenizer2, warn2, multilineVars2, tune2);
      };
      this.reset(tokenizer, warn, multilineVars, tune);
      this.setTitle = function(title) {
        if (multilineVars.hasMainTitle)
          tune.addSubtitle(tokenizer.translateString(tokenizer.stripComment(title)));
        else {
          var titleStr = tokenizer.translateString(tokenizer.theReverser(tokenizer.stripComment(title)));
          if (multilineVars.titlecaps)
            titleStr = titleStr.toUpperCase();
          tune.addMetaText("title", titleStr);
          multilineVars.hasMainTitle = true;
        }
      };
      this.setMeter = function(line) {
        line = tokenizer.stripComment(line);
        if (line === "C") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "common_time" };
        } else if (line === "C|") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "cut_time" };
        } else if (line === "o") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "tempus_perfectum" };
        } else if (line === "c") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "tempus_imperfectum" };
        } else if (line === "o.") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "tempus_perfectum_prolatio" };
        } else if (line === "c.") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return { type: "tempus_imperfectum_prolatio" };
        } else if (line.length === 0 || line.toLowerCase() === "none") {
          if (multilineVars.havent_set_length === true) {
            multilineVars.default_length = 0.125;
            multilineVars.havent_set_length = false;
          }
          return null;
        } else {
          var tokens = tokenizer.tokenize(line, 0, line.length);
          try {
            var parseNum = function() {
              var ret2 = { value: 0, num: "" };
              var tok = tokens.shift();
              if (tok.token === "(")
                tok = tokens.shift();
              while (1) {
                if (tok.type !== "number") throw "Expected top number of meter";
                ret2.value += parseInt(tok.token);
                ret2.num += tok.token;
                if (tokens.length === 0 || tokens[0].token === "/") return ret2;
                tok = tokens.shift();
                if (tok.token === ")") {
                  if (tokens.length === 0 || tokens[0].token === "/") return ret2;
                  throw "Unexpected paren in meter";
                }
                if (tok.token !== "." && tok.token !== "+") throw "Expected top number of meter";
                ret2.num += tok.token;
                if (tokens.length === 0) throw "Expected top number of meter";
                tok = tokens.shift();
              }
              return ret2;
            };
            var parseFraction = function() {
              var ret2 = parseNum();
              if (tokens.length === 0) return ret2;
              var tok = tokens.shift();
              if (tok.token !== "/") throw "Expected slash in meter";
              tok = tokens.shift();
              if (tok.type !== "number") throw "Expected bottom number of meter";
              ret2.den = tok.token;
              ret2.value = ret2.value / parseInt(ret2.den);
              return ret2;
            };
            if (tokens.length === 0) throw "Expected meter definition in M: line";
            var meter = { type: "specified", value: [] };
            var totalLength = 0;
            while (1) {
              var ret = parseFraction();
              totalLength += ret.value;
              var mv = { num: ret.num };
              if (ret.den !== void 0)
                mv.den = ret.den;
              meter.value.push(mv);
              if (tokens.length === 0) break;
            }
            if (multilineVars.havent_set_length === true) {
              multilineVars.default_length = totalLength < 0.75 ? 0.0625 : 0.125;
              multilineVars.havent_set_length = false;
            }
            return meter;
          } catch (e) {
            warn(e, line, 0);
          }
        }
        return null;
      };
      this.calcTempo = function(relTempo) {
        var dur = 1 / 4;
        if (multilineVars.meter && multilineVars.meter.type === "specified") {
          dur = 1 / parseInt(multilineVars.meter.value[0].den);
        } else if (multilineVars.origMeter && multilineVars.origMeter.type === "specified") {
          dur = 1 / parseInt(multilineVars.origMeter.value[0].den);
        }
        for (var i = 0; i < relTempo.duration; i++)
          relTempo.duration[i] = dur * relTempo.duration[i];
        return relTempo;
      };
      this.resolveTempo = function() {
        if (multilineVars.tempo) {
          this.calcTempo(multilineVars.tempo);
          tune.metaText.tempo = multilineVars.tempo;
          delete multilineVars.tempo;
        }
      };
      this.addUserDefinition = function(line, start, end) {
        var equals = line.indexOf("=", start);
        if (equals === -1) {
          warn("Need an = in a macro definition", line, start);
          return;
        }
        var before = parseCommon.strip(line.substring(start, equals));
        var after = parseCommon.strip(line.substring(equals + 1));
        if (before.length !== 1) {
          warn("Macro definitions can only be one character", line, start);
          return;
        }
        var legalChars = "HIJKLMNOPQRSTUVWXYhijklmnopqrstuvw~";
        if (legalChars.indexOf(before) === -1) {
          warn("Macro definitions must be H-Y, h-w, or tilde", line, start);
          return;
        }
        if (after.length === 0) {
          warn("Missing macro definition", line, start);
          return;
        }
        if (multilineVars.macros === void 0)
          multilineVars.macros = {};
        multilineVars.macros[before] = after;
      };
      this.setDefaultLength = function(line, start, end) {
        var len = parseCommon.gsub(line.substring(start, end), " ", "");
        var len_arr = len.split("/");
        if (len_arr.length === 2) {
          var n = parseInt(len_arr[0]);
          var d = parseInt(len_arr[1]);
          if (d > 0) {
            multilineVars.default_length = n / d;
            multilineVars.havent_set_length = false;
          }
        } else if (len_arr.length === 1 && len_arr[0] === "1") {
          multilineVars.default_length = 1;
          multilineVars.havent_set_length = false;
        }
      };
      var tempoString = {
        larghissimo: 20,
        adagissimo: 24,
        sostenuto: 28,
        grave: 32,
        largo: 40,
        lento: 50,
        larghetto: 60,
        adagio: 68,
        adagietto: 74,
        andante: 80,
        andantino: 88,
        "marcia moderato": 84,
        "andante moderato": 100,
        moderato: 112,
        allegretto: 116,
        "allegro moderato": 120,
        allegro: 126,
        animato: 132,
        agitato: 140,
        veloce: 148,
        "mosso vivo": 156,
        vivace: 164,
        vivacissimo: 172,
        allegrissimo: 176,
        presto: 184,
        prestissimo: 210
      };
      this.setTempo = function(line, start, end) {
        try {
          var tokens = tokenizer.tokenize(line, start, end);
          if (tokens.length === 0) throw "Missing parameter in Q: field";
          var tempo = {};
          var delaySet = true;
          var token = tokens.shift();
          if (token.type === "quote") {
            tempo.preString = token.token;
            token = tokens.shift();
            if (tokens.length === 0) {
              if (tempoString[tempo.preString.toLowerCase()]) {
                tempo.bpm = tempoString[tempo.preString.toLowerCase()];
                tempo.suppressBpm = true;
              }
              return { type: "immediate", tempo };
            }
          }
          if (token.type === "alpha" && token.token === "C") {
            if (tokens.length === 0) throw "Missing tempo after C in Q: field";
            token = tokens.shift();
            if (token.type === "punct" && token.token === "=") {
              if (tokens.length === 0) throw "Missing tempo after = in Q: field";
              token = tokens.shift();
              if (token.type !== "number") throw "Expected number after = in Q: field";
              tempo.duration = [1];
              tempo.bpm = parseInt(token.token);
            } else if (token.type === "number") {
              tempo.duration = [parseInt(token.token)];
              if (tokens.length === 0) throw "Missing = after duration in Q: field";
              token = tokens.shift();
              if (token.type !== "punct" || token.token !== "=") throw "Expected = after duration in Q: field";
              if (tokens.length === 0) throw "Missing tempo after = in Q: field";
              token = tokens.shift();
              if (token.type !== "number") throw "Expected number after = in Q: field";
              tempo.bpm = parseInt(token.token);
            } else throw "Expected number or equal after C in Q: field";
          } else if (token.type === "number") {
            var num = parseInt(token.token);
            if (tokens.length === 0 || tokens[0].type === "quote") {
              tempo.duration = [1];
              tempo.bpm = num;
            } else {
              delaySet = false;
              token = tokens.shift();
              if (token.type !== "punct" && token.token !== "/") throw "Expected fraction in Q: field";
              token = tokens.shift();
              if (token.type !== "number") throw "Expected fraction in Q: field";
              var den = parseInt(token.token);
              tempo.duration = [num / den];
              while (tokens.length > 0 && tokens[0].token !== "=" && tokens[0].type !== "quote") {
                token = tokens.shift();
                if (token.type !== "number") throw "Expected fraction in Q: field";
                num = parseInt(token.token);
                token = tokens.shift();
                if (token.type !== "punct" && token.token !== "/") throw "Expected fraction in Q: field";
                token = tokens.shift();
                if (token.type !== "number") throw "Expected fraction in Q: field";
                den = parseInt(token.token);
                tempo.duration.push(num / den);
              }
              token = tokens.shift();
              if (token.type !== "punct" && token.token !== "=") throw "Expected = in Q: field";
              token = tokens.shift();
              if (token.type !== "number") throw "Expected tempo in Q: field";
              tempo.bpm = parseInt(token.token);
            }
          } else throw "Unknown value in Q: field";
          if (tokens.length !== 0) {
            token = tokens.shift();
            if (token.type === "quote") {
              tempo.postString = token.token;
              token = tokens.shift();
            }
            if (tokens.length !== 0) throw "Unexpected string at end of Q: field";
          }
          if (multilineVars.printTempo === false)
            tempo.suppress = true;
          return { type: delaySet ? "delaySet" : "immediate", tempo };
        } catch (msg) {
          warn(msg, line, start);
          return { type: "none" };
        }
      };
      this.letter_to_inline_header = function(line, i) {
        var ws = tokenizer.eatWhiteSpace(line, i);
        i += ws;
        if (line.length >= i + 5 && line.charAt(i) === "[" && line.charAt(i + 2) === ":") {
          var e = line.indexOf("]", i);
          var startChar = multilineVars.iChar + i;
          var endChar = multilineVars.iChar + e + 1;
          switch (line.substring(i, i + 3)) {
            case "[I:":
              var err = parseDirective.addDirective(line.substring(i + 3, e));
              if (err) warn(err, line, i);
              return [e - i + 1 + ws];
            case "[M:":
              var meter = this.setMeter(line.substring(i + 3, e));
              if (tune.hasBeginMusic() && meter)
                tune.appendStartingElement("meter", startChar, endChar, meter);
              else
                multilineVars.meter = meter;
              return [e - i + 1 + ws];
            case "[K:":
              var result = parseKeyVoice.parseKey(line.substring(i + 3, e));
              if (result.foundClef && tune.hasBeginMusic())
                tune.appendStartingElement("clef", startChar, endChar, multilineVars.clef);
              if (result.foundKey && tune.hasBeginMusic())
                tune.appendStartingElement("key", startChar, endChar, parseKeyVoice.fixKey(multilineVars.clef, multilineVars.key));
              return [e - i + 1 + ws];
            case "[P:":
              if (tune.lines.length <= tune.lineNum)
                multilineVars.partForNextLine = { title: line.substring(i + 3, e), startChar, endChar };
              else
                tune.appendElement("part", startChar, endChar, { title: line.substring(i + 3, e) });
              return [e - i + 1 + ws];
            case "[L:":
              this.setDefaultLength(line, i + 3, e);
              return [e - i + 1 + ws];
            case "[Q:":
              if (e > 0) {
                var tempo = this.setTempo(line, i + 3, e);
                if (tempo.type === "delaySet") tune.appendElement("tempo", startChar, endChar, this.calcTempo(tempo.tempo));
                else if (tempo.type === "immediate") tune.appendElement("tempo", startChar, endChar, tempo.tempo);
                return [e - i + 1 + ws, line.charAt(i + 1), line.substring(i + 3, e)];
              }
              break;
            case "[V:":
              if (e > 0) {
                parseKeyVoice.parseVoice(line, i + 3, e);
                return [e - i + 1 + ws, line.charAt(i + 1), line.substring(i + 3, e)];
              }
              break;
            default:
          }
        }
        return [0];
      };
      this.letter_to_body_header = function(line, i) {
        if (line.length >= i + 3) {
          switch (line.substring(i, i + 2)) {
            case "I:":
              var err = parseDirective.addDirective(line.substring(i + 2));
              if (err) warn(err, line, i);
              return [line.length];
            case "M:":
              var meter = this.setMeter(line.substring(i + 2));
              if (tune.hasBeginMusic() && meter)
                tune.appendStartingElement("meter", multilineVars.iChar + i, multilineVars.iChar + line.length, meter);
              return [line.length];
            case "K:":
              var result = parseKeyVoice.parseKey(line.substring(i + 2));
              if (result.foundClef && tune.hasBeginMusic())
                tune.appendStartingElement("clef", multilineVars.iChar + i, multilineVars.iChar + line.length, multilineVars.clef);
              if (result.foundKey && tune.hasBeginMusic())
                tune.appendStartingElement("key", multilineVars.iChar + i, multilineVars.iChar + line.length, parseKeyVoice.fixKey(multilineVars.clef, multilineVars.key));
              return [line.length];
            case "P:":
              if (tune.hasBeginMusic())
                tune.appendElement("part", multilineVars.iChar + i, multilineVars.iChar + line.length, { title: line.substring(i + 2) });
              return [line.length];
            case "L:":
              this.setDefaultLength(line, i + 2, line.length);
              return [line.length];
            case "Q:":
              var e = line.indexOf("", i + 2);
              if (e === -1) e = line.length;
              var tempo = this.setTempo(line, i + 2, e);
              if (tempo.type === "delaySet") tune.appendElement("tempo", multilineVars.iChar + i, multilineVars.iChar + line.length, this.calcTempo(tempo.tempo));
              else if (tempo.type === "immediate") tune.appendElement("tempo", multilineVars.iChar + i, multilineVars.iChar + line.length, tempo.tempo);
              return [e, line.charAt(i), parseCommon.strip(line.substring(i + 2))];
            case "V:":
              parseKeyVoice.parseVoice(line, i + 2, line.length);
              return [line.length, line.charAt(i), parseCommon.strip(line.substring(i + 2))];
            default:
          }
        }
        return [0];
      };
      var metaTextHeaders = {
        A: "author",
        B: "book",
        C: "composer",
        D: "discography",
        F: "url",
        G: "group",
        I: "instruction",
        N: "notes",
        O: "origin",
        R: "rhythm",
        S: "source",
        W: "unalignedWords",
        Z: "transcription"
      };
      this.parseHeader = function(line) {
        if (parseCommon.startsWith(line, "%%")) {
          var err = parseDirective.addDirective(line.substring(2));
          if (err) warn(err, line, 2);
          return {};
        }
        var i = line.indexOf("%");
        if (i >= 0)
          line = line.substring(0, i);
        line = line.replace(/\s+$/, "");
        if (line.length === 0)
          return {};
        if (line.length >= 2) {
          if (line.charAt(1) === ":") {
            var nextLine = "";
            if (line.indexOf("") >= 0 && line.charAt(0) !== "w") {
              nextLine = line.substring(line.indexOf("") + 1);
              line = line.substring(0, line.indexOf(""));
            }
            var field = metaTextHeaders[line.charAt(0)];
            if (field !== void 0) {
              if (field === "unalignedWords")
                tune.addMetaTextArray(field, parseDirective.parseFontChangeLine(tokenizer.translateString(tokenizer.stripComment(line.substring(2)))));
              else
                tune.addMetaText(field, tokenizer.translateString(tokenizer.stripComment(line.substring(2))));
              return {};
            } else {
              var startChar = multilineVars.iChar;
              var endChar = startChar + line.length;
              switch (line.charAt(0)) {
                case "H":
                  tune.addMetaText("history", tokenizer.translateString(tokenizer.stripComment(line.substring(2))));
                  multilineVars.is_in_history = true;
                  break;
                case "K":
                  this.resolveTempo();
                  var result = parseKeyVoice.parseKey(line.substring(2));
                  if (!multilineVars.is_in_header && tune.hasBeginMusic()) {
                    if (result.foundClef)
                      tune.appendStartingElement("clef", startChar, endChar, multilineVars.clef);
                    if (result.foundKey)
                      tune.appendStartingElement("key", startChar, endChar, parseKeyVoice.fixKey(multilineVars.clef, multilineVars.key));
                  }
                  multilineVars.is_in_header = false;
                  break;
                case "L":
                  this.setDefaultLength(line, 2, line.length);
                  break;
                case "M":
                  multilineVars.origMeter = multilineVars.meter = this.setMeter(line.substring(2));
                  break;
                case "P":
                  if (multilineVars.is_in_header)
                    tune.addMetaText("partOrder", tokenizer.translateString(tokenizer.stripComment(line.substring(2))));
                  else
                    multilineVars.partForNextLine = { title: tokenizer.translateString(tokenizer.stripComment(line.substring(2))), startChar, endChar };
                  break;
                case "Q":
                  var tempo = this.setTempo(line, 2, line.length);
                  if (tempo.type === "delaySet") multilineVars.tempo = tempo.tempo;
                  else if (tempo.type === "immediate") tune.metaText.tempo = tempo.tempo;
                  break;
                case "T":
                  this.setTitle(line.substring(2));
                  break;
                case "U":
                  this.addUserDefinition(line, 2, line.length);
                  break;
                case "V":
                  parseKeyVoice.parseVoice(line, 2, line.length);
                  if (!multilineVars.is_in_header)
                    return { newline: true };
                  break;
                case "s":
                  return { symbols: true };
                case "w":
                  return { words: true };
                case "X":
                  break;
                case "E":
                case "m":
                  warn("Ignored header", line, 0);
                  break;
                default:
                  if (nextLine.length)
                    nextLine = "" + nextLine;
                  return { regular: true, str: line + nextLine };
              }
            }
            if (nextLine.length > 0)
              return { recurse: true, str: nextLine };
            return {};
          }
        }
        return { regular: true, str: line };
      };
    };
    module.exports = ParseHeader;
  }
});

// node_modules/abcjs/src/parse/abc_tokenizer.js
var require_abc_tokenizer = __commonJS({
  "node_modules/abcjs/src/parse/abc_tokenizer.js"(exports, module) {
    var parseCommon = require_abc_common();
    var Tokenizer = function() {
      this.skipWhiteSpace = function(str) {
        for (var i = 0; i < str.length; i++) {
          if (!this.isWhiteSpace(str.charAt(i)))
            return i;
        }
        return str.length;
      };
      var finished = function(str, i) {
        return i >= str.length;
      };
      this.eatWhiteSpace = function(line, index) {
        for (var i = index; i < line.length; i++) {
          if (!this.isWhiteSpace(line.charAt(i)))
            return i - index;
        }
        return i - index;
      };
      this.getKeyPitch = function(str) {
        var i = this.skipWhiteSpace(str);
        if (finished(str, i))
          return { len: 0 };
        switch (str.charAt(i)) {
          case "A":
            return { len: i + 1, token: "A" };
          case "B":
            return { len: i + 1, token: "B" };
          case "C":
            return { len: i + 1, token: "C" };
          case "D":
            return { len: i + 1, token: "D" };
          case "E":
            return { len: i + 1, token: "E" };
          case "F":
            return { len: i + 1, token: "F" };
          case "G":
            return { len: i + 1, token: "G" };
        }
        return { len: 0 };
      };
      this.getSharpFlat = function(str) {
        if (str === "bass")
          return { len: 0 };
        switch (str.charAt(0)) {
          case "#":
            return { len: 1, token: "#" };
          case "b":
            return { len: 1, token: "b" };
        }
        return { len: 0 };
      };
      this.getMode = function(str) {
        var skipAlpha = function(str2, start) {
          while (start < str2.length && (str2.charAt(start) >= "a" && str2.charAt(start) <= "z" || str2.charAt(start) >= "A" && str2.charAt(start) <= "Z"))
            start++;
          return start;
        };
        var i = this.skipWhiteSpace(str);
        if (finished(str, i))
          return { len: 0 };
        var firstThree = str.substring(i, i + 3).toLowerCase();
        if (firstThree.length > 1 && firstThree.charAt(1) === " " || firstThree.charAt(1) === "^" || firstThree.charAt(1) === "_" || firstThree.charAt(1) === "=") firstThree = firstThree.charAt(0);
        switch (firstThree) {
          case "mix":
            return { len: skipAlpha(str, i), token: "Mix" };
          case "dor":
            return { len: skipAlpha(str, i), token: "Dor" };
          case "phr":
            return { len: skipAlpha(str, i), token: "Phr" };
          case "lyd":
            return { len: skipAlpha(str, i), token: "Lyd" };
          case "loc":
            return { len: skipAlpha(str, i), token: "Loc" };
          case "aeo":
            return { len: skipAlpha(str, i), token: "m" };
          case "maj":
            return { len: skipAlpha(str, i), token: "" };
          case "ion":
            return { len: skipAlpha(str, i), token: "" };
          case "min":
            return { len: skipAlpha(str, i), token: "m" };
          case "m":
            return { len: skipAlpha(str, i), token: "m" };
        }
        return { len: 0 };
      };
      this.getClef = function(str, bExplicitOnly) {
        var strOrig = str;
        var i = this.skipWhiteSpace(str);
        if (finished(str, i))
          return { len: 0 };
        var needsClef = false;
        var strClef = str.substring(i);
        if (parseCommon.startsWith(strClef, "clef=")) {
          needsClef = true;
          strClef = strClef.substring(5);
          i += 5;
        }
        if (strClef.length === 0 && needsClef)
          return { len: i + 5, warn: "No clef specified: " + strOrig };
        var j = this.skipWhiteSpace(strClef);
        if (finished(strClef, j))
          return { len: 0 };
        if (j > 0) {
          i += j;
          strClef = strClef.substring(j);
        }
        var name = null;
        if (parseCommon.startsWith(strClef, "treble"))
          name = "treble";
        else if (parseCommon.startsWith(strClef, "bass3"))
          name = "bass3";
        else if (parseCommon.startsWith(strClef, "bass"))
          name = "bass";
        else if (parseCommon.startsWith(strClef, "tenor"))
          name = "tenor";
        else if (parseCommon.startsWith(strClef, "alto2"))
          name = "alto2";
        else if (parseCommon.startsWith(strClef, "alto1"))
          name = "alto1";
        else if (parseCommon.startsWith(strClef, "alto"))
          name = "alto";
        else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, "none")))
          name = "none";
        else if (parseCommon.startsWith(strClef, "perc"))
          name = "perc";
        else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, "C")))
          name = "tenor";
        else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, "F")))
          name = "bass";
        else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, "G")))
          name = "treble";
        else
          return { len: i + 5, warn: "Unknown clef specified: " + strOrig };
        strClef = strClef.substring(name.length);
        j = this.isMatch(strClef, "+8");
        if (j > 0)
          name += "+8";
        else {
          j = this.isMatch(strClef, "-8");
          if (j > 0)
            name += "-8";
        }
        return { len: i + name.length, token: name, explicit: needsClef };
      };
      this.getBarLine = function(line, i) {
        switch (line.charAt(i)) {
          case "]":
            ++i;
            switch (line.charAt(i)) {
              case "|":
                return { len: 2, token: "bar_thick_thin" };
              case "[":
                ++i;
                if (line.charAt(i) >= "1" && line.charAt(i) <= "9" || line.charAt(i) === '"')
                  return { len: 2, token: "bar_invisible" };
                return { len: 1, warn: "Unknown bar symbol" };
              default:
                return { len: 1, token: "bar_invisible" };
            }
            break;
          case ":":
            ++i;
            switch (line.charAt(i)) {
              case ":":
                return { len: 2, token: "bar_dbl_repeat" };
              case "|":
                ++i;
                switch (line.charAt(i)) {
                  case "]":
                    ++i;
                    switch (line.charAt(i)) {
                      case "|":
                        ++i;
                        if (line.charAt(i) === ":") return { len: 5, token: "bar_dbl_repeat" };
                        return { len: 3, token: "bar_right_repeat" };
                      default:
                        return { len: 3, token: "bar_right_repeat" };
                    }
                    break;
                  case "|":
                    ++i;
                    if (line.charAt(i) === ":") return { len: 4, token: "bar_dbl_repeat" };
                    return { len: 3, token: "bar_right_repeat" };
                  default:
                    return { len: 2, token: "bar_right_repeat" };
                }
                break;
              default:
                return { len: 1, warn: "Unknown bar symbol" };
            }
            break;
          case "[":
            ++i;
            if (line.charAt(i) === "|") {
              ++i;
              switch (line.charAt(i)) {
                case ":":
                  return { len: 3, token: "bar_left_repeat" };
                case "]":
                  return { len: 3, token: "bar_invisible" };
                default:
                  return { len: 2, token: "bar_thick_thin" };
              }
            } else {
              if (line.charAt(i) >= "1" && line.charAt(i) <= "9" || line.charAt(i) === '"')
                return { len: 1, token: "bar_invisible" };
              return { len: 0 };
            }
            break;
          case "|":
            ++i;
            switch (line.charAt(i)) {
              case "]":
                return { len: 2, token: "bar_thin_thick" };
              case "|":
                ++i;
                if (line.charAt(i) === ":") return { len: 3, token: "bar_left_repeat" };
                return { len: 2, token: "bar_thin_thin" };
              case ":":
                var colons = 0;
                while (line.charAt(i + colons) === ":") colons++;
                return { len: 1 + colons, token: "bar_left_repeat" };
              default:
                return { len: 1, token: "bar_thin" };
            }
            break;
        }
        return { len: 0 };
      };
      this.getTokenOf = function(str, legalChars) {
        for (var i = 0; i < str.length; i++) {
          if (legalChars.indexOf(str.charAt(i)) < 0)
            return { len: i, token: str.substring(0, i) };
        }
        return { len: i, token: str };
      };
      this.getToken = function(str, start, end) {
        var i = start;
        while (i < end && !this.isWhiteSpace(str.charAt(i)))
          i++;
        return str.substring(start, i);
      };
      this.isMatch = function(str, match) {
        var i = this.skipWhiteSpace(str);
        if (finished(str, i))
          return 0;
        if (parseCommon.startsWith(str.substring(i), match))
          return i + match.length;
        return 0;
      };
      this.getPitchFromTokens = function(tokens) {
        var ret = {};
        var pitches = { A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11 };
        ret.position = pitches[tokens[0].token];
        if (ret.position === void 0)
          return { warn: "Pitch expected. Found: " + tokens[0].token };
        tokens.shift();
        while (tokens.length) {
          switch (tokens[0].token) {
            case ",":
              ret.position -= 7;
              tokens.shift();
              break;
            case "'":
              ret.position += 7;
              tokens.shift();
              break;
            default:
              return ret;
          }
        }
        return ret;
      };
      this.getKeyAccidentals2 = function(tokens) {
        var accs;
        while (tokens.length > 0) {
          var acc;
          if (tokens[0].token === "^") {
            acc = "sharp";
            tokens.shift();
            if (tokens.length === 0) return { accs, warn: "Expected note name after " + acc };
            switch (tokens[0].token) {
              case "^":
                acc = "dblsharp";
                tokens.shift();
                break;
              case "/":
                acc = "quartersharp";
                tokens.shift();
                break;
            }
          } else if (tokens[0].token === "=") {
            acc = "natural";
            tokens.shift();
          } else if (tokens[0].token === "_") {
            acc = "flat";
            tokens.shift();
            if (tokens.length === 0) return { accs, warn: "Expected note name after " + acc };
            switch (tokens[0].token) {
              case "_":
                acc = "dblflat";
                tokens.shift();
                break;
              case "/":
                acc = "quarterflat";
                tokens.shift();
                break;
            }
          } else {
            return { accs };
          }
          if (tokens.length === 0) return { accs, warn: "Expected note name after " + acc };
          switch (tokens[0].token.charAt(0)) {
            case "a":
            case "b":
            case "c":
            case "d":
            case "e":
            case "f":
            case "g":
            case "A":
            case "B":
            case "C":
            case "D":
            case "E":
            case "F":
            case "G":
              if (accs === void 0)
                accs = [];
              accs.push({ acc, note: tokens[0].token.charAt(0) });
              if (tokens[0].token.length === 1)
                tokens.shift();
              else
                tokens[0].token = tokens[0].token.substring(1);
              break;
            default:
              return { accs, warn: "Expected note name after " + acc + " Found: " + tokens[0].token };
          }
        }
        return { accs };
      };
      this.getKeyAccidental = function(str) {
        var accTranslation = {
          "^": "sharp",
          "^^": "dblsharp",
          "=": "natural",
          "_": "flat",
          "__": "dblflat",
          "_/": "quarterflat",
          "^/": "quartersharp"
        };
        var i = this.skipWhiteSpace(str);
        if (finished(str, i))
          return { len: 0 };
        var acc = null;
        switch (str.charAt(i)) {
          case "^":
          case "_":
          case "=":
            acc = str.charAt(i);
            break;
          default:
            return { len: 0 };
        }
        i++;
        if (finished(str, i))
          return { len: 1, warn: "Expected note name after accidental" };
        switch (str.charAt(i)) {
          case "a":
          case "b":
          case "c":
          case "d":
          case "e":
          case "f":
          case "g":
          case "A":
          case "B":
          case "C":
          case "D":
          case "E":
          case "F":
          case "G":
            return { len: i + 1, token: { acc: accTranslation[acc], note: str.charAt(i) } };
          case "^":
          case "_":
          case "/":
            acc += str.charAt(i);
            i++;
            if (finished(str, i))
              return { len: 2, warn: "Expected note name after accidental" };
            switch (str.charAt(i)) {
              case "a":
              case "b":
              case "c":
              case "d":
              case "e":
              case "f":
              case "g":
              case "A":
              case "B":
              case "C":
              case "D":
              case "E":
              case "F":
              case "G":
                return { len: i + 1, token: { acc: accTranslation[acc], note: str.charAt(i) } };
              default:
                return { len: 2, warn: "Expected note name after accidental" };
            }
            break;
          default:
            return { len: 1, warn: "Expected note name after accidental" };
        }
      };
      this.isWhiteSpace = function(ch) {
        return ch === " " || ch === "	" || ch === "";
      };
      this.getMeat = function(line, start, end) {
        var comment = line.indexOf("%", start);
        if (comment >= 0 && comment < end)
          end = comment;
        while (start < end && (line.charAt(start) === " " || line.charAt(start) === "	" || line.charAt(start) === ""))
          start++;
        while (start < end && (line.charAt(end - 1) === " " || line.charAt(end - 1) === "	" || line.charAt(end - 1) === ""))
          end--;
        return { start, end };
      };
      var isLetter = function(ch) {
        return ch >= "A" && ch <= "Z" || ch >= "a" && ch <= "z";
      };
      var isNumber = function(ch) {
        return ch >= "0" && ch <= "9";
      };
      this.tokenize = function(line, start, end, alphaUntilWhiteSpace) {
        var ret = this.getMeat(line, start, end);
        start = ret.start;
        end = ret.end;
        var tokens = [];
        var i;
        while (start < end) {
          if (line.charAt(start) === '"') {
            i = start + 1;
            while (i < end && line.charAt(i) !== '"') i++;
            tokens.push({ type: "quote", token: line.substring(start + 1, i), start: start + 1, end: i });
            i++;
          } else if (isLetter(line.charAt(start))) {
            i = start + 1;
            if (alphaUntilWhiteSpace)
              while (i < end && !this.isWhiteSpace(line.charAt(i))) i++;
            else
              while (i < end && isLetter(line.charAt(i))) i++;
            tokens.push({ type: "alpha", token: line.substring(start, i), continueId: isNumber(line.charAt(i)), start, end: i });
            start = i + 1;
          } else if (line.charAt(start) === "." && isNumber(line.charAt(i + 1))) {
            i = start + 1;
            var int2 = null;
            var float2 = null;
            while (i < end && isNumber(line.charAt(i))) i++;
            float2 = parseFloat(line.substring(start, i));
            tokens.push({ type: "number", token: line.substring(start, i), intt: int2, floatt: float2, continueId: isLetter(line.charAt(i)), start, end: i });
            start = i + 1;
          } else if (isNumber(line.charAt(start)) || line.charAt(start) === "-" && isNumber(line.charAt(i + 1))) {
            i = start + 1;
            var intt = null;
            var floatt = null;
            while (i < end && isNumber(line.charAt(i))) i++;
            if (line.charAt(i) === "." && isNumber(line.charAt(i + 1))) {
              i++;
              while (i < end && isNumber(line.charAt(i))) i++;
            } else
              intt = parseInt(line.substring(start, i));
            floatt = parseFloat(line.substring(start, i));
            tokens.push({ type: "number", token: line.substring(start, i), intt, floatt, continueId: isLetter(line.charAt(i)), start, end: i });
            start = i + 1;
          } else if (line.charAt(start) === " " || line.charAt(start) === "	") {
            i = start + 1;
          } else {
            tokens.push({ type: "punct", token: line.charAt(start), start, end: start + 1 });
            i = start + 1;
          }
          start = i;
        }
        return tokens;
      };
      this.getVoiceToken = function(line, start, end) {
        var i = start;
        while (i < end && this.isWhiteSpace(line.charAt(i)) || line.charAt(i) === "=")
          i++;
        if (line.charAt(i) === '"') {
          var close = line.indexOf('"', i + 1);
          if (close === -1 || close >= end)
            return { len: 1, err: "Missing close quote" };
          return { len: close - start + 1, token: this.translateString(line.substring(i + 1, close)) };
        } else {
          var ii = i;
          while (ii < end && !this.isWhiteSpace(line.charAt(ii)) && line.charAt(ii) !== "=")
            ii++;
          return { len: ii - start + 1, token: line.substring(i, ii) };
        }
      };
      var charMap = {
        "`a": "",
        "'a": "",
        "^a": "",
        "~a": "",
        '"a': "",
        "oa": "",
        "aa": "",
        "=a": "",
        "ua": "",
        ";a": "",
        "`e": "",
        "'e": "",
        "^e": "",
        '"e': "",
        "=e": "",
        "ue": "",
        ";e": "",
        ".e": "",
        "`i": "",
        "'i": "",
        "^i": "",
        '"i': "",
        "=i": "",
        "ui": "",
        ";i": "",
        "`o": "",
        "'o": "",
        "^o": "",
        "~o": "",
        '"o': "",
        "=o": "",
        "uo": "",
        "/o": "",
        "`u": "",
        "'u": "",
        "^u": "",
        "~u": "",
        '"u': "",
        "ou": "",
        "=u": "",
        "uu": "",
        ";u": "",
        "`A": "",
        "'A": "",
        "^A": "",
        "~A": "",
        '"A': "",
        "oA": "",
        "AA": "",
        "=A": "",
        "uA": "",
        ";A": "",
        "`E": "",
        "'E": "",
        "^E": "",
        '"E': "",
        "=E": "",
        "uE": "",
        ";E": "",
        ".E": "",
        "`I": "",
        "'I": "",
        "^I": "",
        "~I": "",
        '"I': "",
        "=I": "",
        "uI": "",
        ";I": "",
        ".I": "",
        "`O": "",
        "'O": "",
        "^O": "",
        "~O": "",
        '"O': "",
        "=O": "",
        "uO": "",
        "/O": "",
        "`U": "",
        "'U": "",
        "^U": "",
        "~U": "",
        '"U': "",
        "oU": "",
        "=U": "",
        "uU": "",
        ";U": "",
        "ae": "",
        "AE": "",
        "oe": "",
        "OE": "",
        "ss": "",
        "'c": "",
        "^c": "",
        "uc": "",
        "cc": "",
        ".c": "",
        "cC": "",
        "'C": "",
        "^C": "",
        "uC": "",
        ".C": "",
        "~N": "",
        "~n": "",
        "=s": "",
        "vs": "",
        "DH": "",
        "dh": "",
        "HO": "",
        "Ho": "",
        "HU": "",
        "Hu": "",
        "'Y": "",
        "'y": "",
        "^Y": "",
        "^y": "",
        '"Y': "",
        '"y': "",
        "vS": "",
        "vZ": "",
        "vz": ""
        // More chars:                                                                    
      };
      var charMap1 = {
        "#": "",
        "b": "",
        "=": ""
      };
      var charMap2 = {
        "201": "",
        "202": "",
        "203": "",
        "241": "",
        "242": "",
        "252": "a",
        "262": "2",
        "272": "o",
        "302": "",
        "312": "",
        "322": "",
        "332": "",
        "342": "",
        "352": "",
        "362": "",
        "372": "",
        "243": "",
        "253": "",
        "263": "3",
        "273": "",
        "303": "",
        "313": "",
        "323": "",
        "333": "",
        "343": "",
        "353": "",
        "363": "",
        "373": "",
        "244": "",
        "254": "",
        "264": "  ",
        "274": "14",
        "304": "",
        "314": "",
        "324": "",
        "334": "",
        "344": "",
        "354": "",
        "364": "",
        "374": "",
        "245": "",
        "255": "-",
        "265": "",
        "275": "12",
        "305": "",
        "315": "",
        "325": "",
        "335": "",
        "345": "",
        "355": "",
        "365": "",
        "375": "",
        "246": "",
        "256": "",
        "266": "",
        "276": "34",
        "306": "",
        "316": "",
        "326": "",
        "336": "",
        "346": "",
        "356": "",
        "366": "",
        "376": "",
        "247": "",
        "257": " ",
        "267": "",
        "277": "",
        "307": "",
        "317": "",
        "327": "",
        "337": "",
        "347": "",
        "357": "",
        "367": "",
        "377": "",
        "250": " ",
        "260": "",
        "270": " ",
        "300": "",
        "310": "",
        "320": "",
        "330": "",
        "340": "",
        "350": "",
        "360": "",
        "370": "",
        "251": "",
        "261": "",
        "271": "1",
        "301": "",
        "311": "",
        "321": "",
        "331": "",
        "341": "",
        "351": "",
        "361": "",
        "371": ""
      };
      this.translateString = function(str) {
        var arr = str.split("\\");
        if (arr.length === 1) return str;
        var out = null;
        parseCommon.each(arr, function(s) {
          if (out === null)
            out = s;
          else {
            var c = charMap[s.substring(0, 2)];
            if (c !== void 0)
              out += c + s.substring(2);
            else {
              c = charMap2[s.substring(0, 3)];
              if (c !== void 0)
                out += c + s.substring(3);
              else {
                c = charMap1[s.substring(0, 1)];
                if (c !== void 0)
                  out += c + s.substring(1);
                else
                  out += "\\" + s;
              }
            }
          }
        });
        return out;
      };
      this.getNumber = function(line, index) {
        var num = 0;
        while (index < line.length) {
          switch (line.charAt(index)) {
            case "0":
              num = num * 10;
              index++;
              break;
            case "1":
              num = num * 10 + 1;
              index++;
              break;
            case "2":
              num = num * 10 + 2;
              index++;
              break;
            case "3":
              num = num * 10 + 3;
              index++;
              break;
            case "4":
              num = num * 10 + 4;
              index++;
              break;
            case "5":
              num = num * 10 + 5;
              index++;
              break;
            case "6":
              num = num * 10 + 6;
              index++;
              break;
            case "7":
              num = num * 10 + 7;
              index++;
              break;
            case "8":
              num = num * 10 + 8;
              index++;
              break;
            case "9":
              num = num * 10 + 9;
              index++;
              break;
            default:
              return { num, index };
          }
        }
        return { num, index };
      };
      this.getFraction = function(line, index) {
        var num = 1;
        var den = 1;
        if (line.charAt(index) !== "/") {
          var ret = this.getNumber(line, index);
          num = ret.num;
          index = ret.index;
        }
        if (line.charAt(index) === "/") {
          index++;
          if (line.charAt(index) === "/") {
            var div = 0.5;
            while (line.charAt(index++) === "/")
              div = div / 2;
            return { value: num * div, index: index - 1 };
          } else {
            var iSave = index;
            var ret2 = this.getNumber(line, index);
            if (ret2.num === 0 && iSave === index)
              ret2.num = 2;
            if (ret2.num !== 0)
              den = ret2.num;
            index = ret2.index;
          }
        }
        return { value: num / den, index };
      };
      this.theReverser = function(str) {
        if (parseCommon.endsWith(str, ", The"))
          return "The " + str.substring(0, str.length - 5);
        if (parseCommon.endsWith(str, ", A"))
          return "A " + str.substring(0, str.length - 3);
        return str;
      };
      this.stripComment = function(str) {
        var i = str.indexOf("%");
        if (i >= 0)
          return parseCommon.strip(str.substring(0, i));
        return parseCommon.strip(str);
      };
      this.getInt = function(str) {
        var x = parseInt(str);
        if (isNaN(x))
          return { digits: 0 };
        var s = "" + x;
        var i = str.indexOf(s);
        return { value: x, digits: i + s.length };
      };
      this.getFloat = function(str) {
        var x = parseFloat(str);
        if (isNaN(x))
          return { digits: 0 };
        var s = "" + x;
        var i = str.indexOf(s);
        return { value: x, digits: i + s.length };
      };
      this.getMeasurement = function(tokens) {
        if (tokens.length === 0) return { used: 0 };
        var used = 1;
        var num = "";
        if (tokens[0].token === "-") {
          tokens.shift();
          num = "-";
          used++;
        } else if (tokens[0].type !== "number") return { used: 0 };
        num += tokens.shift().token;
        if (tokens.length === 0) return { used: 1, value: parseInt(num) };
        var x = tokens.shift();
        if (x.token === ".") {
          used++;
          if (tokens.length === 0) return { used, value: parseInt(num) };
          if (tokens[0].type === "number") {
            x = tokens.shift();
            num = num + "." + x.token;
            used++;
            if (tokens.length === 0) return { used, value: parseFloat(num) };
          }
          x = tokens.shift();
        }
        switch (x.token) {
          case "pt":
            return { used: used + 1, value: parseFloat(num) };
          case "cm":
            return { used: used + 1, value: parseFloat(num) / 2.54 * 72 };
          case "in":
            return { used: used + 1, value: parseFloat(num) * 72 };
          default:
            tokens.unshift(x);
            return { used, value: parseFloat(num) };
        }
        return { used: 0 };
      };
      var substInChord = function(str) {
        while (str.indexOf("\\n") !== -1) {
          str = str.replace("\\n", "\n");
        }
        return str;
      };
      this.getBrackettedSubstring = function(line, i, maxErrorChars, _matchChar) {
        var matchChar = _matchChar || line.charAt(i);
        var pos = i + 1;
        while (pos < line.length && line.charAt(pos) !== matchChar)
          ++pos;
        if (line.charAt(pos) === matchChar)
          return [pos - i + 1, substInChord(line.substring(i + 1, pos)), true];
        else {
          pos = i + maxErrorChars;
          if (pos > line.length - 1)
            pos = line.length - 1;
          return [pos - i + 1, substInChord(line.substring(i + 1, pos)), false];
        }
      };
    };
    module.exports = Tokenizer;
  }
});

// node_modules/abcjs/src/parse/wrap_lines.js
var require_wrap_lines = __commonJS({
  "node_modules/abcjs/src/parse/wrap_lines.js"(exports, module) {
    function wrapLines(tune, lineBreaks) {
      if (!lineBreaks || tune.lines.length === 0)
        return;
      var newLines = [];
      var startNewLine = [];
      var currentLine = [];
      var measureNumber = [];
      var measureMarker = [];
      var lastMeter = "";
      var voiceStart = {};
      var linesWithoutStaff = 0;
      for (var i = 0; i < tune.lines.length; i++) {
        var line = tune.lines[i];
        if (line.staff) {
          var staffs = line.staff;
          for (var j = 0; j < staffs.length; j++) {
            if (startNewLine[j] === void 0) {
              startNewLine[j] = [];
              currentLine[j] = [];
              measureNumber[j] = [];
              measureMarker[j] = [];
            }
            var staff = staffs[j];
            var voices = staff.voices;
            for (var k = 0; k < voices.length; k++) {
              if (startNewLine[j][k] === void 0) {
                startNewLine[j][k] = true;
                currentLine[j][k] = 0;
                measureNumber[j][k] = 0;
                measureMarker[j][k] = 0;
              }
              if (linesWithoutStaff > 0) currentLine[j][k] += linesWithoutStaff;
              var voice = voices[k];
              for (var e = 0; e < voice.length; e++) {
                if (startNewLine[j][k]) {
                  if (!newLines[currentLine[j][k]])
                    newLines[currentLine[j][k]] = { staff: [] };
                  if (!newLines[currentLine[j][k]].staff[j]) {
                    newLines[currentLine[j][k]].staff[j] = { voices: [] };
                    for (var key in staff) {
                      if (staff.hasOwnProperty(key)) {
                        if (key === "meter") {
                          if (newLines.length === 1 || lastMeter !== JSON.stringify(staff[key])) {
                            lastMeter = JSON.stringify(staff[key]);
                            newLines[currentLine[j][k]].staff[j][key] = staff[key];
                          }
                        } else if (key !== "voices") {
                          newLines[currentLine[j][k]].staff[j][key] = staff[key];
                        }
                      }
                    }
                  }
                  if (measureMarker[j][k])
                    newLines[currentLine[j][k]].staff[j].barNumber = measureMarker[j][k];
                  startNewLine[j][k] = false;
                }
                var element = voice[e];
                if (!newLines[currentLine[j][k]].staff[j].voices[k]) {
                  newLines[currentLine[j][k]].staff[j].voices[k] = [];
                  for (var startItem in voiceStart) {
                    if (voiceStart.hasOwnProperty(startItem)) {
                      newLines[currentLine[j][k]].staff[j].voices[k].push(voiceStart[startItem]);
                    }
                  }
                }
                newLines[currentLine[j][k]].staff[j].voices[k].push(element);
                if (element.el_type === "stem") {
                  voiceStart[element.el_type] = element;
                }
                if (element.el_type === "bar") {
                  measureNumber[j][k]++;
                  if (lineBreaks[measureNumber[j][k]]) {
                    startNewLine[j][k] = true;
                    currentLine[j][k]++;
                    measureMarker[j][k] = element.barNumber;
                    delete element.barNumber;
                  }
                }
              }
            }
          }
          linesWithoutStaff = 0;
        } else {
          newLines.push(line);
          linesWithoutStaff++;
        }
      }
      tune.lines = newLines;
    }
    function freeFormLineBreaks(widths, lineBreakPoint) {
      var lineBreaks = [];
      var totals = [];
      var totalThisLine = 0;
      for (var i = 0; i < widths.length; i++) {
        var width = widths[i];
        var attemptedWidth = totalThisLine + width;
        if (attemptedWidth < lineBreakPoint)
          totalThisLine = attemptedWidth;
        else {
          var oldDistance = lineBreakPoint - totalThisLine;
          var newDistance = attemptedWidth - lineBreakPoint;
          if (oldDistance < newDistance && totalThisLine > 0) {
            lineBreaks.push(i - 1);
            totals.push(Math.round(totalThisLine - width));
            totalThisLine = width;
          } else {
            if (i < widths.length - 1) {
              lineBreaks.push(i);
              totals.push(Math.round(totalThisLine));
              totalThisLine = 0;
            }
          }
        }
      }
      totals.push(Math.round(totalThisLine));
      return { lineBreaks, totals };
    }
    function clone(arr) {
      var newArr = [];
      for (var i = 0; i < arr.length; i++)
        newArr.push(arr[i]);
      return newArr;
    }
    function oneTry(measureWidths, idealWidths, accumulator, lineAccumulator, lineWidths, lastVariance, highestVariance, currLine, lineBreaks, startIndex, otherTries) {
      for (var i = startIndex; i < measureWidths.length; i++) {
        var measureWidth = measureWidths[i];
        accumulator += measureWidth;
        lineAccumulator += measureWidth;
        var thisVariance = Math.abs(accumulator - idealWidths[currLine]);
        var varianceIsClose = Math.abs(thisVariance - lastVariance) < idealWidths[0] / 10;
        if (varianceIsClose) {
          if (thisVariance < lastVariance) {
            var newWidths = clone(lineWidths);
            var newBreaks = clone(lineBreaks);
            newBreaks.push(i - 1);
            newWidths.push(lineAccumulator - measureWidth);
            otherTries.push({
              accumulator,
              lineAccumulator: measureWidth,
              lineWidths: newWidths,
              lastVariance: Math.abs(accumulator - idealWidths[currLine + 1]),
              highestVariance: Math.max(highestVariance, lastVariance),
              currLine: currLine + 1,
              lineBreaks: newBreaks,
              startIndex: i + 1
            });
          } else if (thisVariance > lastVariance && i < measureWidths.length - 1) {
            newWidths = clone(lineWidths);
            newBreaks = clone(lineBreaks);
            otherTries.push({
              accumulator,
              lineAccumulator,
              lineWidths: newWidths,
              lastVariance: thisVariance,
              highestVariance: Math.max(highestVariance, thisVariance),
              currLine,
              lineBreaks: newBreaks,
              startIndex: i + 1
            });
          }
        }
        if (thisVariance > lastVariance) {
          lineBreaks.push(i - 1);
          currLine++;
          highestVariance = Math.max(highestVariance, lastVariance);
          lastVariance = Math.abs(accumulator - idealWidths[currLine]);
          lineWidths.push(lineAccumulator - measureWidth);
          lineAccumulator = measureWidth;
        } else {
          lastVariance = thisVariance;
        }
      }
      lineWidths.push(lineAccumulator);
    }
    function optimizeLineWidths(widths, lineBreakPoint, lineBreaks, explanation) {
      var numLines = Math.ceil(widths.total / lineBreakPoint) + 1;
      var idealWidth = Math.floor(widths.total / numLines);
      var idealWidths = [];
      for (var i = 0; i < numLines; i++)
        idealWidths.push(idealWidth * (i + 1));
      var otherTries = [];
      otherTries.push({
        accumulator: 0,
        lineAccumulator: 0,
        lineWidths: [],
        lastVariance: 999999,
        highestVariance: 0,
        currLine: 0,
        lineBreaks: [],
        // These are the zero-based last measure on each line
        startIndex: 0
      });
      var index = 0;
      while (index < otherTries.length) {
        oneTry(
          widths.measureWidths,
          idealWidths,
          otherTries[index].accumulator,
          otherTries[index].lineAccumulator,
          otherTries[index].lineWidths,
          otherTries[index].lastVariance,
          otherTries[index].highestVariance,
          otherTries[index].currLine,
          otherTries[index].lineBreaks,
          otherTries[index].startIndex,
          otherTries
        );
        index++;
      }
      for (i = 0; i < otherTries.length; i++) {
        var otherTry = otherTries[i];
        otherTry.variances = [];
        otherTry.aveVariance = 0;
        for (var j = 0; j < otherTry.lineWidths.length; j++) {
          var lineWidth2 = otherTry.lineWidths[j];
          otherTry.variances.push(lineWidth2 - idealWidths[0]);
          otherTry.aveVariance += Math.abs(lineWidth2 - idealWidths[0]);
        }
        otherTry.aveVariance = otherTry.aveVariance / otherTry.lineWidths.length;
        explanation.attempts.push({ type: "optimizeLineWidths", lineBreaks: otherTry.lineBreaks, variances: otherTry.variances, aveVariance: otherTry.aveVariance, widths: widths.measureWidths });
      }
      var smallest = 9999999;
      var smallestIndex = -1;
      for (i = 0; i < otherTries.length; i++) {
        otherTry = otherTries[i];
        if (otherTry.aveVariance < smallest) {
          smallest = otherTry.aveVariance;
          smallestIndex = i;
        }
      }
      return { failed: false, lineBreaks: otherTries[smallestIndex].lineBreaks, variance: otherTries[smallestIndex].highestVariance };
    }
    function fixedMeasureLineBreaks(widths, lineBreakPoint, preferredMeasuresPerLine) {
      var lineBreaks = [];
      var totals = [];
      var thisWidth = 0;
      var failed = false;
      for (var i = 0; i < widths.length; i++) {
        thisWidth += widths[i];
        if (thisWidth > lineBreakPoint) {
          failed = true;
        }
        if (i % preferredMeasuresPerLine === preferredMeasuresPerLine - 1) {
          if (i !== widths.length - 1)
            lineBreaks.push(i);
          totals.push(Math.round(thisWidth));
          thisWidth = 0;
        }
      }
      return { failed, totals, lineBreaks };
    }
    function getRevisedTune(lineBreaks, staffWidth, abcString, params, Parse) {
      var abcParser = new Parse();
      var revisedParams = {
        lineBreaks,
        staffwidth: staffWidth
      };
      for (var key in params) {
        if (params.hasOwnProperty(key) && key !== "wrap" && key !== "staffwidth") {
          revisedParams[key] = params[key];
        }
      }
      abcParser.parse(abcString, revisedParams);
      return { tune: abcParser.getTune(), revisedParams };
    }
    function calcLineWraps(tune, widths, abcString, params, Parse, engraver_controller) {
      if (params.staffwidth < widths.left) {
        return {
          explanation: "Staffwidth is narrower than the margin",
          tune,
          revisedParams: params
        };
      }
      var scale = params.scale ? Math.max(params.scale, 0.1) : 1;
      var minSpacing = params.wrap.minSpacing ? Math.max(parseFloat(params.wrap.minSpacing), 1) : 1;
      var minSpacingLimit = params.wrap.minSpacingLimit ? Math.max(parseFloat(params.wrap.minSpacingLimit), 1) : minSpacing - 0.1;
      var maxSpacing = params.wrap.maxSpacing ? Math.max(parseFloat(params.wrap.maxSpacing), 1) : void 0;
      if (params.wrap.lastLineLimit && !maxSpacing)
        maxSpacing = Math.max(parseFloat(params.wrap.lastLineLimit), 1);
      var targetHeight = params.wrap.targetHeight ? Math.max(parseInt(params.wrap.targetHeight, 10), 100) : void 0;
      var preferredMeasuresPerLine = params.wrap.preferredMeasuresPerLine ? Math.max(parseInt(params.wrap.preferredMeasuresPerLine, 10), 1) : void 0;
      var lineBreakPoint = (params.staffwidth - widths.left) / minSpacing / scale;
      var minLineSize = (params.staffwidth - widths.left) / maxSpacing / scale;
      var allowableVariance = (params.staffwidth - widths.left) / minSpacingLimit / scale;
      var explanation = { widths, lineBreakPoint, minLineSize, attempts: [], staffWidth: params.staffwidth, minWidth: Math.round(allowableVariance) };
      var lineBreaks = null;
      if (preferredMeasuresPerLine) {
        var f = fixedMeasureLineBreaks(widths.measureWidths, lineBreakPoint, preferredMeasuresPerLine);
        explanation.attempts.push({ type: "Fixed Measures Per Line", preferredMeasuresPerLine, lineBreaks: f.lineBreaks, failed: f.failed, totals: f.totals });
        if (!f.failed)
          lineBreaks = f.lineBreaks;
      }
      if (!lineBreaks) {
        var ff = freeFormLineBreaks(widths.measureWidths, lineBreakPoint);
        explanation.attempts.push({ type: "Free Form", lineBreaks: ff.lineBreaks, totals: ff.totals });
        lineBreaks = ff.lineBreaks;
        ff = optimizeLineWidths(widths, lineBreakPoint, lineBreaks, explanation);
        explanation.attempts.push({ type: "Optimize", failed: ff.failed, reason: ff.reason, lineBreaks: ff.lineBreaks, totals: ff.totals });
        if (!ff.failed)
          lineBreaks = ff.lineBreaks;
      }
      var staffWidth = params.staffwidth;
      var ret = getRevisedTune(lineBreaks, staffWidth, abcString, params, Parse);
      var newWidths = engraver_controller.getMeasureWidths(ret.tune);
      var gotTune = true;
      explanation.attempts.push({ type: "heightCheck", height: newWidths.height });
      if (lineBreaks.length === 0 && minLineSize > widths.total) {
        staffWidth = widths.total * maxSpacing * scale + widths.left;
        explanation.attempts.push({ type: "too sparse", newWidth: Math.round(staffWidth) });
        gotTune = false;
      }
      if (!gotTune)
        ret = getRevisedTune(lineBreaks, staffWidth, abcString, params, Parse);
      ret.explanation = explanation;
      return ret;
    }
    module.exports = { wrapLines, calcLineWraps };
  }
});

// node_modules/abcjs/src/data/abc_tune.js
var require_abc_tune = __commonJS({
  "node_modules/abcjs/src/data/abc_tune.js"(exports, module) {
    var parseCommon = require_abc_common();
    var parseKeyVoice = require_abc_parse_key_voice();
    var spacing = require_abc_spacing();
    var Tune = function() {
      this.getBeatLength = function() {
        for (var i = 0; i < this.lines.length; i++) {
          if (this.lines[i].staff) {
            for (var j = 0; j < this.lines[i].staff.length; j++) {
              if (this.lines[i].staff[j].meter) {
                var meter = this.lines[i].staff[j].meter;
                if (meter.type === "specified") {
                  if (meter.value.length > 0) {
                    var num = parseInt(meter.value[0].num, 10);
                    var den = parseInt(meter.value[0].den, 10);
                    if (num === 3 && den === 8) return 3 / 8;
                    if (num === 6 && den === 8) return 3 / 8;
                    if (num === 6 && den === 4) return 3 / 4;
                    if (num === 9 && den === 8) return 3 / 8;
                    if (num === 12 && den === 8) return 3 / 8;
                    return 1 / den;
                  } else
                    return 1 / 4;
                } else if (meter.type === "cut_time") {
                  return 1 / 2;
                } else {
                  return 1 / 4;
                }
              }
            }
          }
        }
        return 1 / 4;
      };
      this.getPickupLength = function() {
        var pickupLength = 0;
        var barLength = this.getBarLength();
        for (var i = 0; i < this.lines.length; i++) {
          if (this.lines[i].staff) {
            for (var j = 0; j < this.lines[i].staff.length; j++) {
              for (var v = 0; v < this.lines[i].staff[j].voices.length; v++) {
                var voice = this.lines[i].staff[j].voices[v];
                var hasNote = false;
                var tripletMultiplier = 1;
                for (var el = 0; el < voice.length; el++) {
                  var isSpacer = voice[el].rest && voice[el].rest.type === "spacer";
                  if (voice[el].startTriplet)
                    tripletMultiplier = voice[el].tripletMultiplier;
                  if (voice[el].duration && !isSpacer)
                    pickupLength += voice[el].duration * tripletMultiplier;
                  if (voice[el].endTriplet)
                    tripletMultiplier = 1;
                  if (pickupLength >= barLength)
                    pickupLength -= barLength;
                  if (voice[el].el_type === "bar")
                    return pickupLength;
                }
              }
            }
          }
        }
        return pickupLength;
      };
      this.getBarLength = function() {
        var meter = this.getMeterFraction();
        return meter.num / meter.den;
      };
      this.millisecondsPerMeasure = function(bpmOverride) {
        var bpm;
        if (bpmOverride) {
          bpm = bpmOverride;
        } else {
          var tempo = this.metaText ? this.metaText.tempo : null;
          bpm = this.getBpm(tempo);
        }
        if (bpm <= 0)
          bpm = 1;
        var beatsPerMeasure = this.getBeatsPerMeasure();
        var minutesPerMeasure = beatsPerMeasure / bpm;
        return minutesPerMeasure * 6e4;
      };
      this.getBeatsPerMeasure = function() {
        var beatsPerMeasure;
        var meter = this.getMeterFraction();
        if (meter.den === 8) {
          beatsPerMeasure = meter.num / 3;
        } else {
          beatsPerMeasure = meter.num;
        }
        if (beatsPerMeasure <= 0)
          beatsPerMeasure = 1;
        return beatsPerMeasure;
      };
      this.reset = function() {
        this.version = "1.0.1";
        this.media = "screen";
        this.metaText = {};
        this.formatting = {};
        this.lines = [];
        this.staffNum = 0;
        this.voiceNum = 0;
        this.lineNum = 0;
      };
      this.resolveOverlays = function() {
        var madeChanges = false;
        for (var i = 0; i < this.lines.length; i++) {
          var line = this.lines[i];
          if (line.staff) {
            for (var j = 0; j < line.staff.length; j++) {
              var staff = line.staff[j];
              var overlayVoice = [];
              for (var k = 0; k < staff.voices.length; k++) {
                var voice = staff.voices[k];
                overlayVoice.push({ hasOverlay: false, voice: [], snip: [] });
                var durationThisBar = 0;
                var inOverlay = false;
                var snipStart = -1;
                for (var kk = 0; kk < voice.length; kk++) {
                  var event = voice[kk];
                  if (event.el_type === "overlay" && !inOverlay) {
                    madeChanges = true;
                    inOverlay = true;
                    snipStart = kk;
                    overlayVoice[k].hasOverlay = true;
                  } else if (event.el_type === "bar") {
                    if (inOverlay) {
                      inOverlay = false;
                      overlayVoice[k].snip.push({ start: snipStart, len: kk - snipStart });
                      overlayVoice[k].voice.push(event);
                    } else {
                      if (durationThisBar > 0)
                        overlayVoice[k].voice.push({ el_type: "note", duration: durationThisBar, rest: { type: "invisible" }, startChar: event.startChar, endChar: event.endChar });
                      overlayVoice[k].voice.push(event);
                    }
                    durationThisBar = 0;
                  } else if (event.el_type === "note") {
                    if (inOverlay) {
                      overlayVoice[k].voice.push(event);
                    } else {
                      durationThisBar += event.duration;
                    }
                  } else if (event.el_type === "scale" || event.el_type === "stem" || event.el_type === "overlay" || event.el_type === "style" || event.el_type === "transpose") {
                    overlayVoice[k].voice.push(event);
                  }
                }
                if (overlayVoice[k].hasOverlay && overlayVoice[k].snip.length === 0) {
                  overlayVoice[k].snip.push({ start: snipStart, len: voice.length - snipStart });
                }
              }
              for (k = 0; k < overlayVoice.length; k++) {
                var ov = overlayVoice[k];
                if (ov.hasOverlay) {
                  staff.voices.push(ov.voice);
                  for (var kkk = ov.snip.length - 1; kkk >= 0; kkk--) {
                    var snip = ov.snip[kkk];
                    staff.voices[k].splice(snip.start, snip.len);
                  }
                  for (kkk = 0; kkk < staff.voices[staff.voices.length - 1].length; kkk++) {
                    staff.voices[staff.voices.length - 1][kkk] = parseCommon.clone(staff.voices[staff.voices.length - 1][kkk]);
                    var el = staff.voices[staff.voices.length - 1][kkk];
                    if (el.el_type === "bar" && el.startEnding) {
                      delete el.startEnding;
                    }
                    if (el.el_type === "bar" && el.endEnding)
                      delete el.endEnding;
                  }
                }
              }
            }
          }
        }
        return madeChanges;
      };
      function fixTitles(lines) {
        var firstMusicLine = true;
        for (var i = 0; i < lines.length; i++) {
          var line = lines[i];
          if (line.staff) {
            for (var j = 0; j < line.staff.length; j++) {
              var staff = line.staff[j];
              if (staff.title) {
                var hasATitle = false;
                for (var k = 0; k < staff.title.length; k++) {
                  if (staff.title[k]) {
                    staff.title[k] = firstMusicLine ? staff.title[k].name : staff.title[k].subname;
                    if (staff.title[k])
                      hasATitle = true;
                    else
                      staff.title[k] = "";
                  } else
                    staff.title[k] = "";
                }
                if (!hasATitle)
                  delete staff.title;
              }
            }
            firstMusicLine = false;
          }
        }
      }
      this.cleanUp = function(defWidth, defLength, barsperstaff, staffnonote, currSlur) {
        this.closeLine();
        if (this.metaText.tempo && this.metaText.tempo.bpm && !this.metaText.tempo.duration)
          this.metaText.tempo.duration = [this.getBeatLength()];
        var anyDeleted = false;
        var i, s, v;
        for (i = 0; i < this.lines.length; i++) {
          if (this.lines[i].staff !== void 0) {
            var hasAny = false;
            for (s = 0; s < this.lines[i].staff.length; s++) {
              if (this.lines[i].staff[s] === void 0) {
                anyDeleted = true;
                this.lines[i].staff[s] = null;
              } else {
                for (v = 0; v < this.lines[i].staff[s].voices.length; v++) {
                  if (this.lines[i].staff[s].voices[v] === void 0)
                    this.lines[i].staff[s].voices[v] = [];
                  else if (this.containsNotes(this.lines[i].staff[s].voices[v])) hasAny = true;
                }
              }
            }
            if (!hasAny) {
              this.lines[i] = null;
              anyDeleted = true;
            }
          }
        }
        if (anyDeleted) {
          this.lines = parseCommon.compact(this.lines);
          parseCommon.each(this.lines, function(line) {
            if (line.staff)
              line.staff = parseCommon.compact(line.staff);
          });
        }
        if (barsperstaff) {
          while (wrapMusicLines(this.lines, barsperstaff)) {
          }
        }
        if (staffnonote) {
          anyDeleted = false;
          for (i = 0; i < this.lines.length; i++) {
            if (this.lines[i].staff !== void 0) {
              for (s = 0; s < this.lines[i].staff.length; s++) {
                var keepThis = false;
                for (v = 0; v < this.lines[i].staff[s].voices.length; v++) {
                  if (this.containsNotesStrict(this.lines[i].staff[s].voices[v])) {
                    keepThis = true;
                  }
                }
                if (!keepThis) {
                  anyDeleted = true;
                  this.lines[i].staff[s] = null;
                }
              }
            }
          }
          if (anyDeleted) {
            parseCommon.each(this.lines, function(line) {
              if (line.staff)
                line.staff = parseCommon.compact(line.staff);
            });
          }
        }
        fixTitles(this.lines);
        for (i = 0; i < this.lines.length; i++) {
          if (this.lines[i].staff) {
            for (s = 0; s < this.lines[i].staff.length; s++)
              delete this.lines[i].staff[s].workingClef;
          }
        }
        while (this.resolveOverlays()) {
        }
        function cleanUpSlursInLine(line) {
          var x;
          var addEndSlur = function(obj, num, chordPos) {
            if (currSlur[chordPos] === void 0) {
              for (x = 0; x < currSlur.length; x++) {
                if (currSlur[x] !== void 0) {
                  chordPos = x;
                  break;
                }
              }
              if (currSlur[chordPos] === void 0) {
                var offNum = chordPos * 100 + 1;
                parseCommon.each(obj.endSlur, function(x2) {
                  if (offNum === x2) --offNum;
                });
                currSlur[chordPos] = [offNum];
              }
            }
            var slurNum2;
            for (var i3 = 0; i3 < num; i3++) {
              slurNum2 = currSlur[chordPos].pop();
              obj.endSlur.push(slurNum2);
            }
            if (currSlur[chordPos].length === 0)
              delete currSlur[chordPos];
            return slurNum2;
          };
          var addStartSlur = function(obj, num, chordPos, usedNums2) {
            obj.startSlur = [];
            if (currSlur[chordPos] === void 0) {
              currSlur[chordPos] = [];
            }
            var nextNum = chordPos * 100 + 1;
            for (var i3 = 0; i3 < num; i3++) {
              if (usedNums2) {
                parseCommon.each(usedNums2, function(x2) {
                  if (nextNum === x2) ++nextNum;
                });
                parseCommon.each(usedNums2, function(x2) {
                  if (nextNum === x2) ++nextNum;
                });
                parseCommon.each(usedNums2, function(x2) {
                  if (nextNum === x2) ++nextNum;
                });
              }
              parseCommon.each(currSlur[chordPos], function(x2) {
                if (nextNum === x2) ++nextNum;
              });
              parseCommon.each(currSlur[chordPos], function(x2) {
                if (nextNum === x2) ++nextNum;
              });
              currSlur[chordPos].push(nextNum);
              obj.startSlur.push({ label: nextNum });
              nextNum++;
            }
          };
          for (var i2 = 0; i2 < line.length; i2++) {
            var el = line[i2];
            if (el.el_type === "note") {
              if (el.gracenotes) {
                for (var g = 0; g < el.gracenotes.length; g++) {
                  if (el.gracenotes[g].endSlur) {
                    var gg = el.gracenotes[g].endSlur;
                    el.gracenotes[g].endSlur = [];
                    for (var ggg = 0; ggg < gg; ggg++)
                      addEndSlur(el.gracenotes[g], 1, 20);
                  }
                  if (el.gracenotes[g].startSlur) {
                    x = el.gracenotes[g].startSlur;
                    addStartSlur(el.gracenotes[g], x, 20);
                  }
                }
              }
              if (el.endSlur) {
                x = el.endSlur;
                el.endSlur = [];
                addEndSlur(el, x, 0);
              }
              if (el.startSlur) {
                x = el.startSlur;
                addStartSlur(el, x, 0);
              }
              if (el.pitches) {
                var usedNums = [];
                for (var p = 0; p < el.pitches.length; p++) {
                  if (el.pitches[p].endSlur) {
                    var k = el.pitches[p].endSlur;
                    el.pitches[p].endSlur = [];
                    for (var j2 = 0; j2 < k; j2++) {
                      var slurNum = addEndSlur(el.pitches[p], 1, p + 1);
                      usedNums.push(slurNum);
                    }
                  }
                }
                for (p = 0; p < el.pitches.length; p++) {
                  if (el.pitches[p].startSlur) {
                    x = el.pitches[p].startSlur;
                    addStartSlur(el.pitches[p], x, p + 1, usedNums);
                  }
                }
                if (el.gracenotes && el.pitches[0].endSlur && el.pitches[0].endSlur[0] === 100 && el.pitches[0].startSlur) {
                  if (el.gracenotes[0].endSlur)
                    el.gracenotes[0].endSlur.push(el.pitches[0].startSlur[0].label);
                  else
                    el.gracenotes[0].endSlur = [el.pitches[0].startSlur[0].label];
                  if (el.pitches[0].endSlur.length === 1)
                    delete el.pitches[0].endSlur;
                  else if (el.pitches[0].endSlur[0] === 100)
                    el.pitches[0].endSlur.shift();
                  else if (el.pitches[0].endSlur[el.pitches[0].endSlur.length - 1] === 100)
                    el.pitches[0].endSlur.pop();
                  if (currSlur[1].length === 1)
                    delete currSlur[1];
                  else
                    currSlur[1].pop();
                }
              }
            }
          }
        }
        function fixClefPlacement(el) {
          parseKeyVoice.fixClef(el);
        }
        function wrapMusicLines(lines, barsperstaff2) {
          for (i = 0; i < lines.length; i++) {
            if (lines[i].staff !== void 0) {
              for (s = 0; s < lines[i].staff.length; s++) {
                var permanentItems = [];
                for (v = 0; v < lines[i].staff[s].voices.length; v++) {
                  var voice2 = lines[i].staff[s].voices[v];
                  var barNumThisLine = 0;
                  for (var n = 0; n < voice2.length; n++) {
                    if (voice2[n].el_type === "bar") {
                      barNumThisLine++;
                      if (barNumThisLine >= barsperstaff2) {
                        if (n < voice2.length - 1) {
                          var nextLine2 = getNextMusicLine(lines, i);
                          if (!nextLine2) {
                            var cp = JSON.parse(JSON.stringify(lines[i]));
                            lines.push(parseCommon.clone(cp));
                            nextLine2 = lines[lines.length - 1];
                            for (var ss = 0; ss < nextLine2.staff.length; ss++) {
                              for (var vv = 0; vv < nextLine2.staff[ss].voices.length; vv++)
                                nextLine2.staff[ss].voices[vv] = [];
                            }
                          }
                          var startElement = n + 1;
                          var section = lines[i].staff[s].voices[v].slice(startElement);
                          lines[i].staff[s].voices[v] = lines[i].staff[s].voices[v].slice(0, startElement);
                          nextLine2.staff[s].voices[v] = permanentItems.concat(section.concat(nextLine2.staff[s].voices[v]));
                          return true;
                        }
                      }
                    } else if (!voice2[n].duration) {
                      permanentItems.push(voice2[n]);
                    }
                  }
                }
              }
            }
          }
          return false;
        }
        function getNextMusicLine(lines, currentLine) {
          currentLine++;
          while (lines.length > currentLine) {
            if (lines[currentLine].staff)
              return lines[currentLine];
            currentLine++;
          }
          return null;
        }
        for (this.lineNum = 0; this.lineNum < this.lines.length; this.lineNum++) {
          var staff = this.lines[this.lineNum].staff;
          if (staff) {
            for (this.staffNum = 0; this.staffNum < staff.length; this.staffNum++) {
              if (staff[this.staffNum].clef)
                fixClefPlacement(staff[this.staffNum].clef);
              for (this.voiceNum = 0; this.voiceNum < staff[this.staffNum].voices.length; this.voiceNum++) {
                var voice = staff[this.staffNum].voices[this.voiceNum];
                cleanUpSlursInLine(voice);
                for (var j = 0; j < voice.length; j++) {
                  if (voice[j].el_type === "clef")
                    fixClefPlacement(voice[j]);
                }
                if (voice.length > 0 && voice[voice.length - 1].barNumber) {
                  var nextLine = getNextMusicLine(this.lines, this.lineNum);
                  if (nextLine)
                    nextLine.staff[0].barNumber = voice[voice.length - 1].barNumber;
                  delete voice[voice.length - 1].barNumber;
                }
              }
            }
          }
        }
        if (!this.formatting.pagewidth)
          this.formatting.pagewidth = defWidth;
        if (!this.formatting.pageheight)
          this.formatting.pageheight = defLength;
        delete this.staffNum;
        delete this.voiceNum;
        delete this.lineNum;
        delete this.potentialStartBeam;
        delete this.potentialEndBeam;
        delete this.vskipPending;
        return currSlur;
      };
      this.reset();
      this.getLastNote = function() {
        if (this.lines[this.lineNum] && this.lines[this.lineNum].staff && this.lines[this.lineNum].staff[this.staffNum] && this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum]) {
          for (var i = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum].length - 1; i >= 0; i--) {
            var el = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum][i];
            if (el.el_type === "note") {
              return el;
            }
          }
        }
        return null;
      };
      this.addTieToLastNote = function() {
        var el = this.getLastNote();
        if (el && el.pitches && el.pitches.length > 0) {
          el.pitches[0].startTie = {};
          return true;
        }
        return false;
      };
      this.getDuration = function(el) {
        if (el.duration) return el.duration;
        return 0;
      };
      this.closeLine = function() {
        if (this.potentialStartBeam && this.potentialEndBeam) {
          this.potentialStartBeam.startBeam = true;
          this.potentialEndBeam.endBeam = true;
        }
        delete this.potentialStartBeam;
        delete this.potentialEndBeam;
      };
      this.appendElement = function(type, startChar, endChar, hashParams) {
        var This = this;
        var pushNote = function(hp) {
          var currStaff = This.lines[This.lineNum].staff[This.staffNum];
          if (!currStaff) {
            return;
          }
          if (hp.pitches !== void 0) {
            var mid = currStaff.workingClef.verticalPos;
            parseCommon.each(hp.pitches, function(p) {
              p.verticalPos = p.pitch - mid;
            });
          }
          if (hp.gracenotes !== void 0) {
            var mid2 = currStaff.workingClef.verticalPos;
            parseCommon.each(hp.gracenotes, function(p) {
              p.verticalPos = p.pitch - mid2;
            });
          }
          currStaff.voices[This.voiceNum].push(hp);
        };
        hashParams.el_type = type;
        if (startChar !== null)
          hashParams.startChar = startChar;
        if (endChar !== null)
          hashParams.endChar = endChar;
        var endBeamHere = function() {
          This.potentialStartBeam.startBeam = true;
          hashParams.endBeam = true;
          delete This.potentialStartBeam;
          delete This.potentialEndBeam;
        };
        var endBeamLast = function() {
          if (This.potentialStartBeam !== void 0 && This.potentialEndBeam !== void 0) {
            This.potentialStartBeam.startBeam = true;
            This.potentialEndBeam.endBeam = true;
          }
          delete This.potentialStartBeam;
          delete This.potentialEndBeam;
        };
        if (type === "note") {
          var dur = This.getDuration(hashParams);
          if (dur >= 0.25) {
            endBeamLast();
          } else if (hashParams.force_end_beam_last && This.potentialStartBeam !== void 0) {
            endBeamLast();
          } else if (hashParams.end_beam && This.potentialStartBeam !== void 0) {
            if (hashParams.rest === void 0)
              endBeamHere();
            else
              endBeamLast();
          } else if (hashParams.rest === void 0) {
            if (This.potentialStartBeam === void 0) {
              if (!hashParams.end_beam) {
                This.potentialStartBeam = hashParams;
                delete This.potentialEndBeam;
              }
            } else {
              This.potentialEndBeam = hashParams;
            }
          }
        } else {
          endBeamLast();
        }
        delete hashParams.end_beam;
        delete hashParams.force_end_beam_last;
        pushNote(hashParams);
      };
      this.appendStartingElement = function(type, startChar, endChar, hashParams2) {
        this.closeLine();
        var impliedNaturals;
        if (type === "key") {
          impliedNaturals = hashParams2.impliedNaturals;
          delete hashParams2.impliedNaturals;
          delete hashParams2.explicitAccidentals;
        }
        var hashParams = parseCommon.clone(hashParams2);
        if (this.lines[this.lineNum].staff) {
          if (this.lines[this.lineNum].staff.length <= this.staffNum) {
            this.lines[this.lineNum].staff[this.staffNum] = {};
            this.lines[this.lineNum].staff[this.staffNum].clef = parseCommon.clone(this.lines[this.lineNum].staff[0].clef);
            this.lines[this.lineNum].staff[this.staffNum].key = parseCommon.clone(this.lines[this.lineNum].staff[0].key);
            if (this.lines[this.lineNum].staff[0].meter)
              this.lines[this.lineNum].staff[this.staffNum].meter = parseCommon.clone(this.lines[this.lineNum].staff[0].meter);
            this.lines[this.lineNum].staff[this.staffNum].workingClef = parseCommon.clone(this.lines[this.lineNum].staff[0].workingClef);
            this.lines[this.lineNum].staff[this.staffNum].voices = [[]];
          }
          if (type === "clef") {
            this.lines[this.lineNum].staff[this.staffNum].workingClef = hashParams;
          }
          var voice = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum];
          for (var i = 0; i < voice.length; i++) {
            if (voice[i].el_type === "note" || voice[i].el_type === "bar") {
              hashParams.el_type = type;
              hashParams.startChar = startChar;
              hashParams.endChar = endChar;
              if (impliedNaturals)
                hashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);
              voice.push(hashParams);
              return;
            }
            if (voice[i].el_type === type) {
              hashParams.el_type = type;
              hashParams.startChar = startChar;
              hashParams.endChar = endChar;
              if (impliedNaturals)
                hashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);
              voice[i] = hashParams;
              return;
            }
          }
          this.lines[this.lineNum].staff[this.staffNum][type] = hashParams2;
        }
      };
      this.getNumLines = function() {
        return this.lines.length;
      };
      this.pushLine = function(hash) {
        if (this.vskipPending) {
          hash.vskip = this.vskipPending;
          delete this.vskipPending;
        }
        this.lines.push(hash);
      };
      this.addSubtitle = function(str) {
        this.pushLine({ subtitle: str });
      };
      this.addSpacing = function(num) {
        this.vskipPending = num;
      };
      this.addNewPage = function(num) {
        this.pushLine({ newpage: num });
      };
      this.addSeparator = function(spaceAbove, spaceBelow, lineLength) {
        this.pushLine({ separator: { spaceAbove, spaceBelow, lineLength } });
      };
      this.addText = function(str) {
        this.pushLine({ text: str });
      };
      this.addCentered = function(str) {
        this.pushLine({ text: [{ text: str, center: true }] });
      };
      this.containsNotes = function(voice) {
        for (var i = 0; i < voice.length; i++) {
          if (voice[i].el_type === "note" || voice[i].el_type === "bar")
            return true;
        }
        return false;
      };
      this.containsNotesStrict = function(voice) {
        for (var i = 0; i < voice.length; i++) {
          if (voice[i].el_type === "note" && voice[i].rest === void 0)
            return true;
        }
        return false;
      };
      this.changeVoiceScale = function(scale) {
        var This = this;
        This.appendElement("scale", null, null, { size: scale });
      };
      this.startNewLine = function(params) {
        var This = this;
        this.closeLine();
        var createVoice = function(params2) {
          var thisStaff = This.lines[This.lineNum].staff[This.staffNum];
          thisStaff.voices[This.voiceNum] = [];
          if (!thisStaff.title)
            thisStaff.title = [];
          thisStaff.title[This.voiceNum] = { name: params2.name, subname: params2.subname };
          if (params2.style)
            This.appendElement("style", null, null, { head: params2.style });
          if (params2.stem)
            This.appendElement("stem", null, null, { direction: params2.stem });
          else if (This.voiceNum > 0) {
            if (thisStaff.voices[0] !== void 0) {
              var found = false;
              for (var i = 0; i < thisStaff.voices[0].length; i++) {
                if (thisStaff.voices[0].el_type === "stem")
                  found = true;
              }
              if (!found) {
                var stem = { el_type: "stem", direction: "up" };
                thisStaff.voices[0].splice(0, 0, stem);
              }
            }
            This.appendElement("stem", null, null, { direction: "down" });
          }
          if (params2.scale)
            This.appendElement("scale", null, null, { size: params2.scale });
        };
        var createStaff = function(params2) {
          if (params2.key && params2.key.impliedNaturals) {
            params2.key.accidentals = params2.key.accidentals.concat(params2.key.impliedNaturals);
            delete params2.key.impliedNaturals;
          }
          This.lines[This.lineNum].staff[This.staffNum] = { voices: [], clef: params2.clef, key: params2.key, workingClef: params2.clef };
          if (params2.stafflines !== void 0) {
            This.lines[This.lineNum].staff[This.staffNum].clef.stafflines = params2.stafflines;
            This.lines[This.lineNum].staff[This.staffNum].workingClef.stafflines = params2.stafflines;
          }
          if (params2.staffscale) {
            This.lines[This.lineNum].staff[This.staffNum].staffscale = params2.staffscale;
          }
          if (params2.tripletfont) This.lines[This.lineNum].staff[This.staffNum].tripletfont = params2.tripletfont;
          if (params2.vocalfont) This.lines[This.lineNum].staff[This.staffNum].vocalfont = params2.vocalfont;
          if (params2.bracket) This.lines[This.lineNum].staff[This.staffNum].bracket = params2.bracket;
          if (params2.brace) This.lines[This.lineNum].staff[This.staffNum].brace = params2.brace;
          if (params2.connectBarLines) This.lines[This.lineNum].staff[This.staffNum].connectBarLines = params2.connectBarLines;
          if (params2.barNumber) This.lines[This.lineNum].staff[This.staffNum].barNumber = params2.barNumber;
          createVoice(params2);
          if (params2.part)
            This.appendElement("part", params2.part.startChar, params2.part.endChar, { title: params2.part.title });
          if (params2.meter !== void 0) This.lines[This.lineNum].staff[This.staffNum].meter = params2.meter;
        };
        var createLine = function(params2) {
          This.lines[This.lineNum] = { staff: [] };
          createStaff(params2);
        };
        if (this.lines[this.lineNum] === void 0) createLine(params);
        else if (this.lines[this.lineNum].staff === void 0) {
          this.lineNum++;
          this.startNewLine(params);
        } else if (this.lines[this.lineNum].staff[this.staffNum] === void 0) createStaff(params);
        else if (this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum] === void 0) createVoice(params);
        else if (!this.containsNotes(this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum])) return;
        else {
          this.lineNum++;
          this.startNewLine(params);
        }
      };
      this.setBarNumberImmediate = function(barNumber) {
        var currentVoice = this.getCurrentVoice();
        if (currentVoice && currentVoice.length > 0) {
          var lastElement = currentVoice[currentVoice.length - 1];
          if (lastElement.el_type === "bar") {
            if (lastElement.barNumber !== void 0)
              lastElement.barNumber = barNumber;
          } else
            return barNumber - 1;
        }
        return barNumber;
      };
      this.hasBeginMusic = function() {
        for (var i = 0; i < this.lines.length; i++) {
          if (this.lines[i].staff)
            return true;
        }
        return false;
      };
      this.isFirstLine = function(index) {
        for (var i = index - 1; i >= 0; i--) {
          if (this.lines[i].staff !== void 0) return false;
        }
        return true;
      };
      this.getMeter = function() {
        for (var i = 0; i < this.lines.length; i++) {
          var line = this.lines[i];
          if (line.staff) {
            for (var j = 0; j < line.staff.length; j++) {
              var meter = line.staff[j].meter;
              if (meter) {
                return meter;
              }
            }
          }
        }
        return { type: "common_time" };
      };
      this.getMeterFraction = function() {
        var meter = this.getMeter();
        var num = 4;
        var den = 4;
        if (meter) {
          if (meter.type === "specified") {
            num = parseInt(meter.value[0].num, 10);
            den = parseInt(meter.value[0].den, 10);
          } else if (meter.type === "cut_time") {
            num = 2;
            den = 2;
          } else if (meter.type === "common_time") {
            num = 4;
            den = 4;
          }
        }
        this.meter = { num, den };
        return this.meter;
      };
      this.getKeySignature = function() {
        for (var i = 0; i < this.lines.length; i++) {
          var line = this.lines[i];
          if (line.staff) {
            for (var j = 0; j < line.staff.length; j++) {
              if (line.staff[j].key)
                return line.staff[j].key;
            }
          }
        }
        return {};
      };
      this.getCurrentVoice = function() {
        if (this.lines[this.lineNum] !== void 0 && this.lines[this.lineNum].staff[this.staffNum] !== void 0 && this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum] !== void 0)
          return this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum];
        else return null;
      };
      this.setCurrentVoice = function(staffNum, voiceNum) {
        this.staffNum = staffNum;
        this.voiceNum = voiceNum;
        for (var i = 0; i < this.lines.length; i++) {
          if (this.lines[i].staff) {
            if (this.lines[i].staff[staffNum] === void 0 || this.lines[i].staff[staffNum].voices[voiceNum] === void 0 || !this.containsNotes(this.lines[i].staff[staffNum].voices[voiceNum])) {
              this.lineNum = i;
              return;
            }
          }
        }
        this.lineNum = i;
      };
      this.addMetaText = function(key, value) {
        if (this.metaText[key] === void 0)
          this.metaText[key] = value;
        else
          this.metaText[key] += "\n" + value;
      };
      this.addMetaTextArray = function(key, value) {
        if (this.metaText[key] === void 0)
          this.metaText[key] = [value];
        else
          this.metaText[key].push(value);
      };
      this.addMetaTextObj = function(key, value) {
        this.metaText[key] = value;
      };
      function addVerticalInfo(timingEvents) {
        var lastBarTop;
        var lastBarBottom;
        var lastEventTop;
        var lastEventBottom;
        for (var e = timingEvents.length - 1; e >= 0; e--) {
          var ev = timingEvents[e];
          if (ev.type === "bar") {
            ev.top = lastEventTop;
            ev.nextTop = lastBarTop;
            lastBarTop = lastEventTop;
            ev.bottom = lastEventBottom;
            ev.nextBottom = lastBarBottom;
            lastBarBottom = lastEventBottom;
          } else if (ev.type === "event") {
            lastEventTop = ev.top;
            lastEventBottom = ev.top + ev.height;
          }
        }
      }
      function makeSortedArray(hash) {
        var arr = [];
        for (var k in hash) {
          if (hash.hasOwnProperty(k))
            arr.push(hash[k]);
        }
        arr = arr.sort(function(a, b) {
          var diff = a.milliseconds - b.milliseconds;
          if (diff !== 0) {
            return diff;
          } else {
            return a.type === "bar" ? -1 : 1;
          }
        });
        return arr;
      }
      this.addElementToEvents = function(eventHash, element, voiceTimeMilliseconds, top, height, line, measureNumber, timeDivider, isTiedState, nextIsBar) {
        if (element.hint)
          return { isTiedState: void 0, duration: 0 };
        var realDuration = element.durationClass ? element.durationClass : element.duration;
        if (element.abcelem.rest && element.abcelem.rest.type === "spacer")
          realDuration = 0;
        if (realDuration > 0) {
          var es = [];
          for (var i = 0; i < element.elemset.length; i++) {
            if (element.elemset[i] !== null)
              es.push(element.elemset[i]);
          }
          var isTiedToNext = element.startTie;
          if (isTiedState !== void 0) {
            eventHash["event" + isTiedState].elements.push(es);
            if (nextIsBar) {
              if (!eventHash["event" + voiceTimeMilliseconds]) {
                eventHash["event" + voiceTimeMilliseconds] = {
                  type: "event",
                  milliseconds: voiceTimeMilliseconds,
                  line,
                  measureNumber,
                  top,
                  height,
                  left: null,
                  width: 0,
                  elements: [],
                  startChar: null,
                  endChar: null,
                  startCharArray: [],
                  endCharArray: []
                };
              }
              eventHash["event" + voiceTimeMilliseconds].measureStart = true;
              nextIsBar = false;
            }
            if (!isTiedToNext)
              isTiedState = void 0;
          } else {
            if (!eventHash["event" + voiceTimeMilliseconds]) {
              eventHash["event" + voiceTimeMilliseconds] = {
                type: "event",
                milliseconds: voiceTimeMilliseconds,
                line,
                measureNumber,
                top,
                height,
                left: element.x,
                width: element.w,
                elements: [es],
                startChar: element.abcelem.startChar,
                endChar: element.abcelem.endChar,
                startCharArray: [element.abcelem.startChar],
                endCharArray: [element.abcelem.endChar],
                midiPitches: element.abcelem.midiPitches ? parseCommon.cloneArray(element.abcelem.midiPitches) : []
              };
              if (element.abcelem.midiGraceNotePitches)
                eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches = parseCommon.cloneArray(element.abcelem.midiGraceNotePitches);
            } else {
              if (eventHash["event" + voiceTimeMilliseconds].left)
                eventHash["event" + voiceTimeMilliseconds].left = Math.min(eventHash["event" + voiceTimeMilliseconds].left, element.x);
              else
                eventHash["event" + voiceTimeMilliseconds].left = element.x;
              eventHash["event" + voiceTimeMilliseconds].elements.push(es);
              eventHash["event" + voiceTimeMilliseconds].startCharArray.push(element.abcelem.startChar);
              eventHash["event" + voiceTimeMilliseconds].endCharArray.push(element.abcelem.endChar);
              if (eventHash["event" + voiceTimeMilliseconds].startChar === null)
                eventHash["event" + voiceTimeMilliseconds].startChar = element.abcelem.startChar;
              if (eventHash["event" + voiceTimeMilliseconds].endChar === null)
                eventHash["event" + voiceTimeMilliseconds].endChar = element.abcelem.endChar;
              if (element.abcelem.midiPitches && element.abcelem.midiPitches.length) {
                if (!eventHash["event" + voiceTimeMilliseconds].midiPitches)
                  eventHash["event" + voiceTimeMilliseconds].midiPitches = [];
                for (var i = 0; i < element.abcelem.midiPitches.length; i++)
                  eventHash["event" + voiceTimeMilliseconds].midiPitches.push(element.abcelem.midiPitches[i]);
              }
              if (element.abcelem.midiGraceNotePitches && element.abcelem.midiGraceNotePitches.length) {
                if (!eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches)
                  eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches = [];
                for (var j = 0; j < element.abcelem.midiGraceNotePitches.length; j++)
                  eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches.push(element.abcelem.midiGraceNotePitches[j]);
              }
            }
            if (nextIsBar) {
              eventHash["event" + voiceTimeMilliseconds].measureStart = true;
              nextIsBar = false;
            }
            if (isTiedToNext)
              isTiedState = voiceTimeMilliseconds;
          }
        }
        return { isTiedState, duration: realDuration / timeDivider, nextIsBar: nextIsBar || element.type === "bar" };
      };
      this.makeVoicesArray = function() {
        var voicesArr = [];
        for (var line = 0; line < this.engraver.staffgroups.length; line++) {
          var group = this.engraver.staffgroups[line];
          var firstStaff = group.staffs[0];
          var middleC = firstStaff.absoluteY;
          var top = middleC - firstStaff.top * spacing.STEP;
          var lastStaff = group.staffs[group.staffs.length - 1];
          middleC = lastStaff.absoluteY;
          var bottom = middleC - lastStaff.bottom * spacing.STEP;
          var height = bottom - top;
          var voices = group.voices;
          for (var v = 0; v < voices.length; v++) {
            var measureNumber = 0;
            var noteFound = false;
            if (!voicesArr[v])
              voicesArr[v] = [];
            var elements = voices[v].children;
            for (var elem = 0; elem < elements.length; elem++) {
              voicesArr[v].push({ top, height, line, measureNumber, elem: elements[elem] });
              if (elements[elem].type === "bar" && noteFound)
                measureNumber++;
              if (elements[elem].type === "note" || elements[elem].type === "rest")
                noteFound = true;
            }
          }
        }
        return voicesArr;
      };
      this.setupEvents = function(startingDelay, timeDivider, bpm) {
        var timingEvents = [];
        var eventHash = {};
        var time = startingDelay;
        var isTiedState;
        var nextIsBar = true;
        var voices = this.makeVoicesArray();
        for (var v = 0; v < voices.length; v++) {
          var voiceTime = time;
          var voiceTimeMilliseconds = Math.round(voiceTime * 1e3);
          var startingRepeatElem = 0;
          var endingRepeatElem = -1;
          var elements = voices[v];
          for (var elem = 0; elem < elements.length; elem++) {
            var element = elements[elem].elem;
            if (element.abcelem.el_type === "tempo") {
              var bpm = this.getBpm(element.abcelem);
              var beatLength = this.getBeatLength();
              var beatsPerSecond = bpm / 60;
              timeDivider = beatLength * beatsPerSecond;
            }
            var ret = this.addElementToEvents(eventHash, element, voiceTimeMilliseconds, elements[elem].top, elements[elem].height, elements[elem].line, elements[elem].measureNumber, timeDivider, isTiedState, nextIsBar);
            isTiedState = ret.isTiedState;
            nextIsBar = ret.nextIsBar;
            voiceTime += ret.duration;
            voiceTimeMilliseconds = Math.round(voiceTime * 1e3);
            if (element.type === "bar") {
              var barType = element.abcelem.type;
              var endRepeat = barType === "bar_right_repeat" || barType === "bar_dbl_repeat";
              var startEnding = element.abcelem.startEnding === "1";
              var startRepeat = barType === "bar_left_repeat" || barType === "bar_dbl_repeat" || barType === "bar_right_repeat";
              if (endRepeat) {
                if (endingRepeatElem === -1)
                  endingRepeatElem = elem;
                for (var el2 = startingRepeatElem; el2 < endingRepeatElem; el2++) {
                  var element2 = elements[el2].elem;
                  ret = this.addElementToEvents(eventHash, element2, voiceTimeMilliseconds, elements[el2].top, elements[el2].height, elements[el2].line, elements[el2].measureNumber, timeDivider, isTiedState, nextIsBar);
                  isTiedState = ret.isTiedState;
                  nextIsBar = ret.nextIsBar;
                  voiceTime += ret.duration;
                  voiceTimeMilliseconds = Math.round(voiceTime * 1e3);
                }
                nextIsBar = true;
                endingRepeatElem = -1;
              }
              if (startEnding)
                endingRepeatElem = elem;
              if (startRepeat)
                startingRepeatElem = elem;
            }
          }
        }
        timingEvents = makeSortedArray(eventHash);
        addVerticalInfo(timingEvents);
        timingEvents.push({ type: "end", milliseconds: voiceTimeMilliseconds });
        this.addUsefulCallbackInfo(timingEvents, bpm);
        return timingEvents;
      };
      this.addUsefulCallbackInfo = function(timingEvents, bpm) {
        var millisecondsPerMeasure = this.millisecondsPerMeasure(bpm);
        for (var i = 0; i < timingEvents.length; i++) {
          var ev = timingEvents[i];
          ev.millisecondsPerMeasure = millisecondsPerMeasure;
        }
      };
      function getVertical(group) {
        var voices = group.voices;
        var firstStaff = group.staffs[0];
        var middleC = firstStaff.absoluteY;
        var top = middleC - firstStaff.top * spacing.STEP;
        var lastStaff = group.staffs[group.staffs.length - 1];
        middleC = lastStaff.absoluteY;
        var bottom = middleC - lastStaff.bottom * spacing.STEP;
        var height = bottom - top;
        return { top, height };
      }
      this.getBpm = function(tempo) {
        var bpm;
        if (tempo) {
          bpm = tempo.bpm;
          var beatLength = this.getBeatLength();
          var statedBeatLength = tempo.duration && tempo.duration.length > 0 ? tempo.duration[0] : beatLength;
          bpm = bpm * statedBeatLength / beatLength;
        }
        if (!bpm) {
          bpm = 180;
          var meter = this.getMeterFraction();
          if (meter && meter.den === 8) {
            bpm = 120;
          }
        }
        return bpm;
      };
      this.setTiming = function(bpm, measuresOfDelay) {
        if (!bpm) {
          var tempo = this.metaText ? this.metaText.tempo : null;
          bpm = this.getBpm(tempo);
        }
        var beatLength = this.getBeatLength();
        var beatsPerSecond = bpm / 60;
        var measureLength = this.getBarLength();
        var startingDelay = measureLength / beatLength * measuresOfDelay / beatsPerSecond;
        if (startingDelay)
          startingDelay -= this.getPickupLength() / beatLength / beatsPerSecond;
        var timeDivider = beatLength * beatsPerSecond;
        this.noteTimings = this.setupEvents(startingDelay, timeDivider, bpm);
      };
    };
    module.exports = Tune;
  }
});

// node_modules/abcjs/src/parse/abc_parse.js
var require_abc_parse = __commonJS({
  "node_modules/abcjs/src/parse/abc_parse.js"(exports, module) {
    var parseCommon = require_abc_common();
    var parseDirective = require_abc_parse_directive();
    var ParseHeader = require_abc_parse_header();
    var parseKeyVoice = require_abc_parse_key_voice();
    var Tokenizer = require_abc_tokenizer();
    var transpose = require_abc_transpose();
    var wrap = require_wrap_lines();
    var Tune = require_abc_tune();
    var Parse = function() {
      "use strict";
      var tune = new Tune();
      var tokenizer = new Tokenizer();
      this.getTune = function() {
        return {
          formatting: tune.formatting,
          lines: tune.lines,
          media: tune.media,
          metaText: tune.metaText,
          version: tune.version,
          addElementToEvents: tune.addElementToEvents,
          addUsefulCallbackInfo: tune.addUsefulCallbackInfo,
          getBarLength: tune.getBarLength,
          getBeatLength: tune.getBeatLength,
          getBeatsPerMeasure: tune.getBeatsPerMeasure,
          getBpm: tune.getBpm,
          getMeter: tune.getMeter,
          getMeterFraction: tune.getMeterFraction,
          getPickupLength: tune.getPickupLength,
          getKeySignature: tune.getKeySignature,
          makeVoicesArray: tune.makeVoicesArray,
          millisecondsPerMeasure: tune.millisecondsPerMeasure,
          setupEvents: tune.setupEvents,
          setTiming: tune.setTiming
        };
      };
      function addPositioning(el, type, value) {
        if (!el.positioning) el.positioning = {};
        el.positioning[type] = value;
      }
      function addFont(el, type, value) {
        if (!el.fonts) el.fonts = {};
        el.fonts[type] = value;
      }
      var multilineVars = {
        reset: function() {
          for (var property in this) {
            if (this.hasOwnProperty(property) && typeof this[property] !== "function") {
              delete this[property];
            }
          }
          this.iChar = 0;
          this.key = { accidentals: [], root: "none", acc: "", mode: "" };
          this.meter = null;
          this.origMeter = null;
          this.hasMainTitle = false;
          this.default_length = 0.125;
          this.clef = { type: "treble", verticalPos: 0 };
          this.next_note_duration = 0;
          this.start_new_line = true;
          this.is_in_header = true;
          this.is_in_history = false;
          this.partForNextLine = {};
          this.havent_set_length = true;
          this.voices = {};
          this.staves = [];
          this.macros = {};
          this.currBarNumber = 1;
          this.barCounter = {};
          this.inTextBlock = false;
          this.inPsBlock = false;
          this.ignoredDecorations = [];
          this.textBlock = "";
          this.score_is_present = false;
          this.inEnding = false;
          this.inTie = [];
          this.inTieChord = {};
          this.vocalPosition = "auto";
          this.dynamicPosition = "auto";
          this.chordPosition = "auto";
          this.ornamentPosition = "auto";
          this.volumePosition = "auto";
          this.openSlurs = [];
          this.freegchord = false;
        },
        differentFont: function(type, defaultFonts) {
          if (this[type].decoration !== defaultFonts[type].decoration) return true;
          if (this[type].face !== defaultFonts[type].face) return true;
          if (this[type].size !== defaultFonts[type].size) return true;
          if (this[type].style !== defaultFonts[type].style) return true;
          if (this[type].weight !== defaultFonts[type].weight) return true;
          return false;
        },
        addFormattingOptions: function(el, defaultFonts, elType) {
          if (elType === "note") {
            if (this.vocalPosition !== "auto") addPositioning(el, "vocalPosition", this.vocalPosition);
            if (this.dynamicPosition !== "auto") addPositioning(el, "dynamicPosition", this.dynamicPosition);
            if (this.chordPosition !== "auto") addPositioning(el, "chordPosition", this.chordPosition);
            if (this.ornamentPosition !== "auto") addPositioning(el, "ornamentPosition", this.ornamentPosition);
            if (this.volumePosition !== "auto") addPositioning(el, "volumePosition", this.volumePosition);
            if (this.differentFont("annotationfont", defaultFonts)) addFont(el, "annotationfont", this.annotationfont);
            if (this.differentFont("gchordfont", defaultFonts)) addFont(el, "gchordfont", this.gchordfont);
            if (this.differentFont("vocalfont", defaultFonts)) addFont(el, "vocalfont", this.vocalfont);
            if (this.differentFont("tripletfont", defaultFonts)) addFont(el, "tripletfont", this.tripletfont);
          } else if (elType === "bar") {
            if (this.dynamicPosition !== "auto") addPositioning(el, "dynamicPosition", this.dynamicPosition);
            if (this.chordPosition !== "auto") addPositioning(el, "chordPosition", this.chordPosition);
            if (this.ornamentPosition !== "auto") addPositioning(el, "ornamentPosition", this.ornamentPosition);
            if (this.volumePosition !== "auto") addPositioning(el, "volumePosition", this.volumePosition);
            if (this.differentFont("measurefont", defaultFonts)) addFont(el, "measurefont", this.measurefont);
            if (this.differentFont("repeatfont", defaultFonts)) addFont(el, "repeatfont", this.repeatfont);
          }
        }
      };
      var addWarning = function(str) {
        if (!multilineVars.warnings)
          multilineVars.warnings = [];
        multilineVars.warnings.push(str);
      };
      var addWarningObject = function(warningObject) {
        if (!multilineVars.warningObjects)
          multilineVars.warningObjects = [];
        multilineVars.warningObjects.push(warningObject);
      };
      var encode = function(str) {
        var ret = parseCommon.gsub(str, "", " ");
        ret = parseCommon.gsub(ret, "&", "&amp;");
        ret = parseCommon.gsub(ret, "<", "&lt;");
        return parseCommon.gsub(ret, ">", "&gt;");
      };
      var warn = function(str, line, col_num) {
        if (!line) line = " ";
        var bad_char = line.charAt(col_num);
        if (bad_char === " ")
          bad_char = "SPACE";
        var clean_line = encode(line.substring(0, col_num)) + '<span style="text-decoration:underline;font-size:1.3em;font-weight:bold;">' + bad_char + "</span>" + encode(line.substring(col_num + 1));
        addWarning("Music Line:" + tune.getNumLines() + ":" + (col_num + 1) + ": " + str + ":  " + clean_line);
        addWarningObject({ message: str, line, startChar: multilineVars.iChar + col_num, column: col_num });
      };
      var header = new ParseHeader(tokenizer, warn, multilineVars, tune);
      this.getWarnings = function() {
        return multilineVars.warnings;
      };
      this.getWarningObjects = function() {
        return multilineVars.warningObjects;
      };
      var letter_to_chord = function(line, i) {
        if (line.charAt(i) === '"') {
          var chord = tokenizer.getBrackettedSubstring(line, i, 5);
          if (!chord[2])
            warn("Missing the closing quote while parsing the chord symbol", line, i);
          if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === "^") {
            chord[1] = chord[1].substring(1);
            chord[2] = "above";
          } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === "_") {
            chord[1] = chord[1].substring(1);
            chord[2] = "below";
          } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === "<") {
            chord[1] = chord[1].substring(1);
            chord[2] = "left";
          } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === ">") {
            chord[1] = chord[1].substring(1);
            chord[2] = "right";
          } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === "@") {
            chord[1] = chord[1].substring(1);
            var x = tokenizer.getFloat(chord[1]);
            if (x.digits === 0)
              warn("Missing first position in absolutely positioned annotation.", line, i);
            chord[1] = chord[1].substring(x.digits);
            if (chord[1][0] !== ",")
              warn("Missing comma absolutely positioned annotation.", line, i);
            chord[1] = chord[1].substring(1);
            var y = tokenizer.getFloat(chord[1]);
            if (y.digits === 0)
              warn("Missing second position in absolutely positioned annotation.", line, i);
            chord[1] = chord[1].substring(y.digits);
            var ws = tokenizer.skipWhiteSpace(chord[1]);
            chord[1] = chord[1].substring(ws);
            chord[2] = null;
            chord[3] = { x: x.value, y: y.value };
          } else {
            if (multilineVars.freegchord !== true) {
              chord[1] = chord[1].replace(/([ABCDEFG0-9])b/g, "$1");
              chord[1] = chord[1].replace(/([ABCDEFG0-9])#/g, "$1");
            }
            chord[2] = "default";
            chord[1] = transpose.chordName(multilineVars, chord[1]);
          }
          return chord;
        }
        return [0, ""];
      };
      var legalAccents = [
        "trill",
        "lowermordent",
        "uppermordent",
        "mordent",
        "pralltriller",
        "accent",
        "fermata",
        "invertedfermata",
        "tenuto",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "+",
        "wedge",
        "open",
        "thumb",
        "snap",
        "turn",
        "roll",
        "breath",
        "shortphrase",
        "mediumphrase",
        "longphrase",
        "segno",
        "coda",
        "D.S.",
        "D.C.",
        "fine",
        "slide",
        "^",
        "marcato",
        "upbow",
        "downbow",
        "/",
        "//",
        "///",
        "////",
        "trem1",
        "trem2",
        "trem3",
        "trem4",
        "turnx",
        "invertedturn",
        "invertedturnx",
        "trill(",
        "trill)",
        "arpeggio",
        "xstem",
        "mark",
        "umarcato",
        "style=normal",
        "style=harmonic",
        "style=rhythm",
        "style=x"
      ];
      var volumeDecorations = ["p", "pp", "f", "ff", "mf", "mp", "ppp", "pppp", "fff", "ffff", "sfz"];
      var dynamicDecorations = ["crescendo(", "crescendo)", "diminuendo(", "diminuendo)"];
      var accentPseudonyms = [
        ["<", "accent"],
        [">", "accent"],
        ["tr", "trill"],
        ["plus", "+"],
        ["emphasis", "accent"],
        ["^", "umarcato"],
        ["marcato", "umarcato"]
      ];
      var accentDynamicPseudonyms = [
        ["<(", "crescendo("],
        ["<)", "crescendo)"],
        [">(", "diminuendo("],
        [">)", "diminuendo)"]
      ];
      var letter_to_accent = function(line, i) {
        var macro = multilineVars.macros[line.charAt(i)];
        if (macro !== void 0) {
          if (macro.charAt(0) === "!" || macro.charAt(0) === "+")
            macro = macro.substring(1);
          if (macro.charAt(macro.length - 1) === "!" || macro.charAt(macro.length - 1) === "+")
            macro = macro.substring(0, macro.length - 1);
          if (parseCommon.detect(legalAccents, function(acc) {
            return macro === acc;
          }))
            return [1, macro];
          else if (parseCommon.detect(volumeDecorations, function(acc) {
            return macro === acc;
          })) {
            if (multilineVars.volumePosition === "hidden")
              macro = "";
            return [1, macro];
          } else if (parseCommon.detect(dynamicDecorations, function(acc) {
            if (multilineVars.dynamicPosition === "hidden")
              macro = "";
            return macro === acc;
          })) {
            return [1, macro];
          } else {
            if (!parseCommon.detect(multilineVars.ignoredDecorations, function(dec) {
              return macro === dec;
            }))
              warn("Unknown macro: " + macro, line, i);
            return [1, ""];
          }
        }
        switch (line.charAt(i)) {
          case ".":
            return [1, "staccato"];
          case "u":
            return [1, "upbow"];
          case "v":
            return [1, "downbow"];
          case "~":
            return [1, "irishroll"];
          case "!":
          case "+":
            var ret = tokenizer.getBrackettedSubstring(line, i, 5);
            if (ret[1].length > 0 && (ret[1].charAt(0) === "^" || ret[1].charAt(0) === "_"))
              ret[1] = ret[1].substring(1);
            if (parseCommon.detect(legalAccents, function(acc) {
              return ret[1] === acc;
            }))
              return ret;
            if (parseCommon.detect(volumeDecorations, function(acc) {
              return ret[1] === acc;
            })) {
              if (multilineVars.volumePosition === "hidden")
                ret[1] = "";
              return ret;
            }
            if (parseCommon.detect(dynamicDecorations, function(acc) {
              return ret[1] === acc;
            })) {
              if (multilineVars.dynamicPosition === "hidden")
                ret[1] = "";
              return ret;
            }
            if (parseCommon.detect(accentPseudonyms, function(acc) {
              if (ret[1] === acc[0]) {
                ret[1] = acc[1];
                return true;
              } else
                return false;
            }))
              return ret;
            if (parseCommon.detect(accentDynamicPseudonyms, function(acc) {
              if (ret[1] === acc[0]) {
                ret[1] = acc[1];
                return true;
              } else
                return false;
            })) {
              if (multilineVars.dynamicPosition === "hidden")
                ret[1] = "";
              return ret;
            }
            if (line.charAt(i) === "!" && (ret[0] === 1 || line.charAt(i + ret[0] - 1) !== "!"))
              return [1, null];
            warn("Unknown decoration: " + ret[1], line, i);
            ret[1] = "";
            return ret;
          case "H":
            return [1, "fermata"];
          case "J":
            return [1, "slide"];
          case "L":
            return [1, "accent"];
          case "M":
            return [1, "mordent"];
          case "O":
            return [1, "coda"];
          case "P":
            return [1, "pralltriller"];
          case "R":
            return [1, "roll"];
          case "S":
            return [1, "segno"];
          case "T":
            return [1, "trill"];
        }
        return [0, 0];
      };
      var letter_to_spacer = function(line, i) {
        var start = i;
        while (tokenizer.isWhiteSpace(line.charAt(i)))
          i++;
        return [i - start];
      };
      var letter_to_bar = function(line, curr_pos) {
        var ret = tokenizer.getBarLine(line, curr_pos);
        if (ret.len === 0)
          return [0, ""];
        if (ret.warn) {
          warn(ret.warn, line, curr_pos);
          return [ret.len, ""];
        }
        for (var ws = 0; ws < line.length; ws++)
          if (line.charAt(curr_pos + ret.len + ws) !== " ")
            break;
        var orig_bar_len = ret.len;
        if (line.charAt(curr_pos + ret.len + ws) === "[") {
          ret.len += ws + 1;
        }
        if (line.charAt(curr_pos + ret.len) === '"' && line.charAt(curr_pos + ret.len - 1) === "[") {
          var ending = tokenizer.getBrackettedSubstring(line, curr_pos + ret.len, 5);
          return [ret.len + ending[0], ret.token, ending[1]];
        }
        var retRep = tokenizer.getTokenOf(line.substring(curr_pos + ret.len), "1234567890-,");
        if (retRep.len === 0 || retRep.token[0] === "-")
          return [orig_bar_len, ret.token];
        return [ret.len + retRep.len, ret.token, retRep.token];
      };
      var tripletQ = {
        2: 3,
        3: 2,
        4: 3,
        5: 2,
        // TODO-PER: not handling 6/8 rhythm yet
        6: 2,
        7: 2,
        // TODO-PER: not handling 6/8 rhythm yet
        8: 3,
        9: 2
        // TODO-PER: not handling 6/8 rhythm yet
      };
      var letter_to_open_slurs_and_triplets = function(line, i) {
        var ret = {};
        var start = i;
        while (line.charAt(i) === "(" || tokenizer.isWhiteSpace(line.charAt(i))) {
          if (line.charAt(i) === "(") {
            if (i + 1 < line.length && (line.charAt(i + 1) >= "2" && line.charAt(i + 1) <= "9")) {
              if (ret.triplet !== void 0)
                warn("Can't nest triplets", line, i);
              else {
                ret.triplet = line.charAt(i + 1) - "0";
                ret.tripletQ = tripletQ[ret.triplet];
                ret.num_notes = ret.triplet;
                if (i + 2 < line.length && line.charAt(i + 2) === ":") {
                  if (i + 3 < line.length && line.charAt(i + 3) === ":") {
                    if (i + 4 < line.length && (line.charAt(i + 4) >= "1" && line.charAt(i + 4) <= "9")) {
                      ret.num_notes = line.charAt(i + 4) - "0";
                      i += 3;
                    } else
                      warn("expected number after the two colons after the triplet to mark the duration", line, i);
                  } else if (i + 3 < line.length && (line.charAt(i + 3) >= "1" && line.charAt(i + 3) <= "9")) {
                    ret.tripletQ = line.charAt(i + 3) - "0";
                    if (i + 4 < line.length && line.charAt(i + 4) === ":") {
                      if (i + 5 < line.length && (line.charAt(i + 5) >= "1" && line.charAt(i + 5) <= "9")) {
                        ret.num_notes = line.charAt(i + 5) - "0";
                        i += 4;
                      }
                    } else {
                      i += 2;
                    }
                  } else
                    warn("expected number after the triplet to mark the duration", line, i);
                }
              }
              i++;
            } else {
              if (ret.startSlur === void 0)
                ret.startSlur = 1;
              else
                ret.startSlur++;
            }
          }
          i++;
        }
        ret.consumed = i - start;
        return ret;
      };
      var addWords = function(line, words) {
        if (!line) {
          warn("Can't add words before the first line of music", line, 0);
          return;
        }
        words = parseCommon.strip(words);
        if (words.charAt(words.length - 1) !== "-")
          words = words + " ";
        var word_list = [];
        var last_divider = 0;
        var replace = false;
        var addWord = function(i2) {
          var word = parseCommon.strip(words.substring(last_divider, i2));
          last_divider = i2 + 1;
          if (word.length > 0) {
            if (replace)
              word = parseCommon.gsub(word, "~", " ");
            var div = words.charAt(i2);
            if (div !== "_" && div !== "-")
              div = " ";
            word_list.push({ syllable: tokenizer.translateString(word), divider: div });
            replace = false;
            return true;
          }
          return false;
        };
        for (var i = 0; i < words.length; i++) {
          switch (words.charAt(i)) {
            case " ":
            case "":
              addWord(i);
              break;
            case "-":
              if (!addWord(i) && word_list.length > 0) {
                parseCommon.last(word_list).divider = "-";
                word_list.push({ skip: true, to: "next" });
              }
              break;
            case "_":
              addWord(i);
              word_list.push({ skip: true, to: "slur" });
              break;
            case "*":
              addWord(i);
              word_list.push({ skip: true, to: "next" });
              break;
            case "|":
              addWord(i);
              word_list.push({ skip: true, to: "bar" });
              break;
            case "~":
              replace = true;
              break;
          }
        }
        var inSlur = false;
        parseCommon.each(line, function(el) {
          if (word_list.length !== 0) {
            if (word_list[0].skip) {
              switch (word_list[0].to) {
                case "next":
                  if (el.el_type === "note" && el.pitches !== null && !inSlur) word_list.shift();
                  break;
                case "slur":
                  if (el.el_type === "note" && el.pitches !== null) word_list.shift();
                  break;
                case "bar":
                  if (el.el_type === "bar") word_list.shift();
                  break;
              }
              if (el.el_type !== "bar") {
                if (el.lyric === void 0)
                  el.lyric = [{ syllable: "", divider: " " }];
                else
                  el.lyric.push({ syllable: "", divider: " " });
              }
            } else {
              if (el.el_type === "note" && el.rest === void 0 && !inSlur) {
                var lyric = word_list.shift();
                if (lyric.syllable)
                  lyric.syllable = lyric.syllable.replace(/ +/g, "");
                if (el.lyric === void 0)
                  el.lyric = [lyric];
                else
                  el.lyric.push(lyric);
              }
            }
          }
        });
      };
      var addSymbols = function(line, words) {
        if (!line) {
          warn("Can't add symbols before the first line of music", line, 0);
          return;
        }
        words = parseCommon.strip(words);
        if (words.charAt(words.length - 1) !== "-")
          words = words + " ";
        var word_list = [];
        var last_divider = 0;
        var replace = false;
        var addWord = function(i2) {
          var word = parseCommon.strip(words.substring(last_divider, i2));
          last_divider = i2 + 1;
          if (word.length > 0) {
            if (replace)
              word = parseCommon.gsub(word, "~", " ");
            var div = words.charAt(i2);
            if (div !== "_" && div !== "-")
              div = " ";
            word_list.push({ syllable: tokenizer.translateString(word), divider: div });
            replace = false;
            return true;
          }
          return false;
        };
        for (var i = 0; i < words.length; i++) {
          switch (words.charAt(i)) {
            case " ":
            case "":
              addWord(i);
              break;
            case "-":
              if (!addWord(i) && word_list.length > 0) {
                parseCommon.last(word_list).divider = "-";
                word_list.push({ skip: true, to: "next" });
              }
              break;
            case "_":
              addWord(i);
              word_list.push({ skip: true, to: "slur" });
              break;
            case "*":
              addWord(i);
              word_list.push({ skip: true, to: "next" });
              break;
            case "|":
              addWord(i);
              word_list.push({ skip: true, to: "bar" });
              break;
            case "~":
              replace = true;
              break;
          }
        }
        var inSlur = false;
        parseCommon.each(line, function(el) {
          if (word_list.length !== 0) {
            if (word_list[0].skip) {
              switch (word_list[0].to) {
                case "next":
                  if (el.el_type === "note" && el.pitches !== null && !inSlur) word_list.shift();
                  break;
                case "slur":
                  if (el.el_type === "note" && el.pitches !== null) word_list.shift();
                  break;
                case "bar":
                  if (el.el_type === "bar") word_list.shift();
                  break;
              }
            } else {
              if (el.el_type === "note" && el.rest === void 0 && !inSlur) {
                var lyric = word_list.shift();
                if (el.lyric === void 0)
                  el.lyric = [lyric];
                else
                  el.lyric.push(lyric);
              }
            }
          }
        });
      };
      var getBrokenRhythm = function(line, index) {
        switch (line.charAt(index)) {
          case ">":
            if (index < line.length - 1 && line.charAt(index + 1) === ">")
              return [2, 1.75, 0.25];
            else
              return [1, 1.5, 0.5];
            break;
          case "<":
            if (index < line.length - 1 && line.charAt(index + 1) === "<")
              return [2, 0.25, 1.75];
            else
              return [1, 0.5, 1.5];
            break;
        }
        return null;
      };
      var addEndBeam = function(el) {
        if (el.duration !== void 0 && el.duration < 0.25)
          el.end_beam = true;
        return el;
      };
      var pitches = { A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11 };
      var rests = { x: "invisible", y: "spacer", z: "rest", Z: "multimeasure" };
      var getCoreNote = function(line, index, el, canHaveBrokenRhythm) {
        var isComplete = function(state2) {
          return state2 === "octave" || state2 === "duration" || state2 === "Zduration" || state2 === "broken_rhythm" || state2 === "end_slur";
        };
        var state = "startSlur";
        var durationSetByPreviousNote = false;
        while (1) {
          switch (line.charAt(index)) {
            case "(":
              if (state === "startSlur") {
                if (el.startSlur === void 0) el.startSlur = 1;
                else el.startSlur++;
              } else if (isComplete(state)) {
                el.endChar = index;
                return el;
              } else return null;
              break;
            case ")":
              if (isComplete(state)) {
                if (el.endSlur === void 0) el.endSlur = 1;
                else el.endSlur++;
              } else return null;
              break;
            case "^":
              if (state === "startSlur") {
                el.accidental = "sharp";
                state = "sharp2";
              } else if (state === "sharp2") {
                el.accidental = "dblsharp";
                state = "pitch";
              } else if (isComplete(state)) {
                el.endChar = index;
                return el;
              } else return null;
              break;
            case "_":
              if (state === "startSlur") {
                el.accidental = "flat";
                state = "flat2";
              } else if (state === "flat2") {
                el.accidental = "dblflat";
                state = "pitch";
              } else if (isComplete(state)) {
                el.endChar = index;
                return el;
              } else return null;
              break;
            case "=":
              if (state === "startSlur") {
                el.accidental = "natural";
                state = "pitch";
              } else if (isComplete(state)) {
                el.endChar = index;
                return el;
              } else return null;
              break;
            case "A":
            case "B":
            case "C":
            case "D":
            case "E":
            case "F":
            case "G":
            case "a":
            case "b":
            case "c":
            case "d":
            case "e":
            case "f":
            case "g":
              if (state === "startSlur" || state === "sharp2" || state === "flat2" || state === "pitch") {
                el.pitch = pitches[line.charAt(index)];
                transpose.note(multilineVars, el);
                state = "octave";
                if (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {
                  el.duration = multilineVars.default_length * multilineVars.next_note_duration;
                  multilineVars.next_note_duration = 0;
                  durationSetByPreviousNote = true;
                } else
                  el.duration = multilineVars.default_length;
                if (multilineVars.clef && multilineVars.clef.type === "perc" || multilineVars.currentVoice && multilineVars.currentVoice.clef === "perc") {
                  var key = line.charAt(index);
                  if (el.accidental) {
                    var accMap = { "dblflat": "__", "flat": "_", "natural": "=", "sharp": "^", "dblsharp": "^^" };
                    key = accMap[el.accidental] + key;
                  }
                  if (tune.formatting && tune.formatting.midi && tune.formatting.midi.drummap)
                    el.midipitch = tune.formatting.midi.drummap[key];
                }
              } else if (isComplete(state)) {
                el.endChar = index;
                return el;
              } else return null;
              break;
            case ",":
              if (state === "octave") {
                el.pitch -= 7;
              } else if (isComplete(state)) {
                el.endChar = index;
                return el;
              } else return null;
              break;
            case "'":
              if (state === "octave") {
                el.pitch += 7;
              } else if (isComplete(state)) {
                el.endChar = index;
                return el;
              } else return null;
              break;
            case "x":
            case "y":
            case "z":
            case "Z":
              if (state === "startSlur") {
                el.rest = { type: rests[line.charAt(index)] };
                delete el.accidental;
                delete el.startSlur;
                delete el.startTie;
                delete el.endSlur;
                delete el.endTie;
                delete el.end_beam;
                delete el.grace_notes;
                if (el.rest.type === "multimeasure") {
                  el.duration = 1;
                  state = "Zduration";
                } else {
                  if (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {
                    el.duration = multilineVars.default_length * multilineVars.next_note_duration;
                    multilineVars.next_note_duration = 0;
                    durationSetByPreviousNote = true;
                  } else
                    el.duration = multilineVars.default_length;
                  state = "duration";
                }
              } else if (isComplete(state)) {
                el.endChar = index;
                return el;
              } else return null;
              break;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
            case "0":
            case "/":
              if (state === "octave" || state === "duration") {
                var fraction = tokenizer.getFraction(line, index);
                el.duration = el.duration * fraction.value;
                el.endChar = fraction.index;
                while (fraction.index < line.length && (tokenizer.isWhiteSpace(line.charAt(fraction.index)) || line.charAt(fraction.index) === "-")) {
                  if (line.charAt(fraction.index) === "-")
                    el.startTie = {};
                  else
                    el = addEndBeam(el);
                  fraction.index++;
                }
                index = fraction.index - 1;
                state = "broken_rhythm";
              } else if (state === "sharp2") {
                el.accidental = "quartersharp";
                state = "pitch";
              } else if (state === "flat2") {
                el.accidental = "quarterflat";
                state = "pitch";
              } else if (state === "Zduration") {
                var num = tokenizer.getNumber(line, index);
                el.duration = num.num;
                el.endChar = num.index;
                return el;
              } else return null;
              break;
            case "-":
              if (state === "startSlur") {
                tune.addTieToLastNote();
                el.endTie = true;
              } else if (state === "octave" || state === "duration" || state === "end_slur") {
                el.startTie = {};
                if (!durationSetByPreviousNote && canHaveBrokenRhythm)
                  state = "broken_rhythm";
                else {
                  if (tokenizer.isWhiteSpace(line.charAt(index + 1)))
                    addEndBeam(el);
                  el.endChar = index + 1;
                  return el;
                }
              } else if (state === "broken_rhythm") {
                el.endChar = index;
                return el;
              } else return null;
              break;
            case " ":
            case "	":
              if (isComplete(state)) {
                el.end_beam = true;
                do {
                  if (line.charAt(index) === "-")
                    el.startTie = {};
                  index++;
                } while (index < line.length && (tokenizer.isWhiteSpace(line.charAt(index)) || line.charAt(index) === "-"));
                el.endChar = index;
                if (!durationSetByPreviousNote && canHaveBrokenRhythm && (line.charAt(index) === "<" || line.charAt(index) === ">")) {
                  index--;
                  state = "broken_rhythm";
                } else
                  return el;
              } else return null;
              break;
            case ">":
            case "<":
              if (isComplete(state)) {
                if (canHaveBrokenRhythm) {
                  var br2 = getBrokenRhythm(line, index);
                  index += br2[0] - 1;
                  multilineVars.next_note_duration = br2[2];
                  el.duration = br2[1] * el.duration;
                  state = "end_slur";
                } else {
                  el.endChar = index;
                  return el;
                }
              } else
                return null;
              break;
            default:
              if (isComplete(state)) {
                el.endChar = index;
                return el;
              }
              return null;
          }
          index++;
          if (index === line.length) {
            if (isComplete(state)) {
              el.endChar = index;
              return el;
            } else return null;
          }
        }
        return null;
      };
      function startNewLine() {
        var params = { startChar: -1, endChar: -1 };
        if (multilineVars.partForNextLine.title)
          params.part = multilineVars.partForNextLine;
        params.clef = multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].clef !== void 0 ? parseCommon.clone(multilineVars.staves[multilineVars.currentVoice.staffNum].clef) : parseCommon.clone(multilineVars.clef);
        var scoreTranspose = multilineVars.currentVoice ? multilineVars.currentVoice.scoreTranspose : 0;
        params.key = parseKeyVoice.standardKey(multilineVars.key.root + multilineVars.key.acc + multilineVars.key.mode, multilineVars.key.root, multilineVars.key.acc, scoreTranspose);
        params.key.mode = multilineVars.key.mode;
        if (multilineVars.key.impliedNaturals)
          params.key.impliedNaturals = multilineVars.key.impliedNaturals;
        if (multilineVars.key.explicitAccidentals) {
          for (var i = 0; i < multilineVars.key.explicitAccidentals.length; i++) {
            var found = false;
            for (var j = 0; j < params.key.accidentals.length; j++) {
              if (params.key.accidentals[j].note === multilineVars.key.explicitAccidentals[i].note) {
                params.key.accidentals[j].acc = multilineVars.key.explicitAccidentals[i].acc;
                found = true;
              }
            }
            if (!found)
              params.key.accidentals.push(multilineVars.key.explicitAccidentals[i]);
          }
        }
        multilineVars.targetKey = params.key;
        if (params.key.explicitAccidentals)
          delete params.key.explicitAccidentals;
        parseKeyVoice.addPosToKey(params.clef, params.key);
        if (multilineVars.meter !== null) {
          if (multilineVars.currentVoice) {
            parseCommon.each(multilineVars.staves, function(st) {
              st.meter = multilineVars.meter;
            });
            params.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;
            multilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;
          } else
            params.meter = multilineVars.meter;
          multilineVars.meter = null;
        } else if (multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].meter) {
          params.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;
          multilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;
        }
        if (multilineVars.currentVoice && multilineVars.currentVoice.name)
          params.name = multilineVars.currentVoice.name;
        if (multilineVars.vocalfont)
          params.vocalfont = multilineVars.vocalfont;
        if (multilineVars.tripletfont)
          params.tripletfont = multilineVars.tripletfont;
        if (multilineVars.style)
          params.style = multilineVars.style;
        if (multilineVars.currentVoice) {
          var staff = multilineVars.staves[multilineVars.currentVoice.staffNum];
          if (staff.brace) params.brace = staff.brace;
          if (staff.bracket) params.bracket = staff.bracket;
          if (staff.connectBarLines) params.connectBarLines = staff.connectBarLines;
          if (staff.name) params.name = staff.name[multilineVars.currentVoice.index];
          if (staff.subname) params.subname = staff.subname[multilineVars.currentVoice.index];
          if (multilineVars.currentVoice.stem)
            params.stem = multilineVars.currentVoice.stem;
          if (multilineVars.currentVoice.stafflines)
            params.stafflines = multilineVars.currentVoice.stafflines;
          if (multilineVars.currentVoice.staffscale)
            params.staffscale = multilineVars.currentVoice.staffscale;
          if (multilineVars.currentVoice.scale)
            params.scale = multilineVars.currentVoice.scale;
          if (multilineVars.currentVoice.style)
            params.style = multilineVars.currentVoice.style;
          if (multilineVars.currentVoice.transpose)
            params.clef.transpose = multilineVars.currentVoice.transpose;
        }
        var isFirstVoice = multilineVars.currentVoice === void 0 || multilineVars.currentVoice.staffNum === 0 && multilineVars.currentVoice.index === 0;
        if (multilineVars.barNumbers === 0 && isFirstVoice && multilineVars.currBarNumber !== 1)
          params.barNumber = multilineVars.currBarNumber;
        tune.startNewLine(params);
        if (multilineVars.key.impliedNaturals)
          delete multilineVars.key.impliedNaturals;
        multilineVars.partForNextLine = {};
      }
      var letter_to_grace = function(line, i) {
        if (line.charAt(i) === "{") {
          var gra = tokenizer.getBrackettedSubstring(line, i, 1, "}");
          if (!gra[2])
            warn("Missing the closing '}' while parsing grace note", line, i);
          if (line[i + gra[0]] === ")") {
            gra[0]++;
            gra[1] += ")";
          }
          var gracenotes = [];
          var ii = 0;
          var inTie = false;
          while (ii < gra[1].length) {
            var acciaccatura = false;
            if (gra[1].charAt(ii) === "/") {
              acciaccatura = true;
              ii++;
            }
            var note = getCoreNote(gra[1], ii, {}, false);
            if (note !== null) {
              note.duration = note.duration / (multilineVars.default_length * 8);
              if (acciaccatura)
                note.acciaccatura = true;
              gracenotes.push(note);
              if (inTie) {
                note.endTie = true;
                inTie = false;
              }
              if (note.startTie)
                inTie = true;
              ii = note.endChar;
              delete note.endChar;
            } else {
              if (gra[1].charAt(ii) === " ") {
                if (gracenotes.length > 0)
                  gracenotes[gracenotes.length - 1].end_beam = true;
              } else
                warn("Unknown character '" + gra[1].charAt(ii) + "' while parsing grace note", line, i);
              ii++;
            }
          }
          if (gracenotes.length)
            return [gra[0], gracenotes];
        }
        return [0];
      };
      function letter_to_overlay(line, i) {
        if (line.charAt(i) === "&") {
          var start = i;
          while (line.charAt(i) && line.charAt(i) !== ":" && line.charAt(i) !== "|")
            i++;
          return [i - start, line.substring(start + 1, i)];
        }
        return [0];
      }
      function durationOfMeasure(multilineVars2) {
        var meter = multilineVars2.origMeter;
        if (!meter || meter.type !== "specified")
          return 1;
        if (!meter.value || meter.value.length === 0)
          return 1;
        return parseInt(meter.value[0].num, 10) / parseInt(meter.value[0].den, 10);
      }
      var nonDecorations = "ABCDEFGabcdefgxyzZ[]|^_{";
      var parseRegularMusicLine = function(line) {
        header.resolveTempo();
        multilineVars.is_in_header = false;
        var i = 0;
        var startOfLine = multilineVars.iChar;
        while (tokenizer.isWhiteSpace(line.charAt(i)) && i < line.length)
          i++;
        if (i === line.length || line.charAt(i) === "%")
          return;
        var delayStartNewLine = multilineVars.start_new_line;
        if (multilineVars.continueall === void 0)
          multilineVars.start_new_line = true;
        else
          multilineVars.start_new_line = false;
        var tripletNotesLeft = 0;
        var retHeader = header.letter_to_body_header(line, i);
        if (retHeader[0] > 0) {
          i += retHeader[0];
          if (retHeader[1] === "V")
            delayStartNewLine = true;
        }
        var el = {};
        var overlayLevel = 0;
        while (i < line.length) {
          var startI = i;
          if (line.charAt(i) === "%")
            break;
          var retInlineHeader = header.letter_to_inline_header(line, i);
          if (retInlineHeader[0] > 0) {
            i += retInlineHeader[0];
            if (retInlineHeader[1] === "V")
              delayStartNewLine = true;
          } else {
            if (delayStartNewLine) {
              startNewLine();
              delayStartNewLine = false;
            }
            var ret;
            while (1) {
              ret = tokenizer.eatWhiteSpace(line, i);
              if (ret > 0) {
                i += ret;
              }
              if (i > 0 && line.charAt(i - 1) === "") {
                ret = header.letter_to_body_header(line, i);
                if (ret[0] > 0) {
                  if (ret[1] === "V")
                    startNewLine();
                  i = ret[0];
                  multilineVars.start_new_line = false;
                }
              }
              ret = letter_to_spacer(line, i);
              if (ret[0] > 0) {
                i += ret[0];
              }
              ret = letter_to_chord(line, i);
              if (ret[0] > 0) {
                if (!el.chord)
                  el.chord = [];
                var chordName = tokenizer.translateString(ret[1]);
                chordName = chordName.replace(/;/g, "\n");
                var addedChord = false;
                for (var ci = 0; ci < el.chord.length; ci++) {
                  if (el.chord[ci].position === ret[2]) {
                    addedChord = true;
                    el.chord[ci].name += "\n" + chordName;
                  }
                }
                if (addedChord === false) {
                  if (ret[2] === null && ret[3])
                    el.chord.push({ name: chordName, rel_position: ret[3] });
                  else
                    el.chord.push({ name: chordName, position: ret[2] });
                }
                i += ret[0];
                var ii = tokenizer.skipWhiteSpace(line.substring(i));
                if (ii > 0)
                  el.force_end_beam_last = true;
                i += ii;
              } else {
                if (nonDecorations.indexOf(line.charAt(i)) === -1)
                  ret = letter_to_accent(line, i);
                else ret = [0];
                if (ret[0] > 0) {
                  if (ret[1] === null) {
                    if (i + 1 < line.length)
                      startNewLine();
                  } else if (ret[1].length > 0) {
                    if (ret[1].indexOf("style=") === 0) {
                      el.style = ret[1].substr(6);
                    } else {
                      if (el.decoration === void 0)
                        el.decoration = [];
                      el.decoration.push(ret[1]);
                    }
                  }
                  i += ret[0];
                } else {
                  ret = letter_to_grace(line, i);
                  if (ret[0] > 0) {
                    el.gracenotes = ret[1];
                    i += ret[0];
                  } else
                    break;
                }
              }
            }
            ret = letter_to_bar(line, i);
            if (ret[0] > 0) {
              overlayLevel = 0;
              if (el.gracenotes !== void 0) {
                el.rest = { type: "spacer" };
                el.duration = 0.125;
                multilineVars.addFormattingOptions(el, tune.formatting, "note");
                tune.appendElement("note", startOfLine + i, startOfLine + i + ret[0], el);
                multilineVars.measureNotEmpty = true;
                el = {};
              }
              var bar = { type: ret[1] };
              if (bar.type.length === 0)
                warn("Unknown bar type", line, i);
              else {
                if (multilineVars.inEnding && bar.type !== "bar_thin") {
                  bar.endEnding = true;
                  multilineVars.inEnding = false;
                }
                if (ret[2]) {
                  bar.startEnding = ret[2];
                  if (multilineVars.inEnding)
                    bar.endEnding = true;
                  multilineVars.inEnding = true;
                }
                if (el.decoration !== void 0)
                  bar.decoration = el.decoration;
                if (el.chord !== void 0)
                  bar.chord = el.chord;
                if (bar.startEnding && multilineVars.barFirstEndingNum === void 0)
                  multilineVars.barFirstEndingNum = multilineVars.currBarNumber;
                else if (bar.startEnding && bar.endEnding && multilineVars.barFirstEndingNum)
                  multilineVars.currBarNumber = multilineVars.barFirstEndingNum;
                else if (bar.endEnding)
                  multilineVars.barFirstEndingNum = void 0;
                if (bar.type !== "bar_invisible" && multilineVars.measureNotEmpty) {
                  var isFirstVoice = multilineVars.currentVoice === void 0 || multilineVars.currentVoice.staffNum === 0 && multilineVars.currentVoice.index === 0;
                  if (isFirstVoice) {
                    multilineVars.currBarNumber++;
                    if (multilineVars.barNumbers && multilineVars.currBarNumber % multilineVars.barNumbers === 0)
                      bar.barNumber = multilineVars.currBarNumber;
                  }
                }
                multilineVars.addFormattingOptions(el, tune.formatting, "bar");
                tune.appendElement("bar", startOfLine + i, startOfLine + i + ret[0], bar);
                multilineVars.measureNotEmpty = false;
                el = {};
              }
              i += ret[0];
              var cv = multilineVars.currentVoice ? multilineVars.currentVoice.staffNum + "-" + multilineVars.currentVoice.index : "ONLY";
            } else if (line[i] === "&") {
              ret = letter_to_overlay(line, i);
              if (ret[0] > 0) {
                tune.appendElement("overlay", startOfLine, startOfLine + 1, {});
                i += 1;
                overlayLevel++;
              }
            } else {
              ret = letter_to_open_slurs_and_triplets(line, i);
              if (ret.consumed > 0) {
                if (ret.startSlur !== void 0)
                  el.startSlur = ret.startSlur;
                if (ret.triplet !== void 0) {
                  if (tripletNotesLeft > 0)
                    warn("Can't nest triplets", line, i);
                  else {
                    el.startTriplet = ret.triplet;
                    el.tripletMultiplier = ret.tripletQ / ret.triplet;
                    tripletNotesLeft = ret.num_notes === void 0 ? ret.triplet : ret.num_notes;
                  }
                }
                i += ret.consumed;
              }
              if (line.charAt(i) === "[") {
                var chordStartChar = i;
                i++;
                var chordDuration = null;
                var rememberEndBeam = false;
                var done = false;
                while (!done) {
                  var accent = letter_to_accent(line, i);
                  if (accent[0] > 0) {
                    i += accent[0];
                  }
                  var chordNote = getCoreNote(line, i, {}, false);
                  if (chordNote !== null) {
                    if (accent[0] > 0) {
                      if (accent[1].indexOf("style=") !== 0) {
                        if (el.decoration === void 0)
                          el.decoration = [];
                        el.decoration.push(accent[1]);
                      }
                    }
                    if (chordNote.end_beam) {
                      el.end_beam = true;
                      delete chordNote.end_beam;
                    }
                    if (el.pitches === void 0) {
                      el.duration = chordNote.duration;
                      el.pitches = [chordNote];
                    } else
                      el.pitches.push(chordNote);
                    delete chordNote.duration;
                    if (accent[0] > 0) {
                      if (accent[1].indexOf("style=") === 0) {
                        el.pitches[el.pitches.length - 1].style = accent[1].substr(6);
                      }
                    }
                    if (multilineVars.inTieChord[el.pitches.length]) {
                      chordNote.endTie = true;
                      multilineVars.inTieChord[el.pitches.length] = void 0;
                    }
                    if (chordNote.startTie)
                      multilineVars.inTieChord[el.pitches.length] = true;
                    i = chordNote.endChar;
                    delete chordNote.endChar;
                  } else if (line.charAt(i) === " ") {
                    warn("Spaces are not allowed in chords", line, i);
                    i++;
                  } else {
                    if (i < line.length && line.charAt(i) === "]") {
                      i++;
                      if (multilineVars.next_note_duration !== 0) {
                        el.duration = el.duration * multilineVars.next_note_duration;
                        multilineVars.next_note_duration = 0;
                      }
                      if (isInTie(multilineVars, overlayLevel, el)) {
                        parseCommon.each(el.pitches, function(pitch) {
                          pitch.endTie = true;
                        });
                        setIsInTie(multilineVars, overlayLevel, false);
                      }
                      if (tripletNotesLeft > 0) {
                        tripletNotesLeft--;
                        if (tripletNotesLeft === 0) {
                          el.endTriplet = true;
                        }
                      }
                      var postChordDone = false;
                      while (i < line.length && !postChordDone) {
                        switch (line.charAt(i)) {
                          case " ":
                          case "	":
                            addEndBeam(el);
                            break;
                          case ")":
                            if (el.endSlur === void 0) el.endSlur = 1;
                            else el.endSlur++;
                            break;
                          case "-":
                            parseCommon.each(el.pitches, function(pitch) {
                              pitch.startTie = {};
                            });
                            setIsInTie(multilineVars, overlayLevel, true);
                            break;
                          case ">":
                          case "<":
                            var br2 = getBrokenRhythm(line, i);
                            i += br2[0] - 1;
                            multilineVars.next_note_duration = br2[2];
                            if (chordDuration)
                              chordDuration = chordDuration * br2[1];
                            else
                              chordDuration = br2[1];
                            break;
                          case "1":
                          case "2":
                          case "3":
                          case "4":
                          case "5":
                          case "6":
                          case "7":
                          case "8":
                          case "9":
                          case "/":
                            var fraction = tokenizer.getFraction(line, i);
                            chordDuration = fraction.value;
                            i = fraction.index;
                            if (line.charAt(i) === " ")
                              rememberEndBeam = true;
                            if (line.charAt(i) === "-" || line.charAt(i) === ")" || line.charAt(i) === " " || line.charAt(i) === "<" || line.charAt(i) === ">")
                              i--;
                            else
                              postChordDone = true;
                            break;
                          default:
                            postChordDone = true;
                            break;
                        }
                        if (!postChordDone) {
                          i++;
                        }
                      }
                    } else
                      warn("Expected ']' to end the chords", line, i);
                    if (el.pitches !== void 0) {
                      if (chordDuration !== null) {
                        el.duration = el.duration * chordDuration;
                        if (rememberEndBeam)
                          addEndBeam(el);
                      }
                      multilineVars.addFormattingOptions(el, tune.formatting, "note");
                      tune.appendElement("note", startOfLine + chordStartChar, startOfLine + i, el);
                      multilineVars.measureNotEmpty = true;
                      el = {};
                    }
                    done = true;
                  }
                }
              } else {
                var el2 = {};
                var core = getCoreNote(line, i, el2, true);
                if (el2.endTie !== void 0) setIsInTie(multilineVars, overlayLevel, true);
                if (core !== null) {
                  if (core.pitch !== void 0) {
                    el.pitches = [{}];
                    if (core.accidental !== void 0) el.pitches[0].accidental = core.accidental;
                    el.pitches[0].pitch = core.pitch;
                    if (core.midipitch)
                      el.pitches[0].midipitch = core.midipitch;
                    if (core.endSlur !== void 0) el.pitches[0].endSlur = core.endSlur;
                    if (core.endTie !== void 0) el.pitches[0].endTie = core.endTie;
                    if (core.startSlur !== void 0) el.pitches[0].startSlur = core.startSlur;
                    if (el.startSlur !== void 0) el.pitches[0].startSlur = el.startSlur;
                    if (core.startTie !== void 0) el.pitches[0].startTie = core.startTie;
                    if (el.startTie !== void 0) el.pitches[0].startTie = el.startTie;
                  } else {
                    el.rest = core.rest;
                    if (core.endSlur !== void 0) el.endSlur = core.endSlur;
                    if (core.endTie !== void 0) el.rest.endTie = core.endTie;
                    if (core.startSlur !== void 0) el.startSlur = core.startSlur;
                    if (core.startTie !== void 0) el.rest.startTie = core.startTie;
                    if (el.startTie !== void 0) el.rest.startTie = el.startTie;
                  }
                  if (core.chord !== void 0) el.chord = core.chord;
                  if (core.duration !== void 0) el.duration = core.duration;
                  if (core.decoration !== void 0) el.decoration = core.decoration;
                  if (core.graceNotes !== void 0) el.graceNotes = core.graceNotes;
                  delete el.startSlur;
                  if (isInTie(multilineVars, overlayLevel, el)) {
                    if (el.pitches !== void 0) {
                      el.pitches[0].endTie = true;
                    } else if (el.rest.type !== "spacer") {
                      el.rest.endTie = true;
                    }
                    setIsInTie(multilineVars, overlayLevel, false);
                  }
                  if (core.startTie || el.startTie)
                    setIsInTie(multilineVars, overlayLevel, true);
                  i = core.endChar;
                  if (tripletNotesLeft > 0) {
                    tripletNotesLeft--;
                    if (tripletNotesLeft === 0) {
                      el.endTriplet = true;
                    }
                  }
                  if (core.end_beam)
                    addEndBeam(el);
                  if (el.rest && el.rest.type === "rest" && el.duration === 1 && durationOfMeasure(multilineVars) <= 1) {
                    el.rest.type = "whole";
                    el.duration = durationOfMeasure(multilineVars);
                  }
                  multilineVars.addFormattingOptions(el, tune.formatting, "note");
                  tune.appendElement("note", startOfLine + startI, startOfLine + i, el);
                  multilineVars.measureNotEmpty = true;
                  el = {};
                }
              }
              if (i === startI) {
                if (line.charAt(i) !== " " && line.charAt(i) !== "`")
                  warn("Unknown character ignored", line, i);
                i++;
              }
            }
          }
        }
      };
      var isInTie = function(multilineVars2, overlayLevel, el) {
        if (multilineVars2.inTie[overlayLevel] === void 0)
          return false;
        var voiceIndex = multilineVars2.currentVoice ? multilineVars2.currentVoice.index : 0;
        if (multilineVars2.inTie[overlayLevel][voiceIndex]) {
          if (el.pitches !== void 0 || el.rest.type !== "spacer")
            return true;
        }
        return false;
      };
      var setIsInTie = function(multilineVars2, overlayLevel, value) {
        var voiceIndex = multilineVars2.currentVoice ? multilineVars2.currentVoice.index : 0;
        if (multilineVars2.inTie[overlayLevel] === void 0)
          multilineVars2.inTie[overlayLevel] = [];
        multilineVars2.inTie[overlayLevel][voiceIndex] = value;
      };
      var parseLine = function(line) {
        var ret = header.parseHeader(line);
        if (ret.regular)
          parseRegularMusicLine(ret.str);
        if (ret.newline)
          startNewLine();
        if (ret.words)
          addWords(tune.getCurrentVoice(), line.substring(2));
        if (ret.symbols)
          addSymbols(tune.getCurrentVoice(), line.substring(2));
        if (ret.recurse)
          parseLine(ret.str);
      };
      function appendLastMeasure(voice, nextVoice) {
        voice.push({
          el_type: "hint"
        });
        for (var i = 0; i < nextVoice.length; i++) {
          var element = nextVoice[i];
          var hint = parseCommon.clone(element);
          voice.push(hint);
          if (element.el_type === "bar")
            return;
        }
      }
      function addHintMeasure(staff, nextStaff) {
        for (var i = 0; i < staff.length; i++) {
          var stave = staff[i];
          var nextStave = nextStaff[i];
          if (nextStave) {
            for (var j = 0; j < nextStave.voices.length; j++) {
              var nextVoice = nextStave.voices[j];
              var voice = stave.voices[j];
              if (voice) {
                appendLastMeasure(voice, nextVoice);
              }
            }
          }
        }
      }
      function addHintMeasures() {
        for (var i = 0; i < tune.lines.length; i++) {
          var line = tune.lines[i].staff;
          if (line) {
            var j = i + 1;
            while (j < tune.lines.length && tune.lines[j].staff === void 0)
              j++;
            if (j < tune.lines.length) {
              var nextLine = tune.lines[j].staff;
              addHintMeasure(line, nextLine);
            }
          }
        }
      }
      this.parse = function(strTune, switches, startPos) {
        if (!switches) switches = {};
        if (!startPos) startPos = 0;
        tune.reset();
        if (switches.print)
          tune.media = "print";
        multilineVars.reset();
        multilineVars.iChar = startPos;
        if (switches.visualTranspose) {
          multilineVars.globalTranspose = parseInt(switches.visualTranspose);
          if (multilineVars.globalTranspose === 0)
            multilineVars.globalTranspose = void 0;
        } else
          multilineVars.globalTranspose = void 0;
        if (switches.lineBreaks) {
          multilineVars.lineBreaks = {};
          for (var i = 0; i < switches.lineBreaks.length; i++)
            multilineVars.lineBreaks["" + (switches.lineBreaks[i] + 1)] = true;
        }
        header.reset(tokenizer, warn, multilineVars, tune);
        strTune = parseCommon.gsub(strTune, "\r\n", "\n");
        strTune = parseCommon.gsub(strTune, "\r", "\n");
        strTune += "\n";
        strTune = strTune.replace(/\n\\.*\n/g, "\n");
        var continuationReplacement = function(all, backslash, comment) {
          var spaces = "                                                                                                                                                                                                     ";
          var padding = comment ? spaces.substring(0, comment.length) : "";
          return backslash + " " + padding;
        };
        strTune = strTune.replace(/\\([ \t]*)(%.*)*\n/g, continuationReplacement);
        var lines = strTune.split("\n");
        if (parseCommon.last(lines).length === 0)
          lines.pop();
        try {
          if (switches.format) {
            parseDirective.globalFormatting(switches.format);
          }
          parseCommon.each(lines, function(line) {
            if (switches.header_only && multilineVars.is_in_header === false)
              throw "normal_abort";
            if (switches.stop_on_warning && multilineVars.warnings)
              throw "normal_abort";
            if (multilineVars.is_in_history) {
              if (line.charAt(1) === ":") {
                multilineVars.is_in_history = false;
                parseLine(line);
              } else
                tune.addMetaText("history", tokenizer.translateString(tokenizer.stripComment(line)));
            } else if (multilineVars.inTextBlock) {
              if (parseCommon.startsWith(line, "%%endtext")) {
                tune.addText(multilineVars.textBlock);
                multilineVars.inTextBlock = false;
              } else {
                if (parseCommon.startsWith(line, "%%"))
                  multilineVars.textBlock += " " + line.substring(2);
                else
                  multilineVars.textBlock += " " + line;
              }
            } else if (multilineVars.inPsBlock) {
              if (parseCommon.startsWith(line, "%%endps")) {
                multilineVars.inPsBlock = false;
              } else
                multilineVars.textBlock += " " + line;
            } else
              parseLine(line);
            multilineVars.iChar += line.length + 1;
          });
          var ph = 11 * 72;
          var pl = 8.5 * 72;
          switch (multilineVars.papersize) {
            //case "letter": ph = 11*72; pl = 8.5*72; break;
            case "legal":
              ph = 14 * 72;
              pl = 8.5 * 72;
              break;
            case "A4":
              ph = 11.7 * 72;
              pl = 8.3 * 72;
              break;
          }
          if (multilineVars.landscape) {
            var x = ph;
            ph = pl;
            pl = x;
          }
          multilineVars.openSlurs = tune.cleanUp(pl, ph, multilineVars.barsperstaff, multilineVars.staffnonote, multilineVars.openSlurs);
        } catch (err) {
          if (err !== "normal_abort")
            throw err;
        }
        if (switches.hint_measures) {
          addHintMeasures();
        }
        wrap.wrapLines(tune, multilineVars.lineBreaks);
      };
    };
    module.exports = Parse;
  }
});

// node_modules/abcjs/src/api/abc_tunebook.js
var require_abc_tunebook = __commonJS({
  "node_modules/abcjs/src/api/abc_tunebook.js"(exports, module) {
    var parseCommon = require_abc_common();
    var Parse = require_abc_parse();
    var tunebook = {};
    (function() {
      "use strict";
      tunebook.numberOfTunes = function(abc) {
        var tunes = abc.split("\nX:");
        var num = tunes.length;
        if (num === 0) num = 1;
        return num;
      };
      var TuneBook = tunebook.TuneBook = function(book) {
        var This = this;
        var directives = "";
        book = parseCommon.strip(book);
        var tunes = book.split("\nX:");
        for (var i = 1; i < tunes.length; i++)
          tunes[i] = "X:" + tunes[i];
        var pos = 0;
        This.tunes = [];
        parseCommon.each(tunes, function(tune) {
          This.tunes.push({ abc: tune, startPos: pos });
          pos += tune.length + 1;
        });
        if (This.tunes.length > 1 && !parseCommon.startsWith(This.tunes[0].abc, "X:")) {
          var dir = This.tunes.shift();
          var arrDir = dir.abc.split("\n");
          parseCommon.each(arrDir, function(line) {
            if (parseCommon.startsWith(line, "%%"))
              directives += line + "\n";
          });
        }
        This.header = directives;
        parseCommon.each(This.tunes, function(tune) {
          var end = tune.abc.indexOf("\n\n");
          if (end > 0)
            tune.abc = tune.abc.substring(0, end);
          tune.pure = tune.abc;
          tune.abc = directives + tune.abc;
          var title = tune.pure.split("T:");
          if (title.length > 1) {
            title = title[1].split("\n");
            tune.title = title[0].replace(/^\s+|\s+$/g, "");
          } else
            tune.title = "";
          var id = tune.pure.substring(2, tune.pure.indexOf("\n"));
          tune.id = id.replace(/^\s+|\s+$/g, "");
        });
      };
      TuneBook.prototype.getTuneById = function(id) {
        for (var i = 0; i < this.tunes.length; i++) {
          if (this.tunes[i].id === "" + id)
            return this.tunes[i];
        }
        return null;
      };
      TuneBook.prototype.getTuneByTitle = function(title) {
        for (var i = 0; i < this.tunes.length; i++) {
          if (this.tunes[i].title === title)
            return this.tunes[i];
        }
        return null;
      };
      tunebook.parseOnly = function(abc, params) {
        var tunes = [];
        var numTunes = tunebook.numberOfTunes(abc);
        var output = [];
        for (var i = 0; i < numTunes; i++) {
          output.push(1);
        }
        function callback() {
        }
        return tunebook.renderEngine(callback, output, abc, params);
      };
      tunebook.renderEngine = function(callback, output, abc, params) {
        var ret = [];
        var isArray = function(testObject) {
          return testObject && !testObject.propertyIsEnumerable("length") && typeof testObject === "object" && typeof testObject.length === "number";
        };
        if (output === void 0 || abc === void 0)
          return;
        if (!isArray(output))
          output = [output];
        if (params === void 0)
          params = {};
        var currentTune = params.startingTune ? parseInt(params.startingTune, 10) : 0;
        var book = new TuneBook(abc);
        var abcParser = new Parse();
        for (var i = 0; i < output.length; i++) {
          var div = output[i];
          if (div === "*") {
          } else if (typeof div === "string")
            div = document.getElementById(div);
          if (div) {
            if (currentTune >= 0 && currentTune < book.tunes.length) {
              abcParser.parse(book.tunes[currentTune].abc, params, book.tunes[currentTune].startPos - book.header.length);
              var tune = abcParser.getTune();
              var override = callback(div, tune, i, book.tunes[currentTune].abc);
              ret.push(override ? override : tune);
            } else {
              if (div.hasOwnProperty("innerHTML"))
                div.innerHTML = "";
            }
          }
          currentTune++;
        }
        return ret;
      };
      function flattenTune(tuneObj) {
        var staves = [];
        for (var j = 0; j < tuneObj.lines.length; j++) {
          var line = tuneObj.lines[j];
          if (line.staff) {
            for (var k = 0; k < line.staff.length; k++) {
              var staff = line.staff[k];
              if (!staves[k])
                staves[k] = staff;
              else {
                for (var i = 0; i < staff.voices.length; i++) {
                  if (staves[k].voices[i])
                    staves[k].voices[i] = staves[k].voices[i].concat(staff.voices[i]);
                }
              }
            }
          }
        }
        return staves;
      }
      function measuresParser(staff, tune) {
        var voices = [];
        var lastChord = null;
        var measureStartChord = null;
        var fragStart = null;
        var hasNotes = false;
        for (var i = 0; i < staff.voices.length; i++) {
          var voice = staff.voices[i];
          voices.push([]);
          for (var j = 0; j < voice.length; j++) {
            var elem = voice[j];
            if (fragStart === null && elem.startChar >= 0) {
              fragStart = elem.startChar;
              if (elem.chord === void 0)
                measureStartChord = lastChord;
              else
                measureStartChord = null;
            }
            if (elem.chord)
              lastChord = elem;
            if (elem.el_type === "bar") {
              if (hasNotes) {
                var frag = tune.abc.substring(fragStart, elem.endChar);
                var measure = { abc: frag };
                lastChord = measureStartChord && measureStartChord.chord && measureStartChord.chord.length > 0 ? measureStartChord.chord[0].name : null;
                if (lastChord)
                  measure.lastChord = lastChord;
                if (elem.startEnding)
                  measure.startEnding = elem.startEnding;
                if (elem.endEnding)
                  measure.endEnding = elem.endEnding;
                voices[i].push(measure);
                fragStart = null;
                hasNotes = false;
              }
            } else if (elem.el_type === "note") {
              hasNotes = true;
            }
          }
        }
        return voices;
      }
      tunebook.extractMeasures = function(abc) {
        var tunes = [];
        var book = new TuneBook(abc);
        for (var i = 0; i < book.tunes.length; i++) {
          var tune = book.tunes[i];
          var arr = tune.abc.split("K:");
          var arr2 = arr[1].split("\n");
          var header = arr[0] + "K:" + arr2[0] + "\n";
          var lastChord = null;
          var measureStartChord = null;
          var fragStart = null;
          var measures = [];
          var hasNotes = false;
          var tuneObj = tunebook.parseOnly(tune.abc)[0];
          var hasPickup = tuneObj.getPickupLength() > 0;
          for (var j = 0; j < tuneObj.lines.length; j++) {
            var line = tuneObj.lines[j];
            if (line.staff) {
              for (var k = 0; k < 1; k++) {
                var staff = line.staff[k];
                for (var kk = 0; kk < 1; kk++) {
                  var voice = staff.voices[kk];
                  for (var kkk = 0; kkk < voice.length; kkk++) {
                    var elem = voice[kkk];
                    if (fragStart === null && elem.startChar >= 0) {
                      fragStart = elem.startChar;
                      if (elem.chord === void 0)
                        measureStartChord = lastChord;
                      else
                        measureStartChord = null;
                    }
                    if (elem.chord)
                      lastChord = elem;
                    if (elem.el_type === "bar") {
                      if (hasNotes) {
                        var frag = tune.abc.substring(fragStart, elem.endChar);
                        var measure = { abc: frag };
                        lastChord = measureStartChord && measureStartChord.chord && measureStartChord.chord.length > 0 ? measureStartChord.chord[0].name : null;
                        if (lastChord)
                          measure.lastChord = lastChord;
                        if (elem.startEnding)
                          measure.startEnding = elem.startEnding;
                        if (elem.endEnding)
                          measure.endEnding = elem.endEnding;
                        measures.push(measure);
                        fragStart = null;
                        hasNotes = false;
                      }
                    } else if (elem.el_type === "note") {
                      hasNotes = true;
                    }
                  }
                }
              }
            }
          }
          tunes.push({
            header,
            measures,
            hasPickup
          });
        }
        return tunes;
      };
    })();
    module.exports = tunebook;
  }
});

// node_modules/abcjs/src/write/abc_absolute_element.js
var require_abc_absolute_element = __commonJS({
  "node_modules/abcjs/src/write/abc_absolute_element.js"(exports, module) {
    var spacing = require_abc_spacing();
    var AbsoluteElement = function AbsoluteElement2(abcelem, duration, minspacing, type, tuneNumber, options) {
      if (!options)
        options = {};
      this.tuneNumber = tuneNumber;
      this.abcelem = abcelem;
      this.duration = duration;
      this.durationClass = options.durationClassOveride ? options.durationClassOveride : this.duration;
      this.minspacing = minspacing || 0;
      this.x = 0;
      this.children = [];
      this.heads = [];
      this.extra = [];
      this.extraw = 0;
      this.w = 0;
      this.right = [];
      this.invisible = false;
      this.bottom = void 0;
      this.top = void 0;
      this.type = type;
      this.specialY = {
        tempoHeightAbove: 0,
        partHeightAbove: 0,
        volumeHeightAbove: 0,
        dynamicHeightAbove: 0,
        endingHeightAbove: 0,
        chordHeightAbove: 0,
        lyricHeightAbove: 0,
        lyricHeightBelow: 0,
        chordHeightBelow: 0,
        volumeHeightBelow: 0,
        dynamicHeightBelow: 0
      };
    };
    AbsoluteElement.prototype.setUpperAndLowerElements = function(specialYResolved) {
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        for (var key in this.specialY) {
          if (this.specialY.hasOwnProperty(key)) {
            if (child[key]) {
              child.pitch = specialYResolved[key];
              if (child.top === void 0) {
                child.setUpperAndLowerElements(specialYResolved);
                this.pushTop(child.top);
                this.pushBottom(child.bottom);
              }
            }
          }
        }
      }
    };
    AbsoluteElement.prototype.getMinWidth = function() {
      return this.w;
    };
    AbsoluteElement.prototype.getExtraWidth = function() {
      return -this.extraw;
    };
    AbsoluteElement.prototype.addExtra = function(extra) {
      if (extra.dx < this.extraw) this.extraw = extra.dx;
      this.extra[this.extra.length] = extra;
      this.addChild(extra);
    };
    AbsoluteElement.prototype.addHead = function(head) {
      if (head.dx < this.extraw) this.extraw = head.dx;
      this.heads[this.heads.length] = head;
      this.addRight(head);
    };
    AbsoluteElement.prototype.addRight = function(right) {
      if (right.dx + right.w > this.w) this.w = right.dx + right.w;
      this.right[this.right.length] = right;
      this.addChild(right);
    };
    AbsoluteElement.prototype.addCentered = function(elem) {
      var half = elem.w / 2;
      if (-half < this.extraw) this.extraw = -half;
      this.extra[this.extra.length] = elem;
      if (elem.dx + half > this.w) this.w = elem.dx + half;
      this.right[this.right.length] = elem;
      this.addChild(elem);
    };
    AbsoluteElement.prototype.setLimit = function(member, child) {
      if (!child[member]) return;
      if (!this.specialY[member])
        this.specialY[member] = child[member];
      else
        this.specialY[member] = Math.max(this.specialY[member], child[member]);
    };
    AbsoluteElement.prototype.addChild = function(child) {
      child.parent = this;
      this.children[this.children.length] = child;
      this.pushTop(child.top);
      this.pushBottom(child.bottom);
      this.setLimit("tempoHeightAbove", child);
      this.setLimit("partHeightAbove", child);
      this.setLimit("volumeHeightAbove", child);
      this.setLimit("dynamicHeightAbove", child);
      this.setLimit("endingHeightAbove", child);
      this.setLimit("chordHeightAbove", child);
      this.setLimit("lyricHeightAbove", child);
      this.setLimit("lyricHeightBelow", child);
      this.setLimit("chordHeightBelow", child);
      this.setLimit("volumeHeightBelow", child);
      this.setLimit("dynamicHeightBelow", child);
    };
    AbsoluteElement.prototype.pushTop = function(top) {
      if (top !== void 0) {
        if (this.top === void 0)
          this.top = top;
        else
          this.top = Math.max(top, this.top);
      }
    };
    AbsoluteElement.prototype.pushBottom = function(bottom) {
      if (bottom !== void 0) {
        if (this.bottom === void 0)
          this.bottom = bottom;
        else
          this.bottom = Math.min(bottom, this.bottom);
      }
    };
    AbsoluteElement.prototype.setX = function(x) {
      this.x = x;
      for (var i = 0; i < this.children.length; i++)
        this.children[i].setX(x);
    };
    AbsoluteElement.prototype.setHint = function() {
      this.hint = true;
    };
    AbsoluteElement.prototype.draw = function(renderer, bartop) {
      if (this.invisible) return;
      this.elemset = [];
      renderer.beginGroup();
      for (var i = 0; i < this.children.length; i++) {
        if (
          /*ABCJS.write.debugPlacement*/
          false
        ) {
          if (this.children[i].klass === "ornament")
            renderer.printShadedBox(this.x, renderer.calcY(this.children[i].top), this.w, renderer.calcY(this.children[i].bottom) - renderer.calcY(this.children[i].top), "rgb(0,0,200)", 0.3);
        }
        var el = this.children[i].draw(renderer, bartop);
        if (el)
          this.elemset.push(el);
      }
      var klass = this.type;
      if (this.type === "note" || this.type === "rest") {
        klass += " d" + this.durationClass;
        klass = klass.replace(/\./g, "-");
        if (this.abcelem.pitches) {
          for (var j = 0; j < this.abcelem.pitches.length; j++) {
            klass += " p" + this.abcelem.pitches[j].pitch;
          }
        }
      }
      var g = renderer.endGroup(klass);
      if (g)
        this.elemset.push(g);
      if (this.klass)
        this.setClass("mark", "", "#00ff00");
      if (this.hint)
        this.setClass("abcjs-hint", "", null);
      var opacity = (
        /*ABCJS.write.debugPlacement*/
        false ? 0.3 : 0
      );
      var target = renderer.printShadedBox(this.x, renderer.calcY(this.top), this.w, renderer.calcY(this.bottom) - renderer.calcY(this.top), "#000000", opacity);
      var self = this;
      var controller = renderer.controller;
      target.addEventListener("mouseup", function() {
        var classes = [];
        if (self.elemset) {
          for (var j2 = 0; j2 < self.elemset.length; j2++) {
            var es = self.elemset[j2];
            if (es)
              classes.push(es.getAttribute("class"));
          }
        }
        controller.notifySelect(self, self.tuneNumber, classes);
      });
      this.abcelem.abselem = this;
      var step = spacing.STEP;
    };
    AbsoluteElement.prototype.isIE = /*@cc_on!@*/
    false;
    AbsoluteElement.prototype.setClass = function(addClass, removeClass, color) {
      for (var i = 0; i < this.elemset.length; i++) {
        var el = this.elemset[i];
        el.setAttribute("fill", color);
        var kls = el.getAttribute("class");
        if (!kls) kls = "";
        kls = kls.replace(removeClass, "");
        kls = kls.replace(addClass, "");
        if (addClass.length > 0) {
          if (kls.length > 0 && kls.charAt(kls.length - 1) !== " ") kls += " ";
          kls += addClass;
        }
        el.setAttribute("class", kls);
      }
    };
    AbsoluteElement.prototype.highlight = function(klass, color) {
      if (klass === void 0)
        klass = "abcjs-note_selected";
      if (color === void 0)
        color = "#ff0000";
      this.setClass(klass, "", color);
    };
    AbsoluteElement.prototype.unhighlight = function(klass, color) {
      if (klass === void 0)
        klass = "abcjs-note_selected";
      if (color === void 0)
        color = "#000000";
      this.setClass("", klass, color);
    };
    module.exports = AbsoluteElement;
  }
});

// node_modules/abcjs/src/write/abc_relative_element.js
var require_abc_relative_element = __commonJS({
  "node_modules/abcjs/src/write/abc_relative_element.js"(exports, module) {
    var RelativeElement = function RelativeElement2(c, dx, w, pitch, opt) {
      opt = opt || {};
      this.x = 0;
      this.c = c;
      this.dx = dx;
      this.w = w;
      this.pitch = pitch;
      this.scalex = opt.scalex || 1;
      this.scaley = opt.scaley || 1;
      this.type = opt.type || "symbol";
      this.pitch2 = opt.pitch2;
      this.linewidth = opt.linewidth;
      this.klass = opt.klass;
      this.top = pitch;
      if (this.pitch2 !== void 0 && this.pitch2 > this.top) this.top = this.pitch2;
      this.bottom = pitch;
      if (this.pitch2 !== void 0 && this.pitch2 < this.bottom) this.bottom = this.pitch2;
      if (opt.thickness) {
        this.top += opt.thickness / 2;
        this.bottom -= opt.thickness / 2;
      }
      if (opt.stemHeight) {
        if (opt.stemHeight > 0)
          this.top += opt.stemHeight;
        else
          this.bottom += opt.stemHeight;
      }
      this.height = opt.height ? opt.height : 4;
      this.centerVertically = false;
      switch (this.type) {
        case "debug":
          this.chordHeightAbove = this.height;
          break;
        case "lyric":
          if (opt.position && opt.position === "below")
            this.lyricHeightBelow = this.height;
          else
            this.lyricHeightAbove = this.height;
          break;
        case "chord":
          if (opt.position && opt.position === "below")
            this.chordHeightBelow = this.height;
          else
            this.chordHeightAbove = this.height;
          break;
        case "text":
          if (this.pitch === void 0) {
            if (opt.position && opt.position === "below")
              this.chordHeightBelow = this.height;
            else
              this.chordHeightAbove = this.height;
          } else
            this.centerVertically = true;
          break;
        case "part":
          this.partHeightAbove = this.height;
          break;
      }
    };
    RelativeElement.prototype.setX = function(x) {
      this.x = x + this.dx;
    };
    RelativeElement.prototype.setUpperAndLowerElements = function(positionY) {
      switch (this.type) {
        case "part":
          this.top = positionY.partHeightAbove + this.height;
          this.bottom = positionY.partHeightAbove;
          break;
        case "text":
        case "chord":
          if (this.chordHeightAbove) {
            this.top = positionY.chordHeightAbove;
            this.bottom = positionY.chordHeightAbove;
          } else {
            this.top = positionY.chordHeightBelow;
            this.bottom = positionY.chordHeightBelow;
          }
          break;
        case "lyric":
          if (this.lyricHeightAbove) {
            this.top = positionY.lyricHeightAbove;
            this.bottom = positionY.lyricHeightAbove;
          } else {
            this.top = positionY.lyricHeightBelow;
            this.bottom = positionY.lyricHeightBelow;
          }
          break;
        case "debug":
          this.top = positionY.chordHeightAbove;
          this.bottom = positionY.chordHeightAbove;
          break;
      }
      if (this.pitch === void 0 || this.top === void 0)
        window.console.error("RelativeElement position not set.", this.type, this.pitch, this.top, positionY);
    };
    RelativeElement.prototype.draw = function(renderer, bartop) {
      if (this.pitch === void 0)
        window.console.error(this.type + " Relative Element y-coordinate not set.");
      var y = renderer.calcY(this.pitch);
      switch (this.type) {
        case "symbol":
          if (this.c === null) return null;
          var klass = "symbol";
          if (this.klass) klass += " " + this.klass;
          this.graphelem = renderer.printSymbol(this.x, this.pitch, this.c, this.scalex, this.scaley, renderer.addClasses(klass));
          break;
        case "debug":
          this.graphelem = renderer.renderText(this.x, renderer.calcY(15), "" + this.c, "debugfont", "debug-msg", "start");
          break;
        case "barNumber":
          this.graphelem = renderer.renderText(this.x, y, "" + this.c, "measurefont", "bar-number", "middle");
          break;
        case "lyric":
          this.graphelem = renderer.renderText(this.x, y, this.c, "vocalfont", "lyric", "middle");
          break;
        case "chord":
          this.graphelem = renderer.renderText(this.x, y, this.c, "gchordfont", "chord", "middle");
          break;
        case "decoration":
          this.graphelem = renderer.renderText(this.x, y, this.c, "annotationfont", "annotation", "middle", true);
          break;
        case "text":
          this.graphelem = renderer.renderText(this.x, y, this.c, "annotationfont", "annotation", "start", this.centerVertically);
          break;
        case "multimeasure-text":
          this.graphelem = renderer.renderText(this.x + this.w / 2, y, this.c, "tempofont", "rest", "middle", false);
          break;
        case "part":
          this.graphelem = renderer.renderText(this.x, y, this.c, "partsfont", "part", "start");
          break;
        case "bar":
          this.graphelem = renderer.printStem(this.x, this.linewidth, y, bartop ? bartop : renderer.calcY(this.pitch2));
          break;
        // bartop can't be 0
        case "stem":
          this.graphelem = renderer.printStem(this.x, this.linewidth, y, renderer.calcY(this.pitch2));
          break;
        case "ledger":
          this.graphelem = renderer.printStaveLine(this.x, this.x + this.w, this.pitch);
          break;
      }
      if (this.scalex !== 1 && this.graphelem) {
        renderer.scaleExistingElem(this.graphelem, this.scalex, this.scaley, this.x, y);
      }
      return this.graphelem;
    };
    module.exports = RelativeElement;
  }
});

// node_modules/abcjs/src/write/abc_beam_element.js
var require_abc_beam_element = __commonJS({
  "node_modules/abcjs/src/write/abc_beam_element.js"(exports, module) {
    var AbsoluteElement = require_abc_absolute_element();
    var RelativeElement = require_abc_relative_element();
    var spacing = require_abc_spacing();
    var getDurlog = function(duration) {
      if (duration === void 0) {
        return 0;
      }
      return Math.floor(Math.log(duration) / Math.log(2));
    };
    var BeamElem;
    (function() {
      "use strict";
      BeamElem = function BeamElem2(stemHeight, type, flat) {
        this.isflat = flat;
        this.isgrace = type && type === "grace";
        this.forceup = this.isgrace || type && type === "up";
        this.forcedown = type && type === "down";
        this.elems = [];
        this.total = 0;
        this.allrests = true;
        this.stemHeight = stemHeight;
        this.beams = [];
      };
      BeamElem.prototype.setHint = function() {
        this.hint = true;
      };
      BeamElem.prototype.add = function(abselem) {
        var pitch = abselem.abcelem.averagepitch;
        if (pitch === void 0) return;
        this.allrests = this.allrests && abselem.abcelem.rest;
        abselem.beam = this;
        this.elems.push(abselem);
        this.total += pitch;
        if (this.min === void 0 || abselem.abcelem.minpitch < this.min) {
          this.min = abselem.abcelem.minpitch;
        }
        if (this.max === void 0 || abselem.abcelem.maxpitch > this.max) {
          this.max = abselem.abcelem.maxpitch;
        }
      };
      var middleLine = 6;
      BeamElem.prototype.calcDir = function() {
        if (this.forceup) return true;
        if (this.forcedown) return false;
        var average = calcAverage(this.total, this.elems.length);
        return average < middleLine;
      };
      BeamElem.prototype.layout = function() {
        if (this.elems.length === 0 || this.allrests) return;
        this.stemsUp = this.calcDir();
        var dy = calcDy(this.stemsUp, this.isgrace);
        var firstElement = this.elems[0];
        var lastElement = this.elems[this.elems.length - 1];
        var minStemHeight = 0;
        var referencePitch = this.stemsUp ? firstElement.abcelem.maxpitch : firstElement.abcelem.minpitch;
        minStemHeight = minStem(firstElement, this.stemsUp, referencePitch, minStemHeight);
        minStemHeight = minStem(lastElement, this.stemsUp, referencePitch, minStemHeight);
        minStemHeight = Math.max(this.stemHeight, minStemHeight + 3);
        var yPos = calcYPos(this.total, this.elems.length, minStemHeight, this.stemsUp, firstElement.abcelem.averagepitch, lastElement.abcelem.averagepitch, this.isflat, this.min, this.max, this.isgrace);
        var xPos = calcXPos(this.stemsUp, firstElement, lastElement);
        this.beams.push({ startX: xPos[0], endX: xPos[1], startY: yPos[0], endY: yPos[1], dy });
        var beams = createAdditionalBeams(this.elems, this.stemsUp, this.beams[0], this.isgrace, dy);
        for (var i = 0; i < beams.length; i++)
          this.beams.push(beams[i]);
        createStems(this.elems, this.stemsUp, this.beams[0], dy, this.mainNote);
      };
      BeamElem.prototype.isAbove = function() {
        return this.stemsUp;
      };
      BeamElem.prototype.heightAtMidpoint = function(startX, endX) {
        if (this.beams.length === 0)
          return 0;
        var beam = this.beams[0];
        var midPoint = startX + (endX - startX) / 2;
        return getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, midPoint);
      };
      BeamElem.prototype.yAtNote = function(element) {
        var beam = this.beams[0];
        return getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, element.x);
      };
      BeamElem.prototype.xAtMidpoint = function(startX, endX) {
        return startX + (endX - startX) / 2;
      };
      BeamElem.prototype.draw = function(renderer) {
        if (this.beams.length === 0) return;
        renderer.beginGroup();
        for (var i = 0; i < this.beams.length; i++) {
          var beam = this.beams[i];
          drawBeam(renderer, beam.startX, beam.startY, beam.endX, beam.endY, beam.dy, this.hint);
        }
        renderer.endGroup("beam-elem");
      };
      function minStem(element, stemsUp, referencePitch, minStemHeight) {
        if (!element.children)
          return minStemHeight;
        for (var i = 0; i < element.children.length; i++) {
          var elem = element.children[i];
          if (stemsUp && elem.top !== void 0 && elem.c === "flags.ugrace")
            minStemHeight = Math.max(minStemHeight, elem.top - referencePitch);
          else if (!stemsUp && elem.bottom !== void 0 && elem.c === "flags.ugrace")
            minStemHeight = Math.max(minStemHeight, referencePitch - elem.bottom + 7);
        }
        return minStemHeight;
      }
      function calcSlant(leftAveragePitch, rightAveragePitch, numStems, isFlat) {
        if (isFlat)
          return 0;
        var slant = leftAveragePitch - rightAveragePitch;
        var maxSlant = numStems / 2;
        if (slant > maxSlant) slant = maxSlant;
        if (slant < -maxSlant) slant = -maxSlant;
        return slant;
      }
      function calcAverage(total, numElements) {
        if (!numElements)
          return 0;
        return total / numElements;
      }
      function getBarYAt(startx, starty, endx, endy, x) {
        return starty + (endy - starty) / (endx - startx) * (x - startx);
      }
      function calcDy(asc, isGrace) {
        var dy = asc ? spacing.STEP : -spacing.STEP;
        if (isGrace) dy = dy * 0.4;
        return dy;
      }
      function drawBeam(renderer, startX, startY, endX, endY, dy, isHint) {
        var klass = "beam-elem";
        if (isHint)
          klass += " abcjs-hint";
        startY = renderer.calcY(startY);
        endY = renderer.calcY(endY);
        var pathString = "M" + startX + " " + startY + " L" + endX + " " + endY + "L" + endX + " " + (endY + dy) + " L" + startX + " " + (startY + dy) + "z";
        renderer.printPath({
          path: pathString,
          stroke: "none",
          fill: "#000000",
          "class": renderer.addClasses(klass)
        });
      }
      function calcXPos(asc, firstElement, lastElement) {
        var starthead = firstElement.heads[asc ? 0 : firstElement.heads.length - 1];
        var endhead = lastElement.heads[asc ? 0 : lastElement.heads.length - 1];
        var startX = starthead.x;
        if (asc) startX += starthead.w - 0.6;
        var endX = endhead.x;
        if (asc) endX += endhead.w;
        return [startX, endX];
      }
      function calcYPos(total, numElements, stemHeight, asc, firstAveragePitch, lastAveragePitch, isFlat, minPitch, maxPitch, isGrace) {
        var average = calcAverage(total, numElements);
        var barpos = stemHeight - 2;
        var barminpos = stemHeight - 2;
        var pos = Math.round(asc ? Math.max(average + barpos, maxPitch + barminpos) : Math.min(average - barpos, minPitch - barminpos));
        var slant = calcSlant(firstAveragePitch, lastAveragePitch, numElements, isFlat);
        var startY = pos + Math.floor(slant / 2);
        var endY = pos + Math.floor(-slant / 2);
        if (!isGrace) {
          if (asc && pos < 6) {
            startY = 6;
            endY = 6;
          } else if (!asc && pos > 6) {
            startY = 6;
            endY = 6;
          }
        }
        return [startY, endY];
      }
      function createStems(elems, asc, beam, dy, mainNote) {
        for (var i = 0; i < elems.length; i++) {
          var elem = elems[i];
          if (elem.abcelem.rest)
            continue;
          var isGrace = elem.addExtra ? false : true;
          var parent = isGrace ? mainNote : elem;
          var furthestHead = elem.heads[asc ? 0 : elem.heads.length - 1];
          var ovalDelta = 1 / 5;
          var pitch = furthestHead.pitch + (asc ? ovalDelta : -ovalDelta);
          var dx = asc ? furthestHead.w : 0;
          var x = furthestHead.x + dx;
          var bary = getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, x);
          var lineWidth = asc ? -0.6 : 0.6;
          if (!asc)
            bary -= dy / 2 / spacing.STEP;
          if (isGrace)
            dx += elem.heads[0].dx;
          if (furthestHead.c === "noteheads.slash.quarter") {
            if (asc)
              pitch += 1;
            else
              pitch -= 1;
          }
          var stem = new RelativeElement(null, dx, 0, pitch, {
            "type": "stem",
            "pitch2": bary,
            linewidth: lineWidth
          });
          stem.setX(parent.x);
          parent.addExtra(stem);
        }
      }
      function createAdditionalBeams(elems, asc, beam, isGrace, dy) {
        var beams = [];
        var auxBeams = [];
        for (var i = 0; i < elems.length; i++) {
          var elem = elems[i];
          if (elem.abcelem.rest)
            continue;
          var furthestHead = elem.heads[asc ? 0 : elem.heads.length - 1];
          var x = furthestHead.x + (asc ? furthestHead.w : 0);
          var bary = getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, x);
          var sy = asc ? -1.5 : 1.5;
          if (isGrace) sy = sy * 2 / 3;
          var duration = elem.abcelem.duration;
          if (duration === 0) duration = 0.25;
          for (var durlog = getDurlog(duration); durlog < -3; durlog++) {
            if (auxBeams[-4 - durlog]) {
              auxBeams[-4 - durlog].single = false;
            } else {
              auxBeams[-4 - durlog] = {
                x: x + (asc ? -0.6 : 0),
                y: bary + sy * (-4 - durlog + 1),
                durlog,
                single: true
              };
            }
          }
          for (var j = auxBeams.length - 1; j >= 0; j--) {
            if (i === elems.length - 1 || getDurlog(elems[i + 1].abcelem.duration) > -j - 4) {
              var auxBeamEndX = x;
              var auxBeamEndY = bary + sy * (j + 1);
              if (auxBeams[j].single) {
                auxBeamEndX = i === 0 ? x + 5 : x - 5;
                auxBeamEndY = getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, auxBeamEndX) + sy * (j + 1);
              }
              beams.push({ startX: auxBeams[j].x, endX: auxBeamEndX, startY: auxBeams[j].y, endY: auxBeamEndY, dy });
              auxBeams = auxBeams.slice(0, j);
            }
          }
        }
        return beams;
      }
    })();
    module.exports = BeamElem;
  }
});

// node_modules/abcjs/src/write/abc_brace_element.js
var require_abc_brace_element = __commonJS({
  "node_modules/abcjs/src/write/abc_brace_element.js"(exports, module) {
    var BraceElem = function BraceElem2() {
      this.length = 1;
    };
    BraceElem.prototype.increaseStavesIncluded = function() {
      this.length++;
    };
    BraceElem.prototype.setLocation = function(x) {
      this.x = x;
    };
    BraceElem.prototype.getWidth = function() {
      return 10;
    };
    BraceElem.prototype.layout = function(renderer, top, bottom) {
      this.startY = top;
      this.endY = bottom;
    };
    BraceElem.prototype.draw = function(renderer, top, bottom) {
      this.layout(renderer, top, bottom);
      renderer.drawBrace(this.x, this.startY, this.endY);
    };
    module.exports = BraceElem;
  }
});

// node_modules/abcjs/src/write/abc_glyphs.js
var require_abc_glyphs = __commonJS({
  "node_modules/abcjs/src/write/abc_glyphs.js"(exports, module) {
    var spacing = require_abc_spacing();
    var glyphs = {
      "0": { d: [["M", 4.83, -14.97], ["c", 0.33, -0.03, 1.11, 0, 1.47, 0.06], ["c", 1.68, 0.36, 2.97, 1.59, 3.78, 3.6], ["c", 1.2, 2.97, 0.81, 6.96, -0.9, 9.27], ["c", -0.78, 1.08, -1.71, 1.71, -2.91, 1.95], ["c", -0.45, 0.09, -1.32, 0.09, -1.77, 0], ["c", -0.81, -0.18, -1.47, -0.51, -2.07, -1.02], ["c", -2.34, -2.07, -3.15, -6.72, -1.74, -10.2], ["c", 0.87, -2.16, 2.28, -3.42, 4.14, -3.66], ["z"], ["m", 1.11, 0.87], ["c", -0.21, -0.06, -0.69, -0.09, -0.87, -0.06], ["c", -0.54, 0.12, -0.87, 0.42, -1.17, 0.99], ["c", -0.36, 0.66, -0.51, 1.56, -0.6, 3], ["c", -0.03, 0.75, -0.03, 4.59, 0, 5.31], ["c", 0.09, 1.5, 0.27, 2.4, 0.6, 3.06], ["c", 0.24, 0.48, 0.57, 0.78, 0.96, 0.9], ["c", 0.27, 0.09, 0.78, 0.09, 1.05, 0], ["c", 0.39, -0.12, 0.72, -0.42, 0.96, -0.9], ["c", 0.33, -0.66, 0.51, -1.56, 0.6, -3.06], ["c", 0.03, -0.72, 0.03, -4.56, 0, -5.31], ["c", -0.09, -1.47, -0.27, -2.37, -0.6, -3.03], ["c", -0.24, -0.48, -0.54, -0.78, -0.93, -0.9], ["z"]], w: 10.78, h: 14.959 },
      "1": { d: [["M", 3.3, -15.06], ["c", 0.06, -0.06, 0.21, -0.03, 0.66, 0.15], ["c", 0.81, 0.39, 1.08, 0.39, 1.83, 0.03], ["c", 0.21, -0.09, 0.39, -0.15, 0.42, -0.15], ["c", 0.12, 0, 0.21, 0.09, 0.27, 0.21], ["c", 0.06, 0.12, 0.06, 0.33, 0.06, 5.94], ["c", 0, 3.93, 0, 5.85, 0.03, 6.03], ["c", 0.06, 0.36, 0.15, 0.69, 0.27, 0.96], ["c", 0.36, 0.75, 0.93, 1.17, 1.68, 1.26], ["c", 0.3, 0.03, 0.39, 0.09, 0.39, 0.3], ["c", 0, 0.15, -0.03, 0.18, -0.09, 0.24], ["c", -0.06, 0.06, -0.09, 0.06, -0.48, 0.06], ["c", -0.42, 0, -0.69, -0.03, -2.1, -0.24], ["c", -0.9, -0.15, -1.77, -0.15, -2.67, 0], ["c", -1.41, 0.21, -1.68, 0.24, -2.1, 0.24], ["c", -0.39, 0, -0.42, 0, -0.48, -0.06], ["c", -0.06, -0.06, -0.06, -0.09, -0.06, -0.24], ["c", 0, -0.21, 0.06, -0.27, 0.36, -0.3], ["c", 0.75, -0.09, 1.32, -0.51, 1.68, -1.26], ["c", 0.12, -0.27, 0.21, -0.6, 0.27, -0.96], ["c", 0.03, -0.18, 0.03, -1.59, 0.03, -4.29], ["c", 0, -3.87, 0, -4.05, -0.06, -4.14], ["c", -0.09, -0.15, -0.18, -0.24, -0.39, -0.24], ["c", -0.12, 0, -0.15, 0.03, -0.21, 0.06], ["c", -0.03, 0.06, -0.45, 0.99, -0.96, 2.13], ["c", -0.48, 1.14, -0.9, 2.1, -0.93, 2.16], ["c", -0.06, 0.15, -0.21, 0.24, -0.33, 0.24], ["c", -0.24, 0, -0.42, -0.18, -0.42, -0.39], ["c", 0, -0.06, 3.27, -7.62, 3.33, -7.74], ["z"]], w: 8.94, h: 15.058 },
      "2": { d: [["M", 4.23, -14.97], ["c", 0.57, -0.06, 1.68, 0, 2.34, 0.18], ["c", 0.69, 0.18, 1.5, 0.54, 2.01, 0.9], ["c", 1.35, 0.96, 1.95, 2.25, 1.77, 3.81], ["c", -0.15, 1.35, -0.66, 2.34, -1.68, 3.15], ["c", -0.6, 0.48, -1.44, 0.93, -3.12, 1.65], ["c", -1.32, 0.57, -1.8, 0.81, -2.37, 1.14], ["c", -0.57, 0.33, -0.57, 0.33, -0.24, 0.27], ["c", 0.39, -0.09, 1.26, -0.09, 1.68, 0], ["c", 0.72, 0.15, 1.41, 0.45, 2.1, 0.9], ["c", 0.99, 0.63, 1.86, 0.87, 2.55, 0.75], ["c", 0.24, -0.06, 0.42, -0.15, 0.57, -0.3], ["c", 0.12, -0.09, 0.3, -0.42, 0.3, -0.51], ["c", 0, -0.09, 0.12, -0.21, 0.24, -0.24], ["c", 0.18, -0.03, 0.39, 0.12, 0.39, 0.3], ["c", 0, 0.12, -0.15, 0.57, -0.3, 0.87], ["c", -0.54, 1.02, -1.56, 1.74, -2.79, 2.01], ["c", -0.42, 0.09, -1.23, 0.09, -1.62, 0.03], ["c", -0.81, -0.18, -1.32, -0.45, -2.01, -1.11], ["c", -0.45, -0.45, -0.63, -0.57, -0.96, -0.69], ["c", -0.84, -0.27, -1.89, 0.12, -2.25, 0.9], ["c", -0.12, 0.21, -0.21, 0.54, -0.21, 0.72], ["c", 0, 0.12, -0.12, 0.21, -0.27, 0.24], ["c", -0.15, 0, -0.27, -0.03, -0.33, -0.15], ["c", -0.09, -0.21, 0.09, -1.08, 0.33, -1.71], ["c", 0.24, -0.66, 0.66, -1.26, 1.29, -1.89], ["c", 0.45, -0.45, 0.9, -0.81, 1.92, -1.56], ["c", 1.29, -0.93, 1.89, -1.44, 2.34, -1.98], ["c", 0.87, -1.05, 1.26, -2.19, 1.2, -3.63], ["c", -0.06, -1.29, -0.39, -2.31, -0.96, -2.91], ["c", -0.36, -0.33, -0.72, -0.51, -1.17, -0.54], ["c", -0.84, -0.03, -1.53, 0.42, -1.59, 1.05], ["c", -0.03, 0.33, 0.12, 0.6, 0.57, 1.14], ["c", 0.45, 0.54, 0.54, 0.87, 0.42, 1.41], ["c", -0.15, 0.63, -0.54, 1.11, -1.08, 1.38], ["c", -0.63, 0.33, -1.2, 0.33, -1.83, 0], ["c", -0.24, -0.12, -0.33, -0.18, -0.54, -0.39], ["c", -0.18, -0.18, -0.27, -0.3, -0.36, -0.51], ["c", -0.24, -0.45, -0.27, -0.84, -0.21, -1.38], ["c", 0.12, -0.75, 0.45, -1.41, 1.02, -1.98], ["c", 0.72, -0.72, 1.74, -1.17, 2.85, -1.32], ["z"]], w: 10.764, h: 14.97 },
      "3": { d: [["M", 3.78, -14.97], ["c", 0.3, -0.03, 1.41, 0, 1.83, 0.06], ["c", 2.22, 0.3, 3.51, 1.32, 3.72, 2.91], ["c", 0.03, 0.33, 0.03, 1.26, -0.03, 1.65], ["c", -0.12, 0.84, -0.48, 1.47, -1.05, 1.77], ["c", -0.27, 0.15, -0.36, 0.24, -0.45, 0.39], ["c", -0.09, 0.21, -0.09, 0.36, 0, 0.57], ["c", 0.09, 0.15, 0.18, 0.24, 0.51, 0.39], ["c", 0.75, 0.42, 1.23, 1.14, 1.41, 2.13], ["c", 0.06, 0.42, 0.06, 1.35, 0, 1.71], ["c", -0.18, 0.81, -0.48, 1.38, -1.02, 1.95], ["c", -0.75, 0.72, -1.8, 1.2, -3.18, 1.38], ["c", -0.42, 0.06, -1.56, 0.06, -1.95, 0], ["c", -1.89, -0.33, -3.18, -1.29, -3.51, -2.64], ["c", -0.03, -0.12, -0.03, -0.33, -0.03, -0.6], ["c", 0, -0.36, 0, -0.42, 0.06, -0.63], ["c", 0.12, -0.3, 0.27, -0.51, 0.51, -0.75], ["c", 0.24, -0.24, 0.45, -0.39, 0.75, -0.51], ["c", 0.21, -0.06, 0.27, -0.06, 0.6, -0.06], ["c", 0.33, 0, 0.39, 0, 0.6, 0.06], ["c", 0.3, 0.12, 0.51, 0.27, 0.75, 0.51], ["c", 0.36, 0.33, 0.57, 0.75, 0.6, 1.2], ["c", 0, 0.21, 0, 0.27, -0.06, 0.42], ["c", -0.09, 0.18, -0.12, 0.24, -0.54, 0.54], ["c", -0.51, 0.36, -0.63, 0.54, -0.6, 0.87], ["c", 0.06, 0.54, 0.54, 0.9, 1.38, 0.99], ["c", 0.36, 0.06, 0.72, 0.03, 0.96, -0.06], ["c", 0.81, -0.27, 1.29, -1.23, 1.44, -2.79], ["c", 0.03, -0.45, 0.03, -1.95, -0.03, -2.37], ["c", -0.09, -0.75, -0.33, -1.23, -0.75, -1.44], ["c", -0.33, -0.18, -0.45, -0.18, -1.98, -0.18], ["c", -1.35, 0, -1.41, 0, -1.5, -0.06], ["c", -0.18, -0.12, -0.24, -0.39, -0.12, -0.6], ["c", 0.12, -0.15, 0.15, -0.15, 1.68, -0.15], ["c", 1.5, 0, 1.62, 0, 1.89, -0.15], ["c", 0.18, -0.09, 0.42, -0.36, 0.54, -0.57], ["c", 0.18, -0.42, 0.27, -0.9, 0.3, -1.95], ["c", 0.03, -1.2, -0.06, -1.8, -0.36, -2.37], ["c", -0.24, -0.48, -0.63, -0.81, -1.14, -0.96], ["c", -0.3, -0.06, -1.08, -0.06, -1.38, 0.03], ["c", -0.6, 0.15, -0.9, 0.42, -0.96, 0.84], ["c", -0.03, 0.3, 0.06, 0.45, 0.63, 0.84], ["c", 0.33, 0.24, 0.42, 0.39, 0.45, 0.63], ["c", 0.03, 0.72, -0.57, 1.5, -1.32, 1.65], ["c", -1.05, 0.27, -2.1, -0.57, -2.1, -1.65], ["c", 0, -0.45, 0.15, -0.96, 0.39, -1.38], ["c", 0.12, -0.21, 0.54, -0.63, 0.81, -0.81], ["c", 0.57, -0.42, 1.38, -0.69, 2.25, -0.81], ["z"]], w: 9.735, h: 14.967 },
      "4": { d: [["M", 8.64, -14.94], ["c", 0.27, -0.09, 0.42, -0.12, 0.54, -0.03], ["c", 0.09, 0.06, 0.15, 0.21, 0.15, 0.3], ["c", -0.03, 0.06, -1.92, 2.31, -4.23, 5.04], ["c", -2.31, 2.73, -4.23, 4.98, -4.26, 5.01], ["c", -0.03, 0.06, 0.12, 0.06, 2.55, 0.06], ["l", 2.61, 0], ["l", 0, -2.37], ["c", 0, -2.19, 0.03, -2.37, 0.06, -2.46], ["c", 0.03, -0.06, 0.21, -0.18, 0.57, -0.42], ["c", 1.08, -0.72, 1.38, -1.08, 1.86, -2.16], ["c", 0.12, -0.3, 0.24, -0.54, 0.27, -0.57], ["c", 0.12, -0.12, 0.39, -0.06, 0.45, 0.12], ["c", 0.06, 0.09, 0.06, 0.57, 0.06, 3.96], ["l", 0, 3.9], ["l", 1.08, 0], ["c", 1.05, 0, 1.11, 0, 1.2, 0.06], ["c", 0.24, 0.15, 0.24, 0.54, 0, 0.69], ["c", -0.09, 0.06, -0.15, 0.06, -1.2, 0.06], ["l", -1.08, 0], ["l", 0, 0.33], ["c", 0, 0.57, 0.09, 1.11, 0.3, 1.53], ["c", 0.36, 0.75, 0.93, 1.17, 1.68, 1.26], ["c", 0.3, 0.03, 0.39, 0.09, 0.39, 0.3], ["c", 0, 0.15, -0.03, 0.18, -0.09, 0.24], ["c", -0.06, 0.06, -0.09, 0.06, -0.48, 0.06], ["c", -0.42, 0, -0.69, -0.03, -2.1, -0.24], ["c", -0.9, -0.15, -1.77, -0.15, -2.67, 0], ["c", -1.41, 0.21, -1.68, 0.24, -2.1, 0.24], ["c", -0.39, 0, -0.42, 0, -0.48, -0.06], ["c", -0.06, -0.06, -0.06, -0.09, -0.06, -0.24], ["c", 0, -0.21, 0.06, -0.27, 0.36, -0.3], ["c", 0.75, -0.09, 1.32, -0.51, 1.68, -1.26], ["c", 0.21, -0.42, 0.3, -0.96, 0.3, -1.53], ["l", 0, -0.33], ["l", -2.7, 0], ["c", -2.91, 0, -2.85, 0, -3.09, -0.15], ["c", -0.18, -0.12, -0.3, -0.39, -0.27, -0.54], ["c", 0.03, -0.06, 0.18, -0.24, 0.33, -0.45], ["c", 0.75, -0.9, 1.59, -2.07, 2.13, -3.03], ["c", 0.33, -0.54, 0.84, -1.62, 1.05, -2.16], ["c", 0.57, -1.41, 0.84, -2.64, 0.9, -4.05], ["c", 0.03, -0.63, 0.06, -0.72, 0.24, -0.81], ["l", 0.12, -0.06], ["l", 0.45, 0.12], ["c", 0.66, 0.18, 1.02, 0.24, 1.47, 0.27], ["c", 0.6, 0.03, 1.23, -0.09, 2.01, -0.33], ["z"]], w: 11.795, h: 14.994 },
      "5": { d: [["M", 1.02, -14.94], ["c", 0.12, -0.09, 0.03, -0.09, 1.08, 0.06], ["c", 2.49, 0.36, 4.35, 0.36, 6.96, -0.06], ["c", 0.57, -0.09, 0.66, -0.06, 0.81, 0.06], ["c", 0.15, 0.18, 0.12, 0.24, -0.15, 0.51], ["c", -1.29, 1.26, -3.24, 2.04, -5.58, 2.31], ["c", -0.6, 0.09, -1.2, 0.12, -1.71, 0.12], ["c", -0.39, 0, -0.45, 0, -0.57, 0.06], ["c", -0.09, 0.06, -0.15, 0.12, -0.21, 0.21], ["l", -0.06, 0.12], ["l", 0, 1.65], ["l", 0, 1.65], ["l", 0.21, -0.21], ["c", 0.66, -0.57, 1.41, -0.96, 2.19, -1.14], ["c", 0.33, -0.06, 1.41, -0.06, 1.95, 0], ["c", 2.61, 0.36, 4.02, 1.74, 4.26, 4.14], ["c", 0.03, 0.45, 0.03, 1.08, -0.03, 1.44], ["c", -0.18, 1.02, -0.78, 2.01, -1.59, 2.7], ["c", -0.72, 0.57, -1.62, 1.02, -2.49, 1.2], ["c", -1.38, 0.27, -3.03, 0.06, -4.2, -0.54], ["c", -1.08, -0.54, -1.71, -1.32, -1.86, -2.28], ["c", -0.09, -0.69, 0.09, -1.29, 0.57, -1.74], ["c", 0.24, -0.24, 0.45, -0.39, 0.75, -0.51], ["c", 0.21, -0.06, 0.27, -0.06, 0.6, -0.06], ["c", 0.33, 0, 0.39, 0, 0.6, 0.06], ["c", 0.3, 0.12, 0.51, 0.27, 0.75, 0.51], ["c", 0.36, 0.33, 0.57, 0.75, 0.6, 1.2], ["c", 0, 0.21, 0, 0.27, -0.06, 0.42], ["c", -0.09, 0.18, -0.12, 0.24, -0.54, 0.54], ["c", -0.18, 0.12, -0.36, 0.3, -0.42, 0.33], ["c", -0.36, 0.42, -0.18, 0.99, 0.36, 1.26], ["c", 0.51, 0.27, 1.47, 0.36, 2.01, 0.27], ["c", 0.93, -0.21, 1.47, -1.17, 1.65, -2.91], ["c", 0.06, -0.45, 0.06, -1.89, 0, -2.31], ["c", -0.15, -1.2, -0.51, -2.1, -1.05, -2.55], ["c", -0.21, -0.18, -0.54, -0.36, -0.81, -0.39], ["c", -0.3, -0.06, -0.84, -0.03, -1.26, 0.06], ["c", -0.93, 0.18, -1.65, 0.6, -2.16, 1.2], ["c", -0.15, 0.21, -0.27, 0.3, -0.39, 0.3], ["c", -0.15, 0, -0.3, -0.09, -0.36, -0.18], ["c", -0.06, -0.09, -0.06, -0.15, -0.06, -3.66], ["c", 0, -3.39, 0, -3.57, 0.06, -3.66], ["c", 0.03, -0.06, 0.09, -0.15, 0.15, -0.18], ["z"]], w: 10.212, h: 14.997 },
      "6": { d: [["M", 4.98, -14.97], ["c", 0.36, -0.03, 1.2, 0, 1.59, 0.06], ["c", 0.9, 0.15, 1.68, 0.51, 2.25, 1.05], ["c", 0.57, 0.51, 0.87, 1.23, 0.84, 1.98], ["c", -0.03, 0.51, -0.21, 0.9, -0.6, 1.26], ["c", -0.24, 0.24, -0.45, 0.39, -0.75, 0.51], ["c", -0.21, 0.06, -0.27, 0.06, -0.6, 0.06], ["c", -0.33, 0, -0.39, 0, -0.6, -0.06], ["c", -0.3, -0.12, -0.51, -0.27, -0.75, -0.51], ["c", -0.39, -0.36, -0.57, -0.78, -0.57, -1.26], ["c", 0, -0.27, 0, -0.3, 0.09, -0.42], ["c", 0.03, -0.09, 0.18, -0.21, 0.3, -0.3], ["c", 0.12, -0.09, 0.3, -0.21, 0.39, -0.27], ["c", 0.09, -0.06, 0.21, -0.18, 0.27, -0.24], ["c", 0.06, -0.12, 0.09, -0.15, 0.09, -0.33], ["c", 0, -0.18, -0.03, -0.24, -0.09, -0.36], ["c", -0.24, -0.39, -0.75, -0.6, -1.38, -0.57], ["c", -0.54, 0.03, -0.9, 0.18, -1.23, 0.48], ["c", -0.81, 0.72, -1.08, 2.16, -0.96, 5.37], ["l", 0, 0.63], ["l", 0.3, -0.12], ["c", 0.78, -0.27, 1.29, -0.33, 2.1, -0.27], ["c", 1.47, 0.12, 2.49, 0.54, 3.27, 1.29], ["c", 0.48, 0.51, 0.81, 1.11, 0.96, 1.89], ["c", 0.06, 0.27, 0.06, 0.42, 0.06, 0.93], ["c", 0, 0.54, 0, 0.69, -0.06, 0.96], ["c", -0.15, 0.78, -0.48, 1.38, -0.96, 1.89], ["c", -0.54, 0.51, -1.17, 0.87, -1.98, 1.08], ["c", -1.14, 0.3, -2.4, 0.33, -3.24, 0.03], ["c", -1.5, -0.48, -2.64, -1.89, -3.27, -4.02], ["c", -0.36, -1.23, -0.51, -2.82, -0.42, -4.08], ["c", 0.3, -3.66, 2.28, -6.3, 4.95, -6.66], ["z"], ["m", 0.66, 7.41], ["c", -0.27, -0.09, -0.81, -0.12, -1.08, -0.06], ["c", -0.72, 0.18, -1.08, 0.69, -1.23, 1.71], ["c", -0.06, 0.54, -0.06, 3, 0, 3.54], ["c", 0.18, 1.26, 0.72, 1.77, 1.8, 1.74], ["c", 0.39, -0.03, 0.63, -0.09, 0.9, -0.27], ["c", 0.66, -0.42, 0.9, -1.32, 0.9, -3.24], ["c", 0, -2.22, -0.36, -3.12, -1.29, -3.42], ["z"]], w: 9.956, h: 14.982 },
      "7": { d: [["M", 0.21, -14.97], ["c", 0.21, -0.06, 0.45, 0, 0.54, 0.15], ["c", 0.06, 0.09, 0.06, 0.15, 0.06, 0.39], ["c", 0, 0.24, 0, 0.33, 0.06, 0.42], ["c", 0.06, 0.12, 0.21, 0.24, 0.27, 0.24], ["c", 0.03, 0, 0.12, -0.12, 0.24, -0.21], ["c", 0.96, -1.2, 2.58, -1.35, 3.99, -0.42], ["c", 0.15, 0.12, 0.42, 0.3, 0.54, 0.45], ["c", 0.48, 0.39, 0.81, 0.57, 1.29, 0.6], ["c", 0.69, 0.03, 1.5, -0.3, 2.13, -0.87], ["c", 0.09, -0.09, 0.27, -0.3, 0.39, -0.45], ["c", 0.12, -0.15, 0.24, -0.27, 0.3, -0.3], ["c", 0.18, -0.06, 0.39, 0.03, 0.51, 0.21], ["c", 0.06, 0.18, 0.06, 0.24, -0.27, 0.72], ["c", -0.18, 0.24, -0.54, 0.78, -0.78, 1.17], ["c", -2.37, 3.54, -3.54, 6.27, -3.87, 9], ["c", -0.03, 0.33, -0.03, 0.66, -0.03, 1.26], ["c", 0, 0.9, 0, 1.08, 0.15, 1.89], ["c", 0.06, 0.45, 0.06, 0.48, 0.03, 0.6], ["c", -0.06, 0.09, -0.21, 0.21, -0.3, 0.21], ["c", -0.03, 0, -0.27, -0.06, -0.54, -0.15], ["c", -0.84, -0.27, -1.11, -0.3, -1.65, -0.3], ["c", -0.57, 0, -0.84, 0.03, -1.56, 0.27], ["c", -0.6, 0.18, -0.69, 0.21, -0.81, 0.15], ["c", -0.12, -0.06, -0.21, -0.18, -0.21, -0.3], ["c", 0, -0.15, 0.6, -1.44, 1.2, -2.61], ["c", 1.14, -2.22, 2.73, -4.68, 5.1, -8.01], ["c", 0.21, -0.27, 0.36, -0.48, 0.33, -0.48], ["c", 0, 0, -0.12, 0.06, -0.27, 0.12], ["c", -0.54, 0.3, -0.99, 0.39, -1.56, 0.39], ["c", -0.75, 0.03, -1.2, -0.18, -1.83, -0.75], ["c", -0.99, -0.9, -1.83, -1.17, -2.31, -0.72], ["c", -0.18, 0.15, -0.36, 0.51, -0.45, 0.84], ["c", -0.06, 0.24, -0.06, 0.33, -0.09, 1.98], ["c", 0, 1.62, -0.03, 1.74, -0.06, 1.8], ["c", -0.15, 0.24, -0.54, 0.24, -0.69, 0], ["c", -0.06, -0.09, -0.06, -0.15, -0.06, -3.57], ["c", 0, -3.42, 0, -3.48, 0.06, -3.57], ["c", 0.03, -0.06, 0.09, -0.12, 0.15, -0.15], ["z"]], w: 10.561, h: 15.093 },
      "8": { d: [["M", 4.98, -14.97], ["c", 0.33, -0.03, 1.02, -0.03, 1.32, 0], ["c", 1.32, 0.12, 2.49, 0.6, 3.21, 1.32], ["c", 0.39, 0.39, 0.66, 0.81, 0.78, 1.29], ["c", 0.09, 0.36, 0.09, 1.08, 0, 1.44], ["c", -0.21, 0.84, -0.66, 1.59, -1.59, 2.55], ["l", -0.3, 0.3], ["l", 0.27, 0.18], ["c", 1.47, 0.93, 2.31, 2.31, 2.25, 3.75], ["c", -0.03, 0.75, -0.24, 1.35, -0.63, 1.95], ["c", -0.45, 0.66, -1.02, 1.14, -1.83, 1.53], ["c", -1.8, 0.87, -4.2, 0.87, -6, 0.03], ["c", -1.62, -0.78, -2.52, -2.16, -2.46, -3.66], ["c", 0.06, -0.99, 0.54, -1.77, 1.8, -2.97], ["c", 0.54, -0.51, 0.54, -0.54, 0.48, -0.57], ["c", -0.39, -0.27, -0.96, -0.78, -1.2, -1.14], ["c", -0.75, -1.11, -0.87, -2.4, -0.3, -3.6], ["c", 0.69, -1.35, 2.25, -2.25, 4.2, -2.4], ["z"], ["m", 1.53, 0.69], ["c", -0.42, -0.09, -1.11, -0.12, -1.38, -0.06], ["c", -0.3, 0.06, -0.6, 0.18, -0.81, 0.3], ["c", -0.21, 0.12, -0.6, 0.51, -0.72, 0.72], ["c", -0.51, 0.87, -0.42, 1.89, 0.21, 2.52], ["c", 0.21, 0.21, 0.36, 0.3, 1.95, 1.23], ["c", 0.96, 0.54, 1.74, 0.99, 1.77, 1.02], ["c", 0.09, 0, 0.63, -0.6, 0.99, -1.11], ["c", 0.21, -0.36, 0.48, -0.87, 0.57, -1.23], ["c", 0.06, -0.24, 0.06, -0.36, 0.06, -0.72], ["c", 0, -0.45, -0.03, -0.66, -0.15, -0.99], ["c", -0.39, -0.81, -1.29, -1.44, -2.49, -1.68], ["z"], ["m", -1.44, 8.07], ["l", -1.89, -1.08], ["c", -0.03, 0, -0.18, 0.15, -0.39, 0.33], ["c", -1.2, 1.08, -1.65, 1.95, -1.59, 3], ["c", 0.09, 1.59, 1.35, 2.85, 3.21, 3.24], ["c", 0.33, 0.06, 0.45, 0.06, 0.93, 0.06], ["c", 0.63, 0, 0.81, -0.03, 1.29, -0.27], ["c", 0.9, -0.42, 1.47, -1.41, 1.41, -2.4], ["c", -0.06, -0.66, -0.39, -1.29, -0.9, -1.65], ["c", -0.12, -0.09, -1.05, -0.63, -2.07, -1.23], ["z"]], w: 10.926, h: 14.989 },
      "9": { d: [["M", 4.23, -14.97], ["c", 0.42, -0.03, 1.29, 0, 1.62, 0.06], ["c", 0.51, 0.12, 0.93, 0.3, 1.38, 0.57], ["c", 1.53, 1.02, 2.52, 3.24, 2.73, 5.94], ["c", 0.18, 2.55, -0.48, 4.98, -1.83, 6.57], ["c", -1.05, 1.26, -2.4, 1.89, -3.93, 1.83], ["c", -1.23, -0.06, -2.31, -0.45, -3.03, -1.14], ["c", -0.57, -0.51, -0.87, -1.23, -0.84, -1.98], ["c", 0.03, -0.51, 0.21, -0.9, 0.6, -1.26], ["c", 0.24, -0.24, 0.45, -0.39, 0.75, -0.51], ["c", 0.21, -0.06, 0.27, -0.06, 0.6, -0.06], ["c", 0.33, 0, 0.39, 0, 0.6, 0.06], ["c", 0.3, 0.12, 0.51, 0.27, 0.75, 0.51], ["c", 0.39, 0.36, 0.57, 0.78, 0.57, 1.26], ["c", 0, 0.27, 0, 0.3, -0.09, 0.42], ["c", -0.03, 0.09, -0.18, 0.21, -0.3, 0.3], ["c", -0.12, 0.09, -0.3, 0.21, -0.39, 0.27], ["c", -0.09, 0.06, -0.21, 0.18, -0.27, 0.24], ["c", -0.06, 0.12, -0.06, 0.15, -0.06, 0.33], ["c", 0, 0.18, 0, 0.24, 0.06, 0.36], ["c", 0.24, 0.39, 0.75, 0.6, 1.38, 0.57], ["c", 0.54, -0.03, 0.9, -0.18, 1.23, -0.48], ["c", 0.81, -0.72, 1.08, -2.16, 0.96, -5.37], ["l", 0, -0.63], ["l", -0.3, 0.12], ["c", -0.78, 0.27, -1.29, 0.33, -2.1, 0.27], ["c", -1.47, -0.12, -2.49, -0.54, -3.27, -1.29], ["c", -0.48, -0.51, -0.81, -1.11, -0.96, -1.89], ["c", -0.06, -0.27, -0.06, -0.42, -0.06, -0.96], ["c", 0, -0.51, 0, -0.66, 0.06, -0.93], ["c", 0.15, -0.78, 0.48, -1.38, 0.96, -1.89], ["c", 0.15, -0.12, 0.33, -0.27, 0.42, -0.36], ["c", 0.69, -0.51, 1.62, -0.81, 2.76, -0.93], ["z"], ["m", 1.17, 0.66], ["c", -0.21, -0.06, -0.57, -0.06, -0.81, -0.03], ["c", -0.78, 0.12, -1.26, 0.69, -1.41, 1.74], ["c", -0.12, 0.63, -0.15, 1.95, -0.09, 2.79], ["c", 0.12, 1.71, 0.63, 2.4, 1.77, 2.46], ["c", 1.08, 0.03, 1.62, -0.48, 1.8, -1.74], ["c", 0.06, -0.54, 0.06, -3, 0, -3.54], ["c", -0.15, -1.05, -0.51, -1.53, -1.26, -1.68], ["z"]], w: 9.959, h: 14.986 },
      "rests.multimeasure": { d: [["M", 0, -4], ["l", 0, 16], ["l", 1, 0], ["l", 0, -5], ["l", 40, 0], ["l", 0, 5], ["l", 1, 0], ["l", 0, -16], ["l", -1, 0], ["l", 0, 5], ["l", -40, 0], ["l", 0, -5], ["z"]], w: 42, h: 18 },
      "rests.whole": { d: [["M", 0.06, 0.03], ["l", 0.09, -0.06], ["l", 5.46, 0], ["l", 5.49, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 2.19], ["l", 0, 2.19], ["l", -0.06, 0.09], ["l", -0.09, 0.06], ["l", -5.49, 0], ["l", -5.46, 0], ["l", -0.09, -0.06], ["l", -0.06, -0.09], ["l", 0, -2.19], ["l", 0, -2.19], ["z"]], w: 11.25, h: 4.68 },
      "rests.half": { d: [["M", 0.06, -4.62], ["l", 0.09, -0.06], ["l", 5.46, 0], ["l", 5.49, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 2.19], ["l", 0, 2.19], ["l", -0.06, 0.09], ["l", -0.09, 0.06], ["l", -5.49, 0], ["l", -5.46, 0], ["l", -0.09, -0.06], ["l", -0.06, -0.09], ["l", 0, -2.19], ["l", 0, -2.19], ["z"]], w: 11.25, h: 4.68 },
      "rests.quarter": { d: [["M", 1.89, -11.82], ["c", 0.12, -0.06, 0.24, -0.06, 0.36, -0.03], ["c", 0.09, 0.06, 4.74, 5.58, 4.86, 5.82], ["c", 0.21, 0.39, 0.15, 0.78, -0.15, 1.26], ["c", -0.24, 0.33, -0.72, 0.81, -1.62, 1.56], ["c", -0.45, 0.36, -0.87, 0.75, -0.96, 0.84], ["c", -0.93, 0.99, -1.14, 2.49, -0.6, 3.63], ["c", 0.18, 0.39, 0.27, 0.48, 1.32, 1.68], ["c", 1.92, 2.25, 1.83, 2.16, 1.83, 2.34], ["c", 0, 0.18, -0.18, 0.36, -0.36, 0.39], ["c", -0.15, 0, -0.27, -0.06, -0.48, -0.27], ["c", -0.75, -0.75, -2.46, -1.29, -3.39, -1.08], ["c", -0.45, 0.09, -0.69, 0.27, -0.9, 0.69], ["c", -0.12, 0.3, -0.21, 0.66, -0.24, 1.14], ["c", -0.03, 0.66, 0.09, 1.35, 0.3, 2.01], ["c", 0.15, 0.42, 0.24, 0.66, 0.45, 0.96], ["c", 0.18, 0.24, 0.18, 0.33, 0.03, 0.42], ["c", -0.12, 0.06, -0.18, 0.03, -0.45, -0.3], ["c", -1.08, -1.38, -2.07, -3.36, -2.4, -4.83], ["c", -0.27, -1.05, -0.15, -1.77, 0.27, -2.07], ["c", 0.21, -0.12, 0.42, -0.15, 0.87, -0.15], ["c", 0.87, 0.06, 2.1, 0.39, 3.3, 0.9], ["l", 0.39, 0.18], ["l", -1.65, -1.95], ["c", -2.52, -2.97, -2.61, -3.09, -2.7, -3.27], ["c", -0.09, -0.24, -0.12, -0.48, -0.03, -0.75], ["c", 0.15, -0.48, 0.57, -0.96, 1.83, -2.01], ["c", 0.45, -0.36, 0.84, -0.72, 0.93, -0.78], ["c", 0.69, -0.75, 1.02, -1.8, 0.9, -2.79], ["c", -0.06, -0.33, -0.21, -0.84, -0.39, -1.11], ["c", -0.09, -0.15, -0.45, -0.6, -0.81, -1.05], ["c", -0.36, -0.42, -0.69, -0.81, -0.72, -0.87], ["c", -0.09, -0.18, 0, -0.42, 0.21, -0.51], ["z"]], w: 7.888, h: 21.435 },
      "rests.8th": { d: [["M", 1.68, -6.12], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.6, 0.48], ["c", 0.12, 0, 0.18, 0, 0.33, -0.09], ["c", 0.39, -0.18, 1.32, -1.29, 1.68, -1.98], ["c", 0.09, -0.21, 0.24, -0.3, 0.39, -0.3], ["c", 0.12, 0, 0.27, 0.09, 0.33, 0.18], ["c", 0.03, 0.06, -0.27, 1.11, -1.86, 6.42], ["c", -1.02, 3.48, -1.89, 6.39, -1.92, 6.42], ["c", 0, 0.03, -0.12, 0.12, -0.24, 0.15], ["c", -0.18, 0.09, -0.21, 0.09, -0.45, 0.09], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.15, -0.57, 1.68, -4.92], ["c", 0.96, -2.67, 1.74, -4.89, 1.71, -4.89], ["l", -0.51, 0.15], ["c", -1.08, 0.36, -1.74, 0.48, -2.55, 0.48], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], w: 7.534, h: 13.883 },
      "rests.16th": { d: [["M", 3.33, -6.12], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.15, 0.39, 0.57, 0.57, 0.87, 0.42], ["c", 0.39, -0.18, 1.2, -1.23, 1.62, -2.07], ["c", 0.06, -0.15, 0.24, -0.24, 0.36, -0.24], ["c", 0.12, 0, 0.27, 0.09, 0.33, 0.18], ["c", 0.03, 0.06, -0.45, 1.86, -2.67, 10.17], ["c", -1.5, 5.55, -2.73, 10.14, -2.76, 10.17], ["c", -0.03, 0.03, -0.12, 0.12, -0.24, 0.15], ["c", -0.18, 0.09, -0.21, 0.09, -0.45, 0.09], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.12, -0.57, 1.44, -4.92], ["c", 0.81, -2.67, 1.47, -4.86, 1.47, -4.89], ["c", -0.03, 0, -0.27, 0.06, -0.54, 0.15], ["c", -1.08, 0.36, -1.77, 0.48, -2.58, 0.48], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.72, -1.05, 2.22, -1.23, 3.06, -0.42], ["c", 0.3, 0.33, 0.42, 0.6, 0.6, 1.38], ["c", 0.09, 0.45, 0.21, 0.78, 0.33, 0.9], ["c", 0.09, 0.09, 0.27, 0.18, 0.45, 0.21], ["c", 0.12, 0, 0.18, 0, 0.33, -0.09], ["c", 0.33, -0.15, 1.02, -0.93, 1.41, -1.59], ["c", 0.12, -0.21, 0.18, -0.39, 0.39, -1.08], ["c", 0.66, -2.1, 1.17, -3.84, 1.17, -3.87], ["c", 0, 0, -0.21, 0.06, -0.42, 0.15], ["c", -0.51, 0.15, -1.2, 0.33, -1.68, 0.42], ["c", -0.33, 0.06, -0.51, 0.06, -0.96, 0.06], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], w: 9.724, h: 21.383 },
      "rests.32nd": { d: [["M", 4.23, -13.62], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.6, 0.48], ["c", 0.12, 0, 0.18, 0, 0.27, -0.06], ["c", 0.33, -0.21, 0.99, -1.11, 1.44, -1.98], ["c", 0.09, -0.24, 0.21, -0.33, 0.39, -0.33], ["c", 0.12, 0, 0.27, 0.09, 0.33, 0.18], ["c", 0.03, 0.06, -0.57, 2.67, -3.21, 13.89], ["c", -1.8, 7.62, -3.3, 13.89, -3.3, 13.92], ["c", -0.03, 0.06, -0.12, 0.12, -0.24, 0.18], ["c", -0.21, 0.09, -0.24, 0.09, -0.48, 0.09], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.09, -0.57, 1.23, -4.92], ["c", 0.69, -2.67, 1.26, -4.86, 1.29, -4.89], ["c", 0, -0.03, -0.12, -0.03, -0.48, 0.12], ["c", -1.17, 0.39, -2.22, 0.57, -3, 0.54], ["c", -0.42, -0.03, -0.75, -0.12, -1.11, -0.3], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.72, -1.05, 2.22, -1.23, 3.06, -0.42], ["c", 0.3, 0.33, 0.42, 0.6, 0.6, 1.38], ["c", 0.09, 0.45, 0.21, 0.78, 0.33, 0.9], ["c", 0.12, 0.09, 0.3, 0.18, 0.48, 0.21], ["c", 0.12, 0, 0.18, 0, 0.3, -0.09], ["c", 0.42, -0.21, 1.29, -1.29, 1.56, -1.89], ["c", 0.03, -0.12, 1.23, -4.59, 1.23, -4.65], ["c", 0, -0.03, -0.18, 0.03, -0.39, 0.12], ["c", -0.63, 0.18, -1.2, 0.36, -1.74, 0.45], ["c", -0.39, 0.06, -0.54, 0.06, -1.02, 0.06], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.72, -1.05, 2.22, -1.23, 3.06, -0.42], ["c", 0.3, 0.33, 0.42, 0.6, 0.6, 1.38], ["c", 0.09, 0.45, 0.21, 0.78, 0.33, 0.9], ["c", 0.18, 0.18, 0.51, 0.27, 0.72, 0.15], ["c", 0.3, -0.12, 0.69, -0.57, 1.08, -1.17], ["c", 0.42, -0.6, 0.39, -0.51, 1.05, -3.03], ["c", 0.33, -1.26, 0.6, -2.31, 0.6, -2.34], ["c", 0, 0, -0.21, 0.03, -0.45, 0.12], ["c", -0.57, 0.18, -1.14, 0.33, -1.62, 0.42], ["c", -0.33, 0.06, -0.51, 0.06, -0.96, 0.06], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], w: 11.373, h: 28.883 },
      "rests.64th": { d: [["M", 5.13, -13.62], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.15, 0.63, 0.21, 0.81, 0.33, 0.96], ["c", 0.18, 0.21, 0.54, 0.3, 0.75, 0.18], ["c", 0.24, -0.12, 0.63, -0.66, 1.08, -1.56], ["c", 0.33, -0.66, 0.39, -0.72, 0.6, -0.72], ["c", 0.12, 0, 0.27, 0.09, 0.33, 0.18], ["c", 0.03, 0.06, -0.69, 3.66, -3.54, 17.64], ["c", -1.95, 9.66, -3.57, 17.61, -3.57, 17.64], ["c", -0.03, 0.06, -0.12, 0.12, -0.24, 0.18], ["c", -0.21, 0.09, -0.24, 0.09, -0.48, 0.09], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.06, -0.57, 1.05, -4.95], ["c", 0.6, -2.7, 1.08, -4.89, 1.08, -4.92], ["c", 0, 0, -0.24, 0.06, -0.51, 0.15], ["c", -0.66, 0.24, -1.2, 0.36, -1.77, 0.48], ["c", -0.42, 0.06, -0.57, 0.06, -1.05, 0.06], ["c", -0.69, 0, -0.87, -0.03, -1.35, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.72, -1.05, 2.22, -1.23, 3.06, -0.42], ["c", 0.3, 0.33, 0.42, 0.6, 0.6, 1.38], ["c", 0.09, 0.45, 0.21, 0.78, 0.33, 0.9], ["c", 0.09, 0.09, 0.27, 0.18, 0.45, 0.21], ["c", 0.21, 0.03, 0.39, -0.09, 0.72, -0.42], ["c", 0.45, -0.45, 1.02, -1.26, 1.17, -1.65], ["c", 0.03, -0.09, 0.27, -1.14, 0.54, -2.34], ["c", 0.27, -1.2, 0.48, -2.19, 0.51, -2.22], ["c", 0, -0.03, -0.09, -0.03, -0.48, 0.12], ["c", -1.17, 0.39, -2.22, 0.57, -3, 0.54], ["c", -0.42, -0.03, -0.75, -0.12, -1.11, -0.3], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.15, 0.39, 0.57, 0.57, 0.9, 0.42], ["c", 0.36, -0.18, 1.2, -1.26, 1.47, -1.89], ["c", 0.03, -0.09, 0.3, -1.2, 0.57, -2.43], ["l", 0.51, -2.28], ["l", -0.54, 0.18], ["c", -1.11, 0.36, -1.8, 0.48, -2.61, 0.48], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.15, 0.63, 0.21, 0.81, 0.33, 0.96], ["c", 0.21, 0.21, 0.54, 0.3, 0.75, 0.18], ["c", 0.36, -0.18, 0.93, -0.93, 1.29, -1.68], ["c", 0.12, -0.24, 0.18, -0.48, 0.63, -2.55], ["l", 0.51, -2.31], ["c", 0, -0.03, -0.18, 0.03, -0.39, 0.12], ["c", -1.14, 0.36, -2.1, 0.54, -2.82, 0.51], ["c", -0.42, -0.03, -0.75, -0.12, -1.11, -0.3], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], w: 12.453, h: 36.383 },
      "rests.128th": { d: [["M", 6.03, -21.12], ["c", 0.66, -0.09, 1.23, 0.09, 1.68, 0.51], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.6, 0.48], ["c", 0.21, 0, 0.33, -0.06, 0.54, -0.36], ["c", 0.15, -0.21, 0.54, -0.93, 0.78, -1.47], ["c", 0.15, -0.33, 0.18, -0.39, 0.3, -0.48], ["c", 0.18, -0.09, 0.45, 0, 0.51, 0.15], ["c", 0.03, 0.09, -7.11, 42.75, -7.17, 42.84], ["c", -0.03, 0.03, -0.15, 0.09, -0.24, 0.15], ["c", -0.18, 0.06, -0.24, 0.06, -0.45, 0.06], ["c", -0.24, 0, -0.3, 0, -0.48, -0.06], ["c", -0.09, -0.06, -0.21, -0.12, -0.21, -0.15], ["c", -0.06, -0.03, 0.03, -0.57, 0.84, -4.98], ["c", 0.51, -2.7, 0.93, -4.92, 0.9, -4.92], ["c", 0, 0, -0.15, 0.06, -0.36, 0.12], ["c", -0.78, 0.27, -1.62, 0.48, -2.31, 0.57], ["c", -0.15, 0.03, -0.54, 0.03, -0.81, 0.03], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.63, 0.48], ["c", 0.12, 0, 0.18, 0, 0.3, -0.09], ["c", 0.42, -0.21, 1.14, -1.11, 1.5, -1.83], ["c", 0.12, -0.27, 0.12, -0.27, 0.54, -2.52], ["c", 0.24, -1.23, 0.42, -2.25, 0.39, -2.25], ["c", 0, 0, -0.24, 0.06, -0.51, 0.18], ["c", -1.26, 0.39, -2.25, 0.57, -3.06, 0.54], ["c", -0.42, -0.03, -0.75, -0.12, -1.11, -0.3], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.15, 0.63, 0.21, 0.81, 0.33, 0.96], ["c", 0.18, 0.21, 0.51, 0.3, 0.75, 0.18], ["c", 0.36, -0.15, 1.05, -0.99, 1.41, -1.77], ["l", 0.15, -0.3], ["l", 0.42, -2.25], ["c", 0.21, -1.26, 0.42, -2.28, 0.39, -2.28], ["l", -0.51, 0.15], ["c", -1.11, 0.39, -1.89, 0.51, -2.7, 0.51], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.15, 0.63, 0.21, 0.81, 0.33, 0.96], ["c", 0.18, 0.18, 0.48, 0.27, 0.72, 0.21], ["c", 0.33, -0.12, 1.14, -1.26, 1.41, -1.95], ["c", 0, -0.09, 0.21, -1.11, 0.45, -2.34], ["c", 0.21, -1.2, 0.39, -2.22, 0.39, -2.28], ["c", 0.03, -0.03, 0, -0.03, -0.45, 0.12], ["c", -0.57, 0.18, -1.2, 0.33, -1.71, 0.42], ["c", -0.3, 0.06, -0.51, 0.06, -0.93, 0.06], ["c", -0.66, 0, -0.84, -0.03, -1.32, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.36, -0.54, 0.96, -0.87, 1.65, -0.93], ["c", 0.54, -0.03, 1.02, 0.15, 1.41, 0.54], ["c", 0.27, 0.3, 0.39, 0.54, 0.57, 1.26], ["c", 0.09, 0.33, 0.18, 0.66, 0.21, 0.72], ["c", 0.12, 0.27, 0.33, 0.45, 0.6, 0.48], ["c", 0.18, 0, 0.36, -0.09, 0.57, -0.33], ["c", 0.33, -0.36, 0.78, -1.14, 0.93, -1.56], ["c", 0.03, -0.12, 0.24, -1.2, 0.45, -2.4], ["c", 0.24, -1.2, 0.42, -2.22, 0.42, -2.28], ["c", 0.03, -0.03, 0, -0.03, -0.39, 0.09], ["c", -1.05, 0.36, -1.8, 0.48, -2.58, 0.48], ["c", -0.63, 0, -0.84, -0.03, -1.29, -0.27], ["c", -1.32, -0.63, -1.77, -2.16, -1.02, -3.3], ["c", 0.33, -0.45, 0.84, -0.81, 1.38, -0.9], ["z"]], w: 12.992, h: 43.883 },
      "accidentals.sharp": { d: [["M", 5.73, -11.19], ["c", 0.21, -0.12, 0.54, -0.03, 0.66, 0.24], ["c", 0.06, 0.12, 0.06, 0.21, 0.06, 2.31], ["c", 0, 1.23, 0, 2.22, 0.03, 2.22], ["c", 0, 0, 0.27, -0.12, 0.6, -0.24], ["c", 0.69, -0.27, 0.78, -0.3, 0.96, -0.15], ["c", 0.21, 0.15, 0.21, 0.18, 0.21, 1.38], ["c", 0, 1.02, 0, 1.11, -0.06, 1.2], ["c", -0.03, 0.06, -0.09, 0.12, -0.12, 0.15], ["c", -0.06, 0.03, -0.42, 0.21, -0.84, 0.36], ["l", -0.75, 0.33], ["l", -0.03, 2.43], ["c", 0, 1.32, 0, 2.43, 0.03, 2.43], ["c", 0, 0, 0.27, -0.12, 0.6, -0.24], ["c", 0.69, -0.27, 0.78, -0.3, 0.96, -0.15], ["c", 0.21, 0.15, 0.21, 0.18, 0.21, 1.38], ["c", 0, 1.02, 0, 1.11, -0.06, 1.2], ["c", -0.03, 0.06, -0.09, 0.12, -0.12, 0.15], ["c", -0.06, 0.03, -0.42, 0.21, -0.84, 0.36], ["l", -0.75, 0.33], ["l", -0.03, 2.52], ["c", 0, 2.28, -0.03, 2.55, -0.06, 2.64], ["c", -0.21, 0.36, -0.72, 0.36, -0.93, 0], ["c", -0.03, -0.09, -0.06, -0.33, -0.06, -2.43], ["l", 0, -2.31], ["l", -1.29, 0.51], ["l", -1.26, 0.51], ["l", 0, 2.43], ["c", 0, 2.58, 0, 2.52, -0.15, 2.67], ["c", -0.06, 0.09, -0.27, 0.18, -0.36, 0.18], ["c", -0.12, 0, -0.33, -0.09, -0.39, -0.18], ["c", -0.15, -0.15, -0.15, -0.09, -0.15, -2.43], ["c", 0, -1.23, 0, -2.22, -0.03, -2.22], ["c", 0, 0, -0.27, 0.12, -0.6, 0.24], ["c", -0.69, 0.27, -0.78, 0.3, -0.96, 0.15], ["c", -0.21, -0.15, -0.21, -0.18, -0.21, -1.38], ["c", 0, -1.02, 0, -1.11, 0.06, -1.2], ["c", 0.03, -0.06, 0.09, -0.12, 0.12, -0.15], ["c", 0.06, -0.03, 0.42, -0.21, 0.84, -0.36], ["l", 0.78, -0.33], ["l", 0, -2.43], ["c", 0, -1.32, 0, -2.43, -0.03, -2.43], ["c", 0, 0, -0.27, 0.12, -0.6, 0.24], ["c", -0.69, 0.27, -0.78, 0.3, -0.96, 0.15], ["c", -0.21, -0.15, -0.21, -0.18, -0.21, -1.38], ["c", 0, -1.02, 0, -1.11, 0.06, -1.2], ["c", 0.03, -0.06, 0.09, -0.12, 0.12, -0.15], ["c", 0.06, -0.03, 0.42, -0.21, 0.84, -0.36], ["l", 0.78, -0.33], ["l", 0, -2.52], ["c", 0, -2.28, 0.03, -2.55, 0.06, -2.64], ["c", 0.21, -0.36, 0.72, -0.36, 0.93, 0], ["c", 0.03, 0.09, 0.06, 0.33, 0.06, 2.43], ["l", 0.03, 2.31], ["l", 1.26, -0.51], ["l", 1.26, -0.51], ["l", 0, -2.43], ["c", 0, -2.28, 0, -2.43, 0.06, -2.55], ["c", 0.06, -0.12, 0.12, -0.18, 0.27, -0.24], ["z"], ["m", -0.33, 10.65], ["l", 0, -2.43], ["l", -1.29, 0.51], ["l", -1.26, 0.51], ["l", 0, 2.46], ["l", 0, 2.43], ["l", 0.09, -0.03], ["c", 0.06, -0.03, 0.63, -0.27, 1.29, -0.51], ["l", 1.17, -0.48], ["l", 0, -2.46], ["z"]], w: 8.25, h: 22.462 },
      "accidentals.halfsharp": { d: [["M", 2.43, -10.05], ["c", 0.21, -0.12, 0.54, -0.03, 0.66, 0.24], ["c", 0.06, 0.12, 0.06, 0.21, 0.06, 2.01], ["c", 0, 1.05, 0, 1.89, 0.03, 1.89], ["l", 0.72, -0.48], ["c", 0.69, -0.48, 0.69, -0.51, 0.87, -0.51], ["c", 0.15, 0, 0.18, 0.03, 0.27, 0.09], ["c", 0.21, 0.15, 0.21, 0.18, 0.21, 1.41], ["c", 0, 1.11, -0.03, 1.14, -0.09, 1.23], ["c", -0.03, 0.03, -0.48, 0.39, -1.02, 0.75], ["l", -0.99, 0.66], ["l", 0, 2.37], ["c", 0, 1.32, 0, 2.37, 0.03, 2.37], ["l", 0.72, -0.48], ["c", 0.69, -0.48, 0.69, -0.51, 0.87, -0.51], ["c", 0.15, 0, 0.18, 0.03, 0.27, 0.09], ["c", 0.21, 0.15, 0.21, 0.18, 0.21, 1.41], ["c", 0, 1.11, -0.03, 1.14, -0.09, 1.23], ["c", -0.03, 0.03, -0.48, 0.39, -1.02, 0.75], ["l", -0.99, 0.66], ["l", 0, 2.25], ["c", 0, 1.95, 0, 2.28, -0.06, 2.37], ["c", -0.06, 0.12, -0.12, 0.21, -0.24, 0.27], ["c", -0.27, 0.12, -0.54, 0.03, -0.69, -0.24], ["c", -0.06, -0.12, -0.06, -0.21, -0.06, -2.01], ["c", 0, -1.05, 0, -1.89, -0.03, -1.89], ["l", -0.72, 0.48], ["c", -0.69, 0.48, -0.69, 0.48, -0.87, 0.48], ["c", -0.15, 0, -0.18, 0, -0.27, -0.06], ["c", -0.21, -0.15, -0.21, -0.18, -0.21, -1.41], ["c", 0, -1.11, 0.03, -1.14, 0.09, -1.23], ["c", 0.03, -0.03, 0.48, -0.39, 1.02, -0.75], ["l", 0.99, -0.66], ["l", 0, -2.37], ["c", 0, -1.32, 0, -2.37, -0.03, -2.37], ["l", -0.72, 0.48], ["c", -0.69, 0.48, -0.69, 0.48, -0.87, 0.48], ["c", -0.15, 0, -0.18, 0, -0.27, -0.06], ["c", -0.21, -0.15, -0.21, -0.18, -0.21, -1.41], ["c", 0, -1.11, 0.03, -1.14, 0.09, -1.23], ["c", 0.03, -0.03, 0.48, -0.39, 1.02, -0.75], ["l", 0.99, -0.66], ["l", 0, -2.25], ["c", 0, -2.13, 0, -2.28, 0.06, -2.4], ["c", 0.06, -0.12, 0.12, -0.18, 0.27, -0.24], ["z"]], w: 5.25, h: 20.174 },
      "accidentals.nat": { d: [["M", 0.21, -11.4], ["c", 0.24, -0.06, 0.78, 0, 0.99, 0.15], ["c", 0.03, 0.03, 0.03, 0.48, 0, 2.61], ["c", -0.03, 1.44, -0.03, 2.61, -0.03, 2.61], ["c", 0, 0.03, 0.75, -0.09, 1.68, -0.24], ["c", 0.96, -0.18, 1.71, -0.27, 1.74, -0.27], ["c", 0.15, 0.03, 0.27, 0.15, 0.36, 0.3], ["l", 0.06, 0.12], ["l", 0.09, 8.67], ["c", 0.09, 6.96, 0.12, 8.67, 0.09, 8.67], ["c", -0.03, 0.03, -0.12, 0.06, -0.21, 0.09], ["c", -0.24, 0.09, -0.72, 0.09, -0.96, 0], ["c", -0.09, -0.03, -0.18, -0.06, -0.21, -0.09], ["c", -0.03, -0.03, -0.03, -0.48, 0, -2.61], ["c", 0.03, -1.44, 0.03, -2.61, 0.03, -2.61], ["c", 0, -0.03, -0.75, 0.09, -1.68, 0.24], ["c", -0.96, 0.18, -1.71, 0.27, -1.74, 0.27], ["c", -0.15, -0.03, -0.27, -0.15, -0.36, -0.3], ["l", -0.06, -0.15], ["l", -0.09, -7.53], ["c", -0.06, -4.14, -0.09, -8.04, -0.12, -8.67], ["l", 0, -1.11], ["l", 0.15, -0.06], ["c", 0.09, -0.03, 0.21, -0.06, 0.27, -0.09], ["z"], ["m", 3.75, 8.4], ["c", 0, -0.33, 0, -0.42, -0.03, -0.42], ["c", -0.12, 0, -2.79, 0.45, -2.79, 0.48], ["c", -0.03, 0, -0.09, 6.3, -0.09, 6.33], ["c", 0.03, 0, 2.79, -0.45, 2.82, -0.48], ["c", 0, 0, 0.09, -4.53, 0.09, -5.91], ["z"]], w: 5.4, h: 22.8 },
      "accidentals.flat": { d: [["M", -0.36, -14.07], ["c", 0.33, -0.06, 0.87, 0, 1.08, 0.15], ["c", 0.06, 0.03, 0.06, 0.36, -0.03, 5.25], ["c", -0.06, 2.85, -0.09, 5.19, -0.09, 5.19], ["c", 0, 0.03, 0.12, -0.03, 0.24, -0.12], ["c", 0.63, -0.42, 1.41, -0.66, 2.19, -0.72], ["c", 0.81, -0.03, 1.47, 0.21, 2.04, 0.78], ["c", 0.57, 0.54, 0.87, 1.26, 0.93, 2.04], ["c", 0.03, 0.57, -0.09, 1.08, -0.36, 1.62], ["c", -0.42, 0.81, -1.02, 1.38, -2.82, 2.61], ["c", -1.14, 0.78, -1.44, 1.02, -1.8, 1.44], ["c", -0.18, 0.18, -0.39, 0.39, -0.45, 0.42], ["c", -0.27, 0.18, -0.57, 0.15, -0.81, -0.06], ["c", -0.06, -0.09, -0.12, -0.18, -0.15, -0.27], ["c", -0.03, -0.06, -0.09, -3.27, -0.18, -8.34], ["c", -0.09, -4.53, -0.15, -8.58, -0.18, -9.03], ["l", 0, -0.78], ["l", 0.12, -0.06], ["c", 0.06, -0.03, 0.18, -0.09, 0.27, -0.12], ["z"], ["m", 3.18, 11.01], ["c", -0.21, -0.12, -0.54, -0.15, -0.81, -0.06], ["c", -0.54, 0.15, -0.99, 0.63, -1.17, 1.26], ["c", -0.06, 0.3, -0.12, 2.88, -0.06, 3.87], ["c", 0.03, 0.42, 0.03, 0.81, 0.06, 0.9], ["l", 0.03, 0.12], ["l", 0.45, -0.39], ["c", 0.63, -0.54, 1.26, -1.17, 1.56, -1.59], ["c", 0.3, -0.42, 0.6, -0.99, 0.72, -1.41], ["c", 0.18, -0.69, 0.09, -1.47, -0.18, -2.07], ["c", -0.15, -0.3, -0.33, -0.51, -0.6, -0.63], ["z"]], w: 6.75, h: 18.801 },
      "accidentals.halfflat": { d: [["M", 4.83, -14.07], ["c", 0.33, -0.06, 0.87, 0, 1.08, 0.15], ["c", 0.06, 0.03, 0.06, 0.6, -0.12, 9.06], ["c", -0.09, 5.55, -0.15, 9.06, -0.18, 9.12], ["c", -0.03, 0.09, -0.09, 0.18, -0.15, 0.27], ["c", -0.24, 0.21, -0.54, 0.24, -0.81, 0.06], ["c", -0.06, -0.03, -0.27, -0.24, -0.45, -0.42], ["c", -0.36, -0.42, -0.66, -0.66, -1.8, -1.44], ["c", -1.23, -0.84, -1.83, -1.32, -2.25, -1.77], ["c", -0.66, -0.78, -0.96, -1.56, -0.93, -2.46], ["c", 0.09, -1.41, 1.11, -2.58, 2.4, -2.79], ["c", 0.3, -0.06, 0.84, -0.03, 1.23, 0.06], ["c", 0.54, 0.12, 1.08, 0.33, 1.53, 0.63], ["c", 0.12, 0.09, 0.24, 0.15, 0.24, 0.12], ["c", 0, 0, -0.12, -8.37, -0.18, -9.75], ["l", 0, -0.66], ["l", 0.12, -0.06], ["c", 0.06, -0.03, 0.18, -0.09, 0.27, -0.12], ["z"], ["m", -1.65, 10.95], ["c", -0.6, -0.18, -1.08, 0.09, -1.38, 0.69], ["c", -0.27, 0.6, -0.36, 1.38, -0.18, 2.07], ["c", 0.12, 0.42, 0.42, 0.99, 0.72, 1.41], ["c", 0.3, 0.42, 0.93, 1.05, 1.56, 1.59], ["l", 0.48, 0.39], ["l", 0, -0.12], ["c", 0.03, -0.09, 0.03, -0.48, 0.06, -0.9], ["c", 0.03, -0.57, 0.03, -1.08, 0, -2.22], ["c", -0.03, -1.62, -0.03, -1.62, -0.24, -2.07], ["c", -0.21, -0.42, -0.6, -0.75, -1.02, -0.84], ["z"]], w: 6.728, h: 18.801 },
      "accidentals.dblflat": { d: [["M", -0.36, -14.07], ["c", 0.33, -0.06, 0.87, 0, 1.08, 0.15], ["c", 0.06, 0.03, 0.06, 0.33, -0.03, 4.89], ["c", -0.06, 2.67, -0.09, 5.01, -0.09, 5.22], ["l", 0, 0.36], ["l", 0.15, -0.15], ["c", 0.36, -0.3, 0.75, -0.51, 1.2, -0.63], ["c", 0.33, -0.09, 0.96, -0.09, 1.26, -0.03], ["c", 0.27, 0.09, 0.63, 0.27, 0.87, 0.45], ["l", 0.21, 0.15], ["l", 0, -0.27], ["c", 0, -0.15, -0.03, -2.43, -0.09, -5.1], ["c", -0.09, -4.56, -0.09, -4.86, -0.03, -4.89], ["c", 0.15, -0.12, 0.39, -0.15, 0.72, -0.15], ["c", 0.3, 0, 0.54, 0.03, 0.69, 0.15], ["c", 0.06, 0.03, 0.06, 0.33, -0.03, 4.95], ["c", -0.06, 2.7, -0.09, 5.04, -0.09, 5.22], ["l", 0.03, 0.3], ["l", 0.21, -0.15], ["c", 0.69, -0.48, 1.44, -0.69, 2.28, -0.69], ["c", 0.51, 0, 0.78, 0.03, 1.2, 0.21], ["c", 1.32, 0.63, 2.01, 2.28, 1.53, 3.69], ["c", -0.21, 0.57, -0.51, 1.02, -1.05, 1.56], ["c", -0.42, 0.42, -0.81, 0.72, -1.92, 1.5], ["c", -1.26, 0.87, -1.5, 1.08, -1.86, 1.5], ["c", -0.39, 0.45, -0.54, 0.54, -0.81, 0.51], ["c", -0.18, 0, -0.21, 0, -0.33, -0.06], ["l", -0.21, -0.21], ["l", -0.06, -0.12], ["l", -0.03, -0.99], ["c", -0.03, -0.54, -0.03, -1.29, -0.06, -1.68], ["l", 0, -0.69], ["l", -0.21, 0.24], ["c", -0.36, 0.42, -0.75, 0.75, -1.8, 1.62], ["c", -1.02, 0.84, -1.2, 0.99, -1.44, 1.38], ["c", -0.36, 0.51, -0.54, 0.6, -0.9, 0.51], ["c", -0.15, -0.03, -0.39, -0.27, -0.42, -0.42], ["c", -0.03, -0.06, -0.09, -3.27, -0.18, -8.34], ["c", -0.09, -4.53, -0.15, -8.58, -0.18, -9.03], ["l", 0, -0.78], ["l", 0.12, -0.06], ["c", 0.06, -0.03, 0.18, -0.09, 0.27, -0.12], ["z"], ["m", 2.52, 10.98], ["c", -0.18, -0.09, -0.48, -0.12, -0.66, -0.06], ["c", -0.39, 0.15, -0.69, 0.54, -0.84, 1.14], ["c", -0.06, 0.24, -0.06, 0.39, -0.09, 1.74], ["c", -0.03, 1.44, 0, 2.73, 0.06, 3.18], ["l", 0.03, 0.15], ["l", 0.27, -0.27], ["c", 0.93, -0.96, 1.5, -1.95, 1.74, -3.06], ["c", 0.06, -0.27, 0.06, -0.39, 0.06, -0.96], ["c", 0, -0.54, 0, -0.69, -0.06, -0.93], ["c", -0.09, -0.51, -0.27, -0.81, -0.51, -0.93], ["z"], ["m", 5.43, 0], ["c", -0.18, -0.09, -0.51, -0.12, -0.72, -0.06], ["c", -0.54, 0.12, -0.96, 0.63, -1.17, 1.26], ["c", -0.06, 0.3, -0.12, 2.88, -0.06, 3.9], ["c", 0.03, 0.42, 0.03, 0.81, 0.06, 0.9], ["l", 0.03, 0.12], ["l", 0.36, -0.3], ["c", 0.42, -0.36, 1.02, -0.96, 1.29, -1.29], ["c", 0.36, -0.45, 0.66, -0.99, 0.81, -1.41], ["c", 0.42, -1.23, 0.15, -2.76, -0.6, -3.12], ["z"]], w: 11.613, h: 18.804 },
      "accidentals.dblsharp": { d: [["M", -0.18, -3.96], ["c", 0.06, -0.03, 0.12, -0.06, 0.15, -0.06], ["c", 0.09, 0, 2.76, 0.27, 2.79, 0.3], ["c", 0.12, 0.03, 0.15, 0.12, 0.15, 0.51], ["c", 0.06, 0.96, 0.24, 1.59, 0.57, 2.1], ["c", 0.06, 0.09, 0.15, 0.21, 0.18, 0.24], ["l", 0.09, 0.06], ["l", 0.09, -0.06], ["c", 0.03, -0.03, 0.12, -0.15, 0.18, -0.24], ["c", 0.33, -0.51, 0.51, -1.14, 0.57, -2.1], ["c", 0, -0.39, 0.03, -0.45, 0.12, -0.51], ["c", 0.03, 0, 0.66, -0.09, 1.44, -0.15], ["c", 1.47, -0.15, 1.5, -0.15, 1.56, -0.03], ["c", 0.03, 0.06, 0, 0.42, -0.09, 1.44], ["c", -0.09, 0.72, -0.15, 1.35, -0.15, 1.38], ["c", 0, 0.03, -0.03, 0.09, -0.06, 0.12], ["c", -0.06, 0.06, -0.12, 0.09, -0.51, 0.09], ["c", -1.08, 0.06, -1.8, 0.3, -2.28, 0.75], ["l", -0.12, 0.09], ["l", 0.09, 0.09], ["c", 0.12, 0.15, 0.39, 0.33, 0.63, 0.45], ["c", 0.42, 0.18, 0.96, 0.27, 1.68, 0.33], ["c", 0.39, 0, 0.45, 0.03, 0.51, 0.09], ["c", 0.03, 0.03, 0.06, 0.09, 0.06, 0.12], ["c", 0, 0.03, 0.06, 0.66, 0.15, 1.38], ["c", 0.09, 1.02, 0.12, 1.38, 0.09, 1.44], ["c", -0.06, 0.12, -0.09, 0.12, -1.56, -0.03], ["c", -0.78, -0.06, -1.41, -0.15, -1.44, -0.15], ["c", -0.09, -0.06, -0.12, -0.12, -0.12, -0.54], ["c", -0.06, -0.93, -0.24, -1.56, -0.57, -2.07], ["c", -0.06, -0.09, -0.15, -0.21, -0.18, -0.24], ["l", -0.09, -0.06], ["l", -0.09, 0.06], ["c", -0.03, 0.03, -0.12, 0.15, -0.18, 0.24], ["c", -0.33, 0.51, -0.51, 1.14, -0.57, 2.07], ["c", 0, 0.42, -0.03, 0.48, -0.12, 0.54], ["c", -0.03, 0, -0.66, 0.09, -1.44, 0.15], ["c", -1.47, 0.15, -1.5, 0.15, -1.56, 0.03], ["c", -0.03, -0.06, 0, -0.42, 0.09, -1.44], ["c", 0.09, -0.72, 0.15, -1.35, 0.15, -1.38], ["c", 0, -0.03, 0.03, -0.09, 0.06, -0.12], ["c", 0.06, -0.06, 0.12, -0.09, 0.51, -0.09], ["c", 0.72, -0.06, 1.26, -0.15, 1.68, -0.33], ["c", 0.24, -0.12, 0.51, -0.3, 0.63, -0.45], ["l", 0.09, -0.09], ["l", -0.12, -0.09], ["c", -0.48, -0.45, -1.2, -0.69, -2.28, -0.75], ["c", -0.39, 0, -0.45, -0.03, -0.51, -0.09], ["c", -0.03, -0.03, -0.06, -0.09, -0.06, -0.12], ["c", 0, -0.03, -0.06, -0.63, -0.12, -1.38], ["c", -0.09, -0.72, -0.15, -1.35, -0.15, -1.38], ["z"]], w: 7.95, h: 7.977 },
      "dots.dot": { d: [["M", 1.32, -1.68], ["c", 0.09, -0.03, 0.27, -0.06, 0.39, -0.06], ["c", 0.96, 0, 1.74, 0.78, 1.74, 1.71], ["c", 0, 0.96, -0.78, 1.74, -1.71, 1.74], ["c", -0.96, 0, -1.74, -0.78, -1.74, -1.71], ["c", 0, -0.78, 0.54, -1.5, 1.32, -1.68], ["z"]], w: 3.45, h: 3.45 },
      "noteheads.dbl": { d: [["M", -0.69, -4.02], ["c", 0.18, -0.09, 0.36, -0.09, 0.54, 0], ["c", 0.18, 0.09, 0.24, 0.15, 0.33, 0.3], ["c", 0.06, 0.15, 0.06, 0.18, 0.06, 1.41], ["l", 0, 1.23], ["l", 0.12, -0.18], ["c", 0.72, -1.26, 2.64, -2.31, 4.86, -2.64], ["c", 0.81, -0.15, 1.11, -0.15, 2.13, -0.15], ["c", 0.99, 0, 1.29, 0, 2.1, 0.15], ["c", 0.75, 0.12, 1.38, 0.27, 2.04, 0.54], ["c", 1.35, 0.51, 2.34, 1.26, 2.82, 2.1], ["l", 0.12, 0.18], ["l", 0, -1.23], ["c", 0, -1.2, 0, -1.26, 0.06, -1.38], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["c", 0.18, -0.09, 0.36, -0.09, 0.54, 0], ["c", 0.18, 0.09, 0.24, 0.15, 0.33, 0.3], ["l", 0.06, 0.15], ["l", 0, 3.54], ["l", 0, 3.54], ["l", -0.06, 0.15], ["c", -0.09, 0.18, -0.15, 0.24, -0.33, 0.33], ["c", -0.18, 0.09, -0.36, 0.09, -0.54, 0], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["c", -0.06, -0.12, -0.06, -0.18, -0.06, -1.38], ["l", 0, -1.23], ["l", -0.12, 0.18], ["c", -0.48, 0.84, -1.47, 1.59, -2.82, 2.1], ["c", -0.84, 0.33, -1.71, 0.54, -2.85, 0.66], ["c", -0.45, 0.06, -2.16, 0.06, -2.61, 0], ["c", -1.14, -0.12, -2.01, -0.33, -2.85, -0.66], ["c", -1.35, -0.51, -2.34, -1.26, -2.82, -2.1], ["l", -0.12, -0.18], ["l", 0, 1.23], ["c", 0, 1.23, 0, 1.26, -0.06, 1.38], ["c", -0.09, 0.18, -0.15, 0.24, -0.33, 0.33], ["c", -0.18, 0.09, -0.36, 0.09, -0.54, 0], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["l", -0.06, -0.15], ["l", 0, -3.54], ["c", 0, -3.48, 0, -3.54, 0.06, -3.66], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["z"], ["m", 7.71, 0.63], ["c", -0.36, -0.06, -0.9, -0.06, -1.14, 0], ["c", -0.3, 0.03, -0.66, 0.24, -0.87, 0.42], ["c", -0.6, 0.54, -0.9, 1.62, -0.75, 2.82], ["c", 0.12, 0.93, 0.51, 1.68, 1.11, 2.31], ["c", 0.75, 0.72, 1.83, 1.2, 2.85, 1.26], ["c", 1.05, 0.06, 1.83, -0.54, 2.1, -1.65], ["c", 0.21, -0.9, 0.12, -1.95, -0.24, -2.82], ["c", -0.36, -0.81, -1.08, -1.53, -1.95, -1.95], ["c", -0.3, -0.15, -0.78, -0.3, -1.11, -0.39], ["z"]], w: 16.83, h: 8.145 },
      "noteheads.whole": { d: [["M", 6.51, -4.05], ["c", 0.51, -0.03, 2.01, 0, 2.52, 0.03], ["c", 1.41, 0.18, 2.64, 0.51, 3.72, 1.08], ["c", 1.2, 0.63, 1.95, 1.41, 2.19, 2.31], ["c", 0.09, 0.33, 0.09, 0.9, 0, 1.23], ["c", -0.24, 0.9, -0.99, 1.68, -2.19, 2.31], ["c", -1.08, 0.57, -2.28, 0.9, -3.75, 1.08], ["c", -0.66, 0.06, -2.31, 0.06, -2.97, 0], ["c", -1.47, -0.18, -2.67, -0.51, -3.75, -1.08], ["c", -1.2, -0.63, -1.95, -1.41, -2.19, -2.31], ["c", -0.09, -0.33, -0.09, -0.9, 0, -1.23], ["c", 0.24, -0.9, 0.99, -1.68, 2.19, -2.31], ["c", 1.2, -0.63, 2.61, -0.99, 4.23, -1.11], ["z"], ["m", 0.57, 0.66], ["c", -0.87, -0.15, -1.53, 0, -2.04, 0.51], ["c", -0.15, 0.15, -0.24, 0.27, -0.33, 0.48], ["c", -0.24, 0.51, -0.36, 1.08, -0.33, 1.77], ["c", 0.03, 0.69, 0.18, 1.26, 0.42, 1.77], ["c", 0.6, 1.17, 1.74, 1.98, 3.18, 2.22], ["c", 1.11, 0.21, 1.95, -0.15, 2.34, -0.99], ["c", 0.24, -0.51, 0.36, -1.08, 0.33, -1.8], ["c", -0.06, -1.11, -0.45, -2.04, -1.17, -2.76], ["c", -0.63, -0.63, -1.47, -1.05, -2.4, -1.2], ["z"]], w: 14.985, h: 8.097 },
      "noteheads.half": { d: [["M", 7.44, -4.05], ["c", 0.06, -0.03, 0.27, -0.03, 0.48, -0.03], ["c", 1.05, 0, 1.71, 0.24, 2.1, 0.81], ["c", 0.42, 0.6, 0.45, 1.35, 0.18, 2.4], ["c", -0.42, 1.59, -1.14, 2.73, -2.16, 3.39], ["c", -1.41, 0.93, -3.18, 1.44, -5.4, 1.53], ["c", -1.17, 0.03, -1.89, -0.21, -2.28, -0.81], ["c", -0.42, -0.6, -0.45, -1.35, -0.18, -2.4], ["c", 0.42, -1.59, 1.14, -2.73, 2.16, -3.39], ["c", 0.63, -0.42, 1.23, -0.72, 1.98, -0.96], ["c", 0.9, -0.3, 1.65, -0.42, 3.12, -0.54], ["z"], ["m", 1.29, 0.87], ["c", -0.27, -0.09, -0.63, -0.12, -0.9, -0.03], ["c", -0.72, 0.24, -1.53, 0.69, -3.27, 1.8], ["c", -2.34, 1.5, -3.3, 2.25, -3.57, 2.79], ["c", -0.36, 0.72, -0.06, 1.5, 0.66, 1.77], ["c", 0.24, 0.12, 0.69, 0.09, 0.99, 0], ["c", 0.84, -0.3, 1.92, -0.93, 4.14, -2.37], ["c", 1.62, -1.08, 2.37, -1.71, 2.61, -2.19], ["c", 0.36, -0.72, 0.06, -1.5, -0.66, -1.77], ["z"]], w: 10.37, h: 8.132 },
      "noteheads.quarter": { d: [["M", 6.09, -4.05], ["c", 0.36, -0.03, 1.2, 0, 1.53, 0.06], ["c", 1.17, 0.24, 1.89, 0.84, 2.16, 1.83], ["c", 0.06, 0.18, 0.06, 0.3, 0.06, 0.66], ["c", 0, 0.45, 0, 0.63, -0.15, 1.08], ["c", -0.66, 2.04, -3.06, 3.93, -5.52, 4.38], ["c", -0.54, 0.09, -1.44, 0.09, -1.83, 0.03], ["c", -1.23, -0.27, -1.98, -0.87, -2.25, -1.86], ["c", -0.06, -0.18, -0.06, -0.3, -0.06, -0.66], ["c", 0, -0.45, 0, -0.63, 0.15, -1.08], ["c", 0.24, -0.78, 0.75, -1.53, 1.44, -2.22], ["c", 1.2, -1.2, 2.85, -2.01, 4.47, -2.22], ["z"]], w: 9.81, h: 8.094 },
      "noteheads.slash.nostem": { d: [["M", 9.3, -7.77], ["c", 0.06, -0.06, 0.18, -0.06, 1.71, -0.06], ["l", 1.65, 0], ["l", 0.09, 0.09], ["c", 0.06, 0.06, 0.06, 0.09, 0.06, 0.15], ["c", -0.03, 0.12, -9.21, 15.24, -9.3, 15.33], ["c", -0.06, 0.06, -0.18, 0.06, -1.71, 0.06], ["l", -1.65, 0], ["l", -0.09, -0.09], ["c", -0.06, -0.06, -0.06, -0.09, -0.06, -0.15], ["c", 0.03, -0.12, 9.21, -15.24, 9.3, -15.33], ["z"]], w: 12.81, h: 15.63 },
      "noteheads.indeterminate": { d: [["M", 0.78, -4.05], ["c", 0.12, -0.03, 0.24, -0.03, 0.36, 0.03], ["c", 0.03, 0.03, 0.93, 0.72, 1.95, 1.56], ["l", 1.86, 1.5], ["l", 1.86, -1.5], ["c", 1.02, -0.84, 1.92, -1.53, 1.95, -1.56], ["c", 0.21, -0.12, 0.33, -0.09, 0.75, 0.24], ["c", 0.3, 0.27, 0.36, 0.36, 0.36, 0.54], ["c", 0, 0.03, -0.03, 0.12, -0.06, 0.18], ["c", -0.03, 0.06, -0.9, 0.75, -1.89, 1.56], ["l", -1.8, 1.47], ["c", 0, 0.03, 0.81, 0.69, 1.8, 1.5], ["c", 0.99, 0.81, 1.86, 1.5, 1.89, 1.56], ["c", 0.03, 0.06, 0.06, 0.15, 0.06, 0.18], ["c", 0, 0.18, -0.06, 0.27, -0.36, 0.54], ["c", -0.42, 0.33, -0.54, 0.36, -0.75, 0.24], ["c", -0.03, -0.03, -0.93, -0.72, -1.95, -1.56], ["l", -1.86, -1.5], ["l", -1.86, 1.5], ["c", -1.02, 0.84, -1.92, 1.53, -1.95, 1.56], ["c", -0.21, 0.12, -0.33, 0.09, -0.75, -0.24], ["c", -0.3, -0.27, -0.36, -0.36, -0.36, -0.54], ["c", 0, -0.03, 0.03, -0.12, 0.06, -0.18], ["c", 0.03, -0.06, 0.9, -0.75, 1.89, -1.56], ["l", 1.8, -1.47], ["c", 0, -0.03, -0.81, -0.69, -1.8, -1.5], ["c", -0.99, -0.81, -1.86, -1.5, -1.89, -1.56], ["c", -0.06, -0.12, -0.09, -0.21, -0.03, -0.36], ["c", 0.03, -0.09, 0.57, -0.57, 0.72, -0.63], ["z"]], w: 9.843, h: 8.139 },
      "scripts.ufermata": { d: [["M", -0.75, -10.77], ["c", 0.12, 0, 0.45, -0.03, 0.69, -0.03], ["c", 2.91, -0.03, 5.55, 1.53, 7.41, 4.35], ["c", 1.17, 1.71, 1.95, 3.72, 2.43, 6.03], ["c", 0.12, 0.51, 0.12, 0.57, 0.03, 0.69], ["c", -0.12, 0.21, -0.48, 0.27, -0.69, 0.12], ["c", -0.12, -0.09, -0.18, -0.24, -0.27, -0.69], ["c", -0.78, -3.63, -3.42, -6.54, -6.78, -7.38], ["c", -0.78, -0.21, -1.2, -0.24, -2.07, -0.24], ["c", -0.63, 0, -0.84, 0, -1.2, 0.06], ["c", -1.83, 0.27, -3.42, 1.08, -4.8, 2.37], ["c", -1.41, 1.35, -2.4, 3.21, -2.85, 5.19], ["c", -0.09, 0.45, -0.15, 0.6, -0.27, 0.69], ["c", -0.21, 0.15, -0.57, 0.09, -0.69, -0.12], ["c", -0.09, -0.12, -0.09, -0.18, 0.03, -0.69], ["c", 0.33, -1.62, 0.78, -3, 1.47, -4.38], ["c", 1.77, -3.54, 4.44, -5.67, 7.56, -5.97], ["z"], ["m", 0.33, 7.47], ["c", 1.38, -0.3, 2.58, 0.9, 2.31, 2.25], ["c", -0.15, 0.72, -0.78, 1.35, -1.47, 1.5], ["c", -1.38, 0.27, -2.58, -0.93, -2.31, -2.31], ["c", 0.15, -0.69, 0.78, -1.29, 1.47, -1.44], ["z"]], w: 19.748, h: 11.289 },
      "scripts.dfermata": { d: [["M", -9.63, -0.42], ["c", 0.15, -0.09, 0.36, -0.06, 0.51, 0.03], ["c", 0.12, 0.09, 0.18, 0.24, 0.27, 0.66], ["c", 0.78, 3.66, 3.42, 6.57, 6.78, 7.41], ["c", 0.78, 0.21, 1.2, 0.24, 2.07, 0.24], ["c", 0.63, 0, 0.84, 0, 1.2, -0.06], ["c", 1.83, -0.27, 3.42, -1.08, 4.8, -2.37], ["c", 1.41, -1.35, 2.4, -3.21, 2.85, -5.22], ["c", 0.09, -0.42, 0.15, -0.57, 0.27, -0.66], ["c", 0.21, -0.15, 0.57, -0.09, 0.69, 0.12], ["c", 0.09, 0.12, 0.09, 0.18, -0.03, 0.69], ["c", -0.33, 1.62, -0.78, 3, -1.47, 4.38], ["c", -1.92, 3.84, -4.89, 6, -8.31, 6], ["c", -3.42, 0, -6.39, -2.16, -8.31, -6], ["c", -0.48, -0.96, -0.84, -1.92, -1.14, -2.97], ["c", -0.18, -0.69, -0.42, -1.74, -0.42, -1.92], ["c", 0, -0.12, 0.09, -0.27, 0.24, -0.33], ["z"], ["m", 9.21, 0], ["c", 1.2, -0.27, 2.34, 0.63, 2.34, 1.86], ["c", 0, 0.9, -0.66, 1.68, -1.5, 1.89], ["c", -1.38, 0.27, -2.58, -0.93, -2.31, -2.31], ["c", 0.15, -0.69, 0.78, -1.29, 1.47, -1.44], ["z"]], w: 19.744, h: 11.274 },
      "scripts.sforzato": { d: [["M", -6.45, -3.69], ["c", 0.06, -0.03, 0.15, -0.06, 0.18, -0.06], ["c", 0.06, 0, 2.85, 0.72, 6.24, 1.59], ["l", 6.33, 1.65], ["c", 0.33, 0.06, 0.45, 0.21, 0.45, 0.51], ["c", 0, 0.3, -0.12, 0.45, -0.45, 0.51], ["l", -6.33, 1.65], ["c", -3.39, 0.87, -6.18, 1.59, -6.21, 1.59], ["c", -0.21, 0, -0.48, -0.24, -0.51, -0.45], ["c", 0, -0.15, 0.06, -0.36, 0.18, -0.45], ["c", 0.09, -0.06, 0.87, -0.27, 3.84, -1.05], ["c", 2.04, -0.54, 3.84, -0.99, 4.02, -1.02], ["c", 0.15, -0.06, 1.14, -0.24, 2.22, -0.42], ["c", 1.05, -0.18, 1.92, -0.36, 1.92, -0.36], ["c", 0, 0, -0.87, -0.18, -1.92, -0.36], ["c", -1.08, -0.18, -2.07, -0.36, -2.22, -0.42], ["c", -0.18, -0.03, -1.98, -0.48, -4.02, -1.02], ["c", -2.97, -0.78, -3.75, -0.99, -3.84, -1.05], ["c", -0.12, -0.09, -0.18, -0.3, -0.18, -0.45], ["c", 0.03, -0.15, 0.15, -0.3, 0.3, -0.39], ["z"]], w: 13.5, h: 7.5 },
      "scripts.staccato": { d: [["M", -0.36, -1.47], ["c", 0.93, -0.21, 1.86, 0.51, 1.86, 1.47], ["c", 0, 0.93, -0.87, 1.65, -1.8, 1.47], ["c", -0.54, -0.12, -1.02, -0.57, -1.14, -1.08], ["c", -0.21, -0.81, 0.27, -1.65, 1.08, -1.86], ["z"]], w: 2.989, h: 3.004 },
      "scripts.tenuto": { d: [["M", -4.2, -0.48], ["l", 0.12, -0.06], ["l", 4.08, 0], ["l", 4.08, 0], ["l", 0.12, 0.06], ["c", 0.39, 0.21, 0.39, 0.75, 0, 0.96], ["l", -0.12, 0.06], ["l", -4.08, 0], ["l", -4.08, 0], ["l", -0.12, -0.06], ["c", -0.39, -0.21, -0.39, -0.75, 0, -0.96], ["z"]], w: 8.985, h: 1.08 },
      "scripts.umarcato": { d: [["M", -0.15, -8.19], ["c", 0.15, -0.12, 0.36, -0.03, 0.45, 0.15], ["c", 0.21, 0.42, 3.45, 7.65, 3.45, 7.71], ["c", 0, 0.12, -0.12, 0.27, -0.21, 0.3], ["c", -0.03, 0.03, -0.51, 0.03, -1.14, 0.03], ["c", -1.05, 0, -1.08, 0, -1.17, -0.06], ["c", -0.09, -0.06, -0.24, -0.36, -1.17, -2.4], ["c", -0.57, -1.29, -1.05, -2.34, -1.08, -2.34], ["c", 0, -0.03, -0.51, 1.02, -1.08, 2.34], ["c", -0.93, 2.07, -1.08, 2.34, -1.14, 2.4], ["c", -0.06, 0.03, -0.15, 0.06, -0.18, 0.06], ["c", -0.15, 0, -0.33, -0.18, -0.33, -0.33], ["c", 0, -0.06, 3.24, -7.32, 3.45, -7.71], ["c", 0.03, -0.06, 0.09, -0.15, 0.15, -0.15], ["z"]], w: 7.5, h: 8.245 },
      "scripts.dmarcato": { d: [["M", -3.57, 0.03], ["c", 0.03, 0, 0.57, -0.03, 1.17, -0.03], ["c", 1.05, 0, 1.08, 0, 1.17, 0.06], ["c", 0.09, 0.06, 0.24, 0.36, 1.17, 2.4], ["c", 0.57, 1.29, 1.05, 2.34, 1.08, 2.34], ["c", 0, 0.03, 0.51, -1.02, 1.08, -2.34], ["c", 0.93, -2.07, 1.08, -2.34, 1.14, -2.4], ["c", 0.06, -0.03, 0.15, -0.06, 0.18, -0.06], ["c", 0.15, 0, 0.33, 0.18, 0.33, 0.33], ["c", 0, 0.09, -3.45, 7.74, -3.54, 7.83], ["c", -0.12, 0.12, -0.3, 0.12, -0.42, 0], ["c", -0.09, -0.09, -3.54, -7.74, -3.54, -7.83], ["c", 0, -0.09, 0.12, -0.27, 0.18, -0.3], ["z"]], w: 7.5, h: 8.25 },
      "scripts.stopped": { d: [["M", -0.27, -4.08], ["c", 0.18, -0.09, 0.36, -0.09, 0.54, 0], ["c", 0.18, 0.09, 0.24, 0.15, 0.33, 0.3], ["l", 0.06, 0.15], ["l", 0, 1.5], ["l", 0, 1.47], ["l", 1.47, 0], ["l", 1.5, 0], ["l", 0.15, 0.06], ["c", 0.15, 0.09, 0.21, 0.15, 0.3, 0.33], ["c", 0.09, 0.18, 0.09, 0.36, 0, 0.54], ["c", -0.09, 0.18, -0.15, 0.24, -0.33, 0.33], ["c", -0.12, 0.06, -0.18, 0.06, -1.62, 0.06], ["l", -1.47, 0], ["l", 0, 1.47], ["l", 0, 1.47], ["l", -0.06, 0.15], ["c", -0.09, 0.18, -0.15, 0.24, -0.33, 0.33], ["c", -0.18, 0.09, -0.36, 0.09, -0.54, 0], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["l", -0.06, -0.15], ["l", 0, -1.47], ["l", 0, -1.47], ["l", -1.47, 0], ["c", -1.44, 0, -1.5, 0, -1.62, -0.06], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["c", -0.09, -0.18, -0.09, -0.36, 0, -0.54], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["l", 0.15, -0.06], ["l", 1.47, 0], ["l", 1.47, 0], ["l", 0, -1.47], ["c", 0, -1.44, 0, -1.5, 0.06, -1.62], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["z"]], w: 8.295, h: 8.295 },
      "scripts.upbow": { d: [["M", -4.65, -15.54], ["c", 0.12, -0.09, 0.36, -0.06, 0.48, 0.03], ["c", 0.03, 0.03, 0.09, 0.09, 0.12, 0.15], ["c", 0.03, 0.06, 0.66, 2.13, 1.41, 4.62], ["c", 1.35, 4.41, 1.38, 4.56, 2.01, 6.96], ["l", 0.63, 2.46], ["l", 0.63, -2.46], ["c", 0.63, -2.4, 0.66, -2.55, 2.01, -6.96], ["c", 0.75, -2.49, 1.38, -4.56, 1.41, -4.62], ["c", 0.06, -0.15, 0.18, -0.21, 0.36, -0.24], ["c", 0.15, 0, 0.3, 0.06, 0.39, 0.18], ["c", 0.15, 0.21, 0.24, -0.18, -2.1, 7.56], ["c", -1.2, 3.96, -2.22, 7.32, -2.25, 7.41], ["c", 0, 0.12, -0.06, 0.27, -0.09, 0.3], ["c", -0.12, 0.21, -0.6, 0.21, -0.72, 0], ["c", -0.03, -0.03, -0.09, -0.18, -0.09, -0.3], ["c", -0.03, -0.09, -1.05, -3.45, -2.25, -7.41], ["c", -2.34, -7.74, -2.25, -7.35, -2.1, -7.56], ["c", 0.03, -0.03, 0.09, -0.09, 0.15, -0.12], ["z"]], w: 9.73, h: 15.608 },
      "scripts.downbow": { d: [["M", -5.55, -9.93], ["l", 0.09, -0.06], ["l", 5.46, 0], ["l", 5.46, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 4.77], ["c", 0, 5.28, 0, 4.89, -0.18, 5.01], ["c", -0.18, 0.12, -0.42, 0.06, -0.54, -0.12], ["c", -0.06, -0.09, -0.06, -0.18, -0.06, -2.97], ["l", 0, -2.85], ["l", -4.83, 0], ["l", -4.83, 0], ["l", 0, 2.85], ["c", 0, 2.79, 0, 2.88, -0.06, 2.97], ["c", -0.15, 0.24, -0.51, 0.24, -0.66, 0], ["c", -0.06, -0.09, -0.06, -0.21, -0.06, -4.89], ["l", 0, -4.77], ["z"]], w: 11.22, h: 9.992 },
      "scripts.turn": { d: [["M", -4.77, -3.9], ["c", 0.36, -0.06, 1.05, -0.06, 1.44, 0.03], ["c", 0.78, 0.15, 1.5, 0.51, 2.34, 1.14], ["c", 0.6, 0.45, 1.05, 0.87, 2.22, 2.01], ["c", 1.11, 1.08, 1.62, 1.5, 2.22, 1.86], ["c", 0.6, 0.36, 1.32, 0.57, 1.92, 0.57], ["c", 0.9, 0, 1.71, -0.57, 1.89, -1.35], ["c", 0.24, -0.93, -0.39, -1.89, -1.35, -2.1], ["l", -0.15, -0.06], ["l", -0.09, 0.15], ["c", -0.03, 0.09, -0.15, 0.24, -0.24, 0.33], ["c", -0.72, 0.72, -2.04, 0.54, -2.49, -0.36], ["c", -0.48, -0.93, 0.03, -1.86, 1.17, -2.19], ["c", 0.3, -0.09, 1.02, -0.09, 1.35, 0], ["c", 0.99, 0.27, 1.74, 0.87, 2.25, 1.83], ["c", 0.69, 1.41, 0.63, 3, -0.21, 4.26], ["c", -0.21, 0.3, -0.69, 0.81, -0.99, 1.02], ["c", -0.3, 0.21, -0.84, 0.45, -1.17, 0.54], ["c", -1.23, 0.36, -2.49, 0.15, -3.72, -0.6], ["c", -0.75, -0.48, -1.41, -1.02, -2.85, -2.46], ["c", -1.11, -1.08, -1.62, -1.5, -2.22, -1.86], ["c", -0.6, -0.36, -1.32, -0.57, -1.92, -0.57], ["c", -0.9, 0, -1.71, 0.57, -1.89, 1.35], ["c", -0.24, 0.93, 0.39, 1.89, 1.35, 2.1], ["l", 0.15, 0.06], ["l", 0.09, -0.15], ["c", 0.03, -0.09, 0.15, -0.24, 0.24, -0.33], ["c", 0.72, -0.72, 2.04, -0.54, 2.49, 0.36], ["c", 0.48, 0.93, -0.03, 1.86, -1.17, 2.19], ["c", -0.3, 0.09, -1.02, 0.09, -1.35, 0], ["c", -0.99, -0.27, -1.74, -0.87, -2.25, -1.83], ["c", -0.69, -1.41, -0.63, -3, 0.21, -4.26], ["c", 0.21, -0.3, 0.69, -0.81, 0.99, -1.02], ["c", 0.48, -0.33, 1.11, -0.57, 1.74, -0.66], ["z"]], w: 16.366, h: 7.893 },
      "scripts.trill": { d: [["M", -0.51, -16.02], ["c", 0.12, -0.09, 0.21, -0.18, 0.21, -0.18], ["l", -0.81, 4.02], ["l", -0.81, 4.02], ["c", 0.03, 0, 0.51, -0.27, 1.08, -0.6], ["c", 0.6, -0.3, 1.14, -0.63, 1.26, -0.66], ["c", 1.14, -0.54, 2.31, -0.6, 3.09, -0.18], ["c", 0.27, 0.15, 0.54, 0.36, 0.6, 0.51], ["l", 0.06, 0.12], ["l", 0.21, -0.21], ["c", 0.9, -0.81, 2.22, -0.99, 3.12, -0.42], ["c", 0.6, 0.42, 0.9, 1.14, 0.78, 2.07], ["c", -0.15, 1.29, -1.05, 2.31, -1.95, 2.25], ["c", -0.48, -0.03, -0.78, -0.3, -0.96, -0.81], ["c", -0.09, -0.27, -0.09, -0.9, -0.03, -1.2], ["c", 0.21, -0.75, 0.81, -1.23, 1.59, -1.32], ["l", 0.24, -0.03], ["l", -0.09, -0.12], ["c", -0.51, -0.66, -1.62, -0.63, -2.31, 0.03], ["c", -0.39, 0.42, -0.3, 0.09, -1.23, 4.77], ["l", -0.81, 4.14], ["c", -0.03, 0, -0.12, -0.03, -0.21, -0.09], ["c", -0.33, -0.15, -0.54, -0.18, -0.99, -0.18], ["c", -0.42, 0, -0.66, 0.03, -1.05, 0.18], ["c", -0.12, 0.06, -0.21, 0.09, -0.21, 0.09], ["c", 0, -0.03, 0.36, -1.86, 0.81, -4.11], ["c", 0.9, -4.47, 0.87, -4.26, 0.69, -4.53], ["c", -0.21, -0.36, -0.66, -0.51, -1.17, -0.36], ["c", -0.15, 0.06, -2.22, 1.14, -2.58, 1.38], ["c", -0.12, 0.09, -0.12, 0.09, -0.21, 0.6], ["l", -0.09, 0.51], ["l", 0.21, 0.24], ["c", 0.63, 0.75, 1.02, 1.47, 1.2, 2.19], ["c", 0.06, 0.27, 0.06, 0.36, 0.06, 0.81], ["c", 0, 0.42, 0, 0.54, -0.06, 0.78], ["c", -0.15, 0.54, -0.33, 0.93, -0.63, 1.35], ["c", -0.18, 0.24, -0.57, 0.63, -0.81, 0.78], ["c", -0.24, 0.15, -0.63, 0.36, -0.84, 0.42], ["c", -0.27, 0.06, -0.66, 0.06, -0.87, 0.03], ["c", -0.81, -0.18, -1.32, -1.05, -1.38, -2.46], ["c", -0.03, -0.6, 0.03, -0.99, 0.33, -2.46], ["c", 0.21, -1.08, 0.24, -1.32, 0.21, -1.29], ["c", -1.2, 0.48, -2.4, 0.75, -3.21, 0.72], ["c", -0.69, -0.06, -1.17, -0.3, -1.41, -0.72], ["c", -0.39, -0.75, -0.12, -1.8, 0.66, -2.46], ["c", 0.24, -0.18, 0.69, -0.42, 1.02, -0.51], ["c", 0.69, -0.18, 1.53, -0.15, 2.31, 0.09], ["c", 0.3, 0.09, 0.75, 0.3, 0.99, 0.45], ["c", 0.12, 0.09, 0.15, 0.09, 0.15, 0.03], ["c", 0.03, -0.03, 0.33, -1.59, 0.72, -3.45], ["c", 0.36, -1.86, 0.66, -3.42, 0.69, -3.45], ["c", 0, -0.03, 0.03, -0.03, 0.21, 0.03], ["c", 0.21, 0.06, 0.27, 0.06, 0.48, 0.06], ["c", 0.42, -0.03, 0.78, -0.18, 1.26, -0.48], ["c", 0.15, -0.12, 0.36, -0.27, 0.48, -0.39], ["z"], ["m", -5.73, 7.68], ["c", -0.27, -0.03, -0.96, -0.06, -1.2, -0.03], ["c", -0.81, 0.12, -1.35, 0.57, -1.5, 1.2], ["c", -0.18, 0.66, 0.12, 1.14, 0.75, 1.29], ["c", 0.66, 0.12, 1.92, -0.12, 3.18, -0.66], ["l", 0.33, -0.15], ["l", 0.09, -0.39], ["c", 0.06, -0.21, 0.09, -0.42, 0.09, -0.45], ["c", 0, -0.03, -0.45, -0.3, -0.75, -0.45], ["c", -0.27, -0.15, -0.66, -0.27, -0.99, -0.36], ["z"], ["m", 4.29, 3.63], ["c", -0.24, -0.39, -0.51, -0.75, -0.51, -0.69], ["c", -0.06, 0.12, -0.39, 1.92, -0.45, 2.28], ["c", -0.09, 0.54, -0.12, 1.14, -0.06, 1.38], ["c", 0.06, 0.42, 0.21, 0.6, 0.51, 0.57], ["c", 0.39, -0.06, 0.75, -0.48, 0.93, -1.14], ["c", 0.09, -0.33, 0.09, -1.05, 0, -1.38], ["c", -0.09, -0.39, -0.24, -0.69, -0.42, -1.02], ["z"]], w: 17.963, h: 16.49 },
      "scripts.segno": { d: [["M", -3.72, -11.22], ["c", 0.78, -0.09, 1.59, 0.03, 2.31, 0.42], ["c", 1.2, 0.6, 2.01, 1.71, 2.31, 3.09], ["c", 0.09, 0.42, 0.09, 1.2, 0.03, 1.5], ["c", -0.15, 0.45, -0.39, 0.81, -0.66, 0.93], ["c", -0.33, 0.18, -0.84, 0.21, -1.23, 0.15], ["c", -0.81, -0.18, -1.32, -0.93, -1.26, -1.89], ["c", 0.03, -0.36, 0.09, -0.57, 0.24, -0.9], ["c", 0.15, -0.33, 0.45, -0.6, 0.72, -0.75], ["c", 0.12, -0.06, 0.18, -0.09, 0.18, -0.12], ["c", 0, -0.03, -0.03, -0.15, -0.09, -0.24], ["c", -0.18, -0.45, -0.54, -0.87, -0.96, -1.08], ["c", -1.11, -0.57, -2.34, -0.18, -2.88, 0.9], ["c", -0.24, 0.51, -0.33, 1.11, -0.24, 1.83], ["c", 0.27, 1.92, 1.5, 3.54, 3.93, 5.13], ["c", 0.48, 0.33, 1.26, 0.78, 1.29, 0.78], ["c", 0.03, 0, 1.35, -2.19, 2.94, -4.89], ["l", 2.88, -4.89], ["l", 0.84, 0], ["l", 0.87, 0], ["l", -0.03, 0.06], ["c", -0.15, 0.21, -6.15, 10.41, -6.15, 10.44], ["c", 0, 0, 0.21, 0.15, 0.48, 0.27], ["c", 2.61, 1.47, 4.35, 3.03, 5.13, 4.65], ["c", 1.14, 2.34, 0.51, 5.07, -1.44, 6.39], ["c", -0.66, 0.42, -1.32, 0.63, -2.13, 0.69], ["c", -2.01, 0.09, -3.81, -1.41, -4.26, -3.54], ["c", -0.09, -0.42, -0.09, -1.2, -0.03, -1.5], ["c", 0.15, -0.45, 0.39, -0.81, 0.66, -0.93], ["c", 0.33, -0.18, 0.84, -0.21, 1.23, -0.15], ["c", 0.81, 0.18, 1.32, 0.93, 1.26, 1.89], ["c", -0.03, 0.36, -0.09, 0.57, -0.24, 0.9], ["c", -0.15, 0.33, -0.45, 0.6, -0.72, 0.75], ["c", -0.12, 0.06, -0.18, 0.09, -0.18, 0.12], ["c", 0, 0.03, 0.03, 0.15, 0.09, 0.24], ["c", 0.18, 0.45, 0.54, 0.87, 0.96, 1.08], ["c", 1.11, 0.57, 2.34, 0.18, 2.88, -0.9], ["c", 0.24, -0.51, 0.33, -1.11, 0.24, -1.83], ["c", -0.27, -1.92, -1.5, -3.54, -3.93, -5.13], ["c", -0.48, -0.33, -1.26, -0.78, -1.29, -0.78], ["c", -0.03, 0, -1.35, 2.19, -2.91, 4.89], ["l", -2.88, 4.89], ["l", -0.87, 0], ["l", -0.87, 0], ["l", 0.03, -0.06], ["c", 0.15, -0.21, 6.15, -10.41, 6.15, -10.44], ["c", 0, 0, -0.21, -0.15, -0.48, -0.3], ["c", -2.61, -1.44, -4.35, -3, -5.13, -4.62], ["c", -0.9, -1.89, -0.72, -4.02, 0.48, -5.52], ["c", 0.69, -0.84, 1.68, -1.41, 2.73, -1.53], ["z"], ["m", 8.76, 9.09], ["c", 0.03, -0.03, 0.15, -0.03, 0.27, -0.03], ["c", 0.33, 0.03, 0.57, 0.18, 0.72, 0.48], ["c", 0.09, 0.18, 0.09, 0.57, 0, 0.75], ["c", -0.09, 0.18, -0.21, 0.3, -0.36, 0.39], ["c", -0.15, 0.06, -0.21, 0.06, -0.39, 0.06], ["c", -0.21, 0, -0.27, 0, -0.39, -0.06], ["c", -0.3, -0.15, -0.48, -0.45, -0.48, -0.75], ["c", 0, -0.39, 0.24, -0.72, 0.63, -0.84], ["z"], ["m", -10.53, 2.61], ["c", 0.03, -0.03, 0.15, -0.03, 0.27, -0.03], ["c", 0.33, 0.03, 0.57, 0.18, 0.72, 0.48], ["c", 0.09, 0.18, 0.09, 0.57, 0, 0.75], ["c", -0.09, 0.18, -0.21, 0.3, -0.36, 0.39], ["c", -0.15, 0.06, -0.21, 0.06, -0.39, 0.06], ["c", -0.21, 0, -0.27, 0, -0.39, -0.06], ["c", -0.3, -0.15, -0.48, -0.45, -0.48, -0.75], ["c", 0, -0.39, 0.24, -0.72, 0.63, -0.84], ["z"]], w: 15, h: 22.504 },
      "scripts.coda": { d: [["M", -0.21, -10.47], ["c", 0.18, -0.12, 0.42, -0.06, 0.54, 0.12], ["c", 0.06, 0.09, 0.06, 0.18, 0.06, 1.5], ["l", 0, 1.38], ["l", 0.18, 0], ["c", 0.39, 0.06, 0.96, 0.24, 1.38, 0.48], ["c", 1.68, 0.93, 2.82, 3.24, 3.03, 6.12], ["c", 0.03, 0.24, 0.03, 0.45, 0.03, 0.45], ["c", 0, 0.03, 0.6, 0.03, 1.35, 0.03], ["c", 1.5, 0, 1.47, 0, 1.59, 0.18], ["c", 0.09, 0.12, 0.09, 0.3, 0, 0.42], ["c", -0.12, 0.18, -0.09, 0.18, -1.59, 0.18], ["c", -0.75, 0, -1.35, 0, -1.35, 0.03], ["c", 0, 0, 0, 0.21, -0.03, 0.42], ["c", -0.24, 3.15, -1.53, 5.58, -3.45, 6.36], ["c", -0.27, 0.12, -0.72, 0.24, -0.96, 0.27], ["l", -0.18, 0], ["l", 0, 1.38], ["c", 0, 1.32, 0, 1.41, -0.06, 1.5], ["c", -0.15, 0.24, -0.51, 0.24, -0.66, 0], ["c", -0.06, -0.09, -0.06, -0.18, -0.06, -1.5], ["l", 0, -1.38], ["l", -0.18, 0], ["c", -0.39, -0.06, -0.96, -0.24, -1.38, -0.48], ["c", -1.68, -0.93, -2.82, -3.24, -3.03, -6.15], ["c", -0.03, -0.21, -0.03, -0.42, -0.03, -0.42], ["c", 0, -0.03, -0.6, -0.03, -1.35, -0.03], ["c", -1.5, 0, -1.47, 0, -1.59, -0.18], ["c", -0.09, -0.12, -0.09, -0.3, 0, -0.42], ["c", 0.12, -0.18, 0.09, -0.18, 1.59, -0.18], ["c", 0.75, 0, 1.35, 0, 1.35, -0.03], ["c", 0, 0, 0, -0.21, 0.03, -0.45], ["c", 0.24, -3.12, 1.53, -5.55, 3.45, -6.33], ["c", 0.27, -0.12, 0.72, -0.24, 0.96, -0.27], ["l", 0.18, 0], ["l", 0, -1.38], ["c", 0, -1.53, 0, -1.5, 0.18, -1.62], ["z"], ["m", -0.18, 6.93], ["c", 0, -2.97, 0, -3.15, -0.06, -3.15], ["c", -0.09, 0, -0.51, 0.15, -0.66, 0.21], ["c", -0.87, 0.51, -1.38, 1.62, -1.56, 3.51], ["c", -0.06, 0.54, -0.12, 1.59, -0.12, 2.16], ["l", 0, 0.42], ["l", 1.2, 0], ["l", 1.2, 0], ["l", 0, -3.15], ["z"], ["m", 1.17, -3.06], ["c", -0.09, -0.03, -0.21, -0.06, -0.27, -0.09], ["l", -0.12, 0], ["l", 0, 3.15], ["l", 0, 3.15], ["l", 1.2, 0], ["l", 1.2, 0], ["l", 0, -0.81], ["c", -0.06, -2.4, -0.33, -3.69, -0.93, -4.59], ["c", -0.27, -0.39, -0.66, -0.69, -1.08, -0.81], ["z"], ["m", -1.17, 10.14], ["l", 0, -3.15], ["l", -1.2, 0], ["l", -1.2, 0], ["l", 0, 0.81], ["c", 0.03, 0.96, 0.06, 1.47, 0.15, 2.13], ["c", 0.24, 2.04, 0.96, 3.12, 2.13, 3.36], ["l", 0.12, 0], ["l", 0, -3.15], ["z"], ["m", 3.18, -2.34], ["l", 0, -0.81], ["l", -1.2, 0], ["l", -1.2, 0], ["l", 0, 3.15], ["l", 0, 3.15], ["l", 0.12, 0], ["c", 1.17, -0.24, 1.89, -1.32, 2.13, -3.36], ["c", 0.09, -0.66, 0.12, -1.17, 0.15, -2.13], ["z"]], w: 16.035, h: 21.062 },
      "scripts.comma": { d: [["M", 1.14, -4.62], ["c", 0.3, -0.12, 0.69, -0.03, 0.93, 0.15], ["c", 0.12, 0.12, 0.36, 0.45, 0.51, 0.78], ["c", 0.9, 1.77, 0.54, 4.05, -1.08, 6.75], ["c", -0.36, 0.63, -0.87, 1.38, -0.96, 1.44], ["c", -0.18, 0.12, -0.42, 0.06, -0.54, -0.12], ["c", -0.09, -0.18, -0.09, -0.3, 0.12, -0.6], ["c", 0.96, -1.44, 1.44, -2.97, 1.38, -4.35], ["c", -0.06, -0.93, -0.3, -1.68, -0.78, -2.46], ["c", -0.27, -0.39, -0.33, -0.63, -0.24, -0.96], ["c", 0.09, -0.27, 0.36, -0.54, 0.66, -0.63], ["z"]], w: 3.042, h: 9.237 },
      "scripts.roll": { d: [["M", 1.95, -6], ["c", 0.21, -0.09, 0.36, -0.09, 0.57, 0], ["c", 0.39, 0.15, 0.63, 0.39, 1.47, 1.35], ["c", 0.66, 0.75, 0.78, 0.87, 1.08, 1.05], ["c", 0.75, 0.45, 1.65, 0.42, 2.4, -0.06], ["c", 0.12, -0.09, 0.27, -0.27, 0.54, -0.6], ["c", 0.42, -0.54, 0.51, -0.63, 0.69, -0.63], ["c", 0.09, 0, 0.3, 0.12, 0.36, 0.21], ["c", 0.09, 0.12, 0.12, 0.3, 0.03, 0.42], ["c", -0.06, 0.12, -3.15, 3.9, -3.3, 4.08], ["c", -0.06, 0.06, -0.18, 0.12, -0.27, 0.18], ["c", -0.27, 0.12, -0.6, 0.06, -0.99, -0.27], ["c", -0.27, -0.21, -0.42, -0.39, -1.08, -1.14], ["c", -0.63, -0.72, -0.81, -0.9, -1.17, -1.08], ["c", -0.36, -0.18, -0.57, -0.21, -0.99, -0.21], ["c", -0.39, 0, -0.63, 0.03, -0.93, 0.18], ["c", -0.36, 0.15, -0.51, 0.27, -0.9, 0.81], ["c", -0.24, 0.27, -0.45, 0.51, -0.48, 0.54], ["c", -0.12, 0.09, -0.27, 0.06, -0.39, 0], ["c", -0.24, -0.15, -0.33, -0.39, -0.21, -0.6], ["c", 0.09, -0.12, 3.18, -3.87, 3.33, -4.02], ["c", 0.06, -0.06, 0.18, -0.15, 0.24, -0.21], ["z"]], w: 10.817, h: 6.125 },
      "scripts.prall": { d: [["M", -4.38, -3.69], ["c", 0.06, -0.03, 0.18, -0.06, 0.24, -0.06], ["c", 0.3, 0, 0.27, -0.03, 1.89, 1.95], ["l", 1.53, 1.83], ["c", 0.03, 0, 0.57, -0.84, 1.23, -1.83], ["c", 1.14, -1.68, 1.23, -1.83, 1.35, -1.89], ["c", 0.06, -0.03, 0.18, -0.06, 0.24, -0.06], ["c", 0.3, 0, 0.27, -0.03, 1.89, 1.95], ["l", 1.53, 1.83], ["l", 0.48, -0.69], ["c", 0.51, -0.78, 0.54, -0.84, 0.69, -0.9], ["c", 0.42, -0.18, 0.87, 0.15, 0.81, 0.6], ["c", -0.03, 0.12, -0.3, 0.51, -1.5, 2.37], ["c", -1.38, 2.07, -1.5, 2.22, -1.62, 2.28], ["c", -0.06, 0.03, -0.18, 0.06, -0.24, 0.06], ["c", -0.3, 0, -0.27, 0.03, -1.89, -1.95], ["l", -1.53, -1.83], ["c", -0.03, 0, -0.57, 0.84, -1.23, 1.83], ["c", -1.14, 1.68, -1.23, 1.83, -1.35, 1.89], ["c", -0.06, 0.03, -0.18, 0.06, -0.24, 0.06], ["c", -0.3, 0, -0.27, 0.03, -1.89, -1.95], ["l", -1.53, -1.83], ["l", -0.48, 0.69], ["c", -0.51, 0.78, -0.54, 0.84, -0.69, 0.9], ["c", -0.42, 0.18, -0.87, -0.15, -0.81, -0.6], ["c", 0.03, -0.12, 0.3, -0.51, 1.5, -2.37], ["c", 1.38, -2.07, 1.5, -2.22, 1.62, -2.28], ["z"]], w: 15.011, h: 7.5 },
      "scripts.arpeggio": { d: [["M", 1.5, 0], ["c", 1.5, 2, 1.5, 3, 1.5, 3], ["s", 0, 1, -2, 1.5], ["s", -0.5, 3, 1, 5.5], ["l", 1.5, 0], ["s", -1.75, -2, -1.9, -3.25], ["s", 2.15, -0.6, 2.95, -1.6], ["s", 0.45, -1, 0.5, -1.25], ["s", 0, -1, -2, -3.9], ["l", -1.5, 0], ["z"]], w: 5, h: 10 },
      "scripts.mordent": { d: [["M", -0.21, -4.95], ["c", 0.27, -0.15, 0.63, 0, 0.75, 0.27], ["c", 0.06, 0.12, 0.06, 0.24, 0.06, 1.44], ["l", 0, 1.29], ["l", 0.57, -0.84], ["c", 0.51, -0.75, 0.57, -0.84, 0.69, -0.9], ["c", 0.06, -0.03, 0.18, -0.06, 0.24, -0.06], ["c", 0.3, 0, 0.27, -0.03, 1.89, 1.95], ["l", 1.53, 1.83], ["l", 0.48, -0.69], ["c", 0.51, -0.78, 0.54, -0.84, 0.69, -0.9], ["c", 0.42, -0.18, 0.87, 0.15, 0.81, 0.6], ["c", -0.03, 0.12, -0.3, 0.51, -1.5, 2.37], ["c", -1.38, 2.07, -1.5, 2.22, -1.62, 2.28], ["c", -0.06, 0.03, -0.18, 0.06, -0.24, 0.06], ["c", -0.3, 0, -0.27, 0.03, -1.83, -1.89], ["c", -0.81, -0.99, -1.5, -1.8, -1.53, -1.86], ["c", -0.06, -0.03, -0.06, -0.03, -0.12, 0.03], ["c", -0.06, 0.06, -0.06, 0.15, -0.06, 2.28], ["c", 0, 1.95, 0, 2.25, -0.06, 2.34], ["c", -0.18, 0.45, -0.81, 0.48, -1.05, 0.03], ["c", -0.03, -0.06, -0.06, -0.24, -0.06, -1.41], ["l", 0, -1.35], ["l", -0.57, 0.84], ["c", -0.54, 0.78, -0.6, 0.87, -0.72, 0.93], ["c", -0.06, 0.03, -0.18, 0.06, -0.24, 0.06], ["c", -0.3, 0, -0.27, 0.03, -1.89, -1.95], ["l", -1.53, -1.83], ["l", -0.48, 0.69], ["c", -0.51, 0.78, -0.54, 0.84, -0.69, 0.9], ["c", -0.42, 0.18, -0.87, -0.15, -0.81, -0.6], ["c", 0.03, -0.12, 0.3, -0.51, 1.5, -2.37], ["c", 1.38, -2.07, 1.5, -2.22, 1.62, -2.28], ["c", 0.06, -0.03, 0.18, -0.06, 0.24, -0.06], ["c", 0.3, 0, 0.27, -0.03, 1.89, 1.95], ["l", 1.53, 1.83], ["c", 0.03, 0, 0.06, -0.06, 0.09, -0.09], ["c", 0.06, -0.12, 0.06, -0.15, 0.06, -2.28], ["c", 0, -1.92, 0, -2.22, 0.06, -2.31], ["c", 0.06, -0.15, 0.15, -0.24, 0.3, -0.3], ["z"]], w: 15.011, h: 10.012 },
      "flags.u8th": { d: [["M", -0.42, 3.75], ["l", 0, -3.75], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 0.18], ["c", 0, 0.3, 0.06, 0.84, 0.12, 1.23], ["c", 0.24, 1.53, 0.9, 3.12, 2.13, 5.16], ["l", 0.99, 1.59], ["c", 0.87, 1.44, 1.38, 2.34, 1.77, 3.09], ["c", 0.81, 1.68, 1.2, 3.06, 1.26, 4.53], ["c", 0.03, 1.53, -0.21, 3.27, -0.75, 5.01], ["c", -0.21, 0.69, -0.51, 1.5, -0.6, 1.59], ["c", -0.09, 0.12, -0.27, 0.21, -0.42, 0.21], ["c", -0.15, 0, -0.42, -0.12, -0.51, -0.21], ["c", -0.15, -0.18, -0.18, -0.42, -0.09, -0.66], ["c", 0.15, -0.33, 0.45, -1.2, 0.57, -1.62], ["c", 0.42, -1.38, 0.6, -2.58, 0.6, -3.9], ["c", 0, -0.66, 0, -0.81, -0.06, -1.11], ["c", -0.39, -2.07, -1.8, -4.26, -4.59, -7.14], ["l", -0.42, -0.45], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -3.75], ["z"]], w: 6.692, h: 22.59 },
      "flags.u16th": { d: [["M", -0.42, 7.5], ["l", 0, -7.5], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 0.39], ["c", 0.06, 1.08, 0.39, 2.19, 0.99, 3.39], ["c", 0.45, 0.9, 0.87, 1.59, 1.95, 3.12], ["c", 1.29, 1.86, 1.77, 2.64, 2.22, 3.57], ["c", 0.45, 0.93, 0.72, 1.8, 0.87, 2.64], ["c", 0.06, 0.51, 0.06, 1.5, 0, 1.92], ["c", -0.12, 0.6, -0.3, 1.2, -0.54, 1.71], ["l", -0.09, 0.24], ["l", 0.18, 0.45], ["c", 0.51, 1.2, 0.72, 2.22, 0.69, 3.42], ["c", -0.06, 1.53, -0.39, 3.03, -0.99, 4.53], ["c", -0.3, 0.75, -0.36, 0.81, -0.57, 0.9], ["c", -0.15, 0.09, -0.33, 0.06, -0.48, 0], ["c", -0.18, -0.09, -0.27, -0.18, -0.33, -0.33], ["c", -0.09, -0.18, -0.06, -0.3, 0.12, -0.75], ["c", 0.66, -1.41, 1.02, -2.88, 1.08, -4.32], ["c", 0, -0.6, -0.03, -1.05, -0.18, -1.59], ["c", -0.3, -1.2, -0.99, -2.4, -2.25, -3.87], ["c", -0.42, -0.48, -1.53, -1.62, -2.19, -2.22], ["l", -0.45, -0.42], ["l", -0.03, 1.11], ["l", 0, 1.11], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -7.5], ["z"], ["m", 1.65, 0.09], ["c", -0.3, -0.3, -0.69, -0.72, -0.9, -0.87], ["l", -0.33, -0.33], ["l", 0, 0.15], ["c", 0, 0.3, 0.06, 0.81, 0.15, 1.26], ["c", 0.27, 1.29, 0.87, 2.61, 2.04, 4.29], ["c", 0.15, 0.24, 0.6, 0.87, 0.96, 1.38], ["l", 1.08, 1.53], ["l", 0.42, 0.63], ["c", 0.03, 0, 0.12, -0.36, 0.21, -0.72], ["c", 0.06, -0.33, 0.06, -1.2, 0, -1.62], ["c", -0.33, -1.71, -1.44, -3.48, -3.63, -5.7], ["z"]], w: 6.693, h: 26.337 },
      "flags.u32nd": { d: [["M", -0.42, 11.25], ["l", 0, -11.25], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 0.36], ["c", 0.09, 1.68, 0.69, 3.27, 2.07, 5.46], ["l", 0.87, 1.35], ["c", 1.02, 1.62, 1.47, 2.37, 1.86, 3.18], ["c", 0.48, 1.02, 0.78, 1.92, 0.93, 2.88], ["c", 0.06, 0.48, 0.06, 1.5, 0, 1.89], ["c", -0.09, 0.42, -0.21, 0.87, -0.36, 1.26], ["l", -0.12, 0.3], ["l", 0.15, 0.39], ["c", 0.69, 1.56, 0.84, 2.88, 0.54, 4.38], ["c", -0.09, 0.45, -0.27, 1.08, -0.45, 1.47], ["l", -0.12, 0.24], ["l", 0.18, 0.36], ["c", 0.33, 0.72, 0.57, 1.56, 0.69, 2.34], ["c", 0.12, 1.02, -0.06, 2.52, -0.42, 3.84], ["c", -0.27, 0.93, -0.75, 2.13, -0.93, 2.31], ["c", -0.18, 0.15, -0.45, 0.18, -0.66, 0.09], ["c", -0.18, -0.09, -0.27, -0.18, -0.33, -0.33], ["c", -0.09, -0.18, -0.06, -0.3, 0.06, -0.6], ["c", 0.21, -0.36, 0.42, -0.9, 0.57, -1.38], ["c", 0.51, -1.41, 0.69, -3.06, 0.48, -4.08], ["c", -0.15, -0.81, -0.57, -1.68, -1.2, -2.55], ["c", -0.72, -0.99, -1.83, -2.13, -3.3, -3.33], ["l", -0.48, -0.42], ["l", -0.03, 1.53], ["l", 0, 1.56], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -11.25], ["z"], ["m", 1.26, -3.96], ["c", -0.27, -0.3, -0.54, -0.6, -0.66, -0.72], ["l", -0.18, -0.21], ["l", 0, 0.42], ["c", 0.06, 0.87, 0.24, 1.74, 0.66, 2.67], ["c", 0.36, 0.87, 0.96, 1.86, 1.92, 3.18], ["c", 0.21, 0.33, 0.63, 0.87, 0.87, 1.23], ["c", 0.27, 0.39, 0.6, 0.84, 0.75, 1.08], ["l", 0.27, 0.39], ["l", 0.03, -0.12], ["c", 0.12, -0.45, 0.15, -1.05, 0.09, -1.59], ["c", -0.27, -1.86, -1.38, -3.78, -3.75, -6.33], ["z"], ["m", -0.27, 6.09], ["c", -0.27, -0.21, -0.48, -0.42, -0.51, -0.45], ["c", -0.06, -0.03, -0.06, -0.03, -0.06, 0.21], ["c", 0, 0.9, 0.3, 2.04, 0.81, 3.09], ["c", 0.48, 1.02, 0.96, 1.77, 2.37, 3.63], ["c", 0.6, 0.78, 1.05, 1.44, 1.29, 1.77], ["c", 0.06, 0.12, 0.15, 0.21, 0.15, 0.18], ["c", 0.03, -0.03, 0.18, -0.57, 0.24, -0.87], ["c", 0.06, -0.45, 0.06, -1.32, -0.03, -1.74], ["c", -0.09, -0.48, -0.24, -0.9, -0.51, -1.44], ["c", -0.66, -1.35, -1.83, -2.7, -3.75, -4.38], ["z"]], w: 6.697, h: 32.145 },
      "flags.u64th": { d: [["M", -0.42, 15], ["l", 0, -15], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 0.36], ["c", 0.06, 1.2, 0.39, 2.37, 1.02, 3.66], ["c", 0.39, 0.81, 0.84, 1.56, 1.8, 3.09], ["c", 0.81, 1.26, 1.05, 1.68, 1.35, 2.22], ["c", 0.87, 1.5, 1.35, 2.79, 1.56, 4.08], ["c", 0.06, 0.54, 0.06, 1.56, -0.03, 2.04], ["c", -0.09, 0.48, -0.21, 0.99, -0.36, 1.35], ["l", -0.12, 0.27], ["l", 0.12, 0.27], ["c", 0.09, 0.15, 0.21, 0.45, 0.27, 0.66], ["c", 0.69, 1.89, 0.63, 3.66, -0.18, 5.46], ["l", -0.18, 0.39], ["l", 0.15, 0.33], ["c", 0.3, 0.66, 0.51, 1.44, 0.63, 2.1], ["c", 0.06, 0.48, 0.06, 1.35, 0, 1.71], ["c", -0.15, 0.57, -0.42, 1.2, -0.78, 1.68], ["l", -0.21, 0.27], ["l", 0.18, 0.33], ["c", 0.57, 1.05, 0.93, 2.13, 1.02, 3.18], ["c", 0.06, 0.72, 0, 1.83, -0.21, 2.79], ["c", -0.18, 1.02, -0.63, 2.34, -1.02, 3.09], ["c", -0.15, 0.33, -0.48, 0.45, -0.78, 0.3], ["c", -0.18, -0.09, -0.27, -0.18, -0.33, -0.33], ["c", -0.09, -0.18, -0.06, -0.3, 0.03, -0.54], ["c", 0.75, -1.5, 1.23, -3.45, 1.17, -4.89], ["c", -0.06, -1.02, -0.42, -2.01, -1.17, -3.15], ["c", -0.48, -0.72, -1.02, -1.35, -1.89, -2.22], ["c", -0.57, -0.57, -1.56, -1.5, -1.92, -1.77], ["l", -0.12, -0.09], ["l", 0, 1.68], ["l", 0, 1.68], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -15], ["z"], ["m", 0.93, -8.07], ["c", -0.27, -0.3, -0.48, -0.54, -0.51, -0.54], ["c", 0, 0, 0, 0.69, 0.03, 1.02], ["c", 0.15, 1.47, 0.75, 2.94, 2.04, 4.83], ["l", 1.08, 1.53], ["c", 0.39, 0.57, 0.84, 1.2, 0.99, 1.44], ["c", 0.15, 0.24, 0.3, 0.45, 0.3, 0.45], ["c", 0, 0, 0.03, -0.09, 0.06, -0.21], ["c", 0.36, -1.59, -0.15, -3.33, -1.47, -5.4], ["c", -0.63, -0.93, -1.35, -1.83, -2.52, -3.12], ["z"], ["m", 0.06, 6.72], ["c", -0.24, -0.21, -0.48, -0.42, -0.51, -0.45], ["l", -0.06, -0.06], ["l", 0, 0.33], ["c", 0, 1.2, 0.3, 2.34, 0.93, 3.6], ["c", 0.45, 0.9, 0.96, 1.68, 2.25, 3.51], ["c", 0.39, 0.54, 0.84, 1.17, 1.02, 1.44], ["c", 0.21, 0.33, 0.33, 0.51, 0.33, 0.48], ["c", 0.06, -0.09, 0.21, -0.63, 0.3, -0.99], ["c", 0.06, -0.33, 0.06, -0.45, 0.06, -0.96], ["c", 0, -0.6, -0.03, -0.84, -0.18, -1.35], ["c", -0.3, -1.08, -1.02, -2.28, -2.13, -3.57], ["c", -0.39, -0.45, -1.44, -1.47, -2.01, -1.98], ["z"], ["m", 0, 6.72], ["c", -0.24, -0.21, -0.48, -0.39, -0.51, -0.42], ["l", -0.06, -0.06], ["l", 0, 0.33], ["c", 0, 1.41, 0.45, 2.82, 1.38, 4.35], ["c", 0.42, 0.72, 0.72, 1.14, 1.86, 2.73], ["c", 0.36, 0.45, 0.75, 0.99, 0.87, 1.2], ["c", 0.15, 0.21, 0.3, 0.36, 0.3, 0.36], ["c", 0.06, 0, 0.3, -0.48, 0.39, -0.75], ["c", 0.09, -0.36, 0.12, -0.63, 0.12, -1.05], ["c", -0.06, -1.05, -0.45, -2.04, -1.2, -3.18], ["c", -0.57, -0.87, -1.11, -1.53, -2.07, -2.49], ["c", -0.36, -0.33, -0.84, -0.78, -1.08, -1.02], ["z"]], w: 6.682, h: 39.694 },
      "flags.d8th": { d: [["M", 5.67, -21.63], ["c", 0.24, -0.12, 0.54, -0.06, 0.69, 0.15], ["c", 0.06, 0.06, 0.21, 0.36, 0.39, 0.66], ["c", 0.84, 1.77, 1.26, 3.36, 1.32, 5.1], ["c", 0.03, 1.29, -0.21, 2.37, -0.81, 3.63], ["c", -0.6, 1.23, -1.26, 2.13, -3.21, 4.38], ["c", -1.35, 1.53, -1.86, 2.19, -2.4, 2.97], ["c", -0.63, 0.93, -1.11, 1.92, -1.38, 2.79], ["c", -0.15, 0.54, -0.27, 1.35, -0.27, 1.8], ["l", 0, 0.15], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -3.75], ["l", 0, -3.75], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0.48, -0.3], ["c", 1.83, -1.11, 3.12, -2.1, 4.17, -3.12], ["c", 0.78, -0.81, 1.32, -1.53, 1.71, -2.31], ["c", 0.45, -0.93, 0.6, -1.74, 0.51, -2.88], ["c", -0.12, -1.56, -0.63, -3.18, -1.47, -4.68], ["c", -0.12, -0.21, -0.15, -0.33, -0.06, -0.51], ["c", 0.06, -0.15, 0.15, -0.24, 0.33, -0.33], ["z"]], w: 8.492, h: 21.691 },
      "flags.ugrace": { d: [["M", 6.03, 6.93], ["c", 0.15, -0.09, 0.33, -0.06, 0.51, 0], ["c", 0.15, 0.09, 0.21, 0.15, 0.3, 0.33], ["c", 0.09, 0.18, 0.06, 0.39, -0.03, 0.54], ["c", -0.06, 0.15, -10.89, 8.88, -11.07, 8.97], ["c", -0.15, 0.09, -0.33, 0.06, -0.48, 0], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["c", -0.09, -0.18, -0.06, -0.39, 0.03, -0.54], ["c", 0.06, -0.15, 10.89, -8.88, 11.07, -8.97], ["z"]], w: 12.019, h: 9.954 },
      "flags.dgrace": { d: [["M", -6.06, -15.93], ["c", 0.18, -0.09, 0.33, -0.12, 0.48, -0.06], ["c", 0.18, 0.09, 14.01, 8.04, 14.1, 8.1], ["c", 0.12, 0.12, 0.18, 0.33, 0.18, 0.51], ["c", -0.03, 0.21, -0.15, 0.39, -0.36, 0.48], ["c", -0.18, 0.09, -0.33, 0.12, -0.48, 0.06], ["c", -0.18, -0.09, -14.01, -8.04, -14.1, -8.1], ["c", -0.12, -0.12, -0.18, -0.33, -0.18, -0.51], ["c", 0.03, -0.21, 0.15, -0.39, 0.36, -0.48], ["z"]], w: 15.12, h: 9.212 },
      "flags.d16th": { d: [["M", 6.84, -22.53], ["c", 0.27, -0.12, 0.57, -0.06, 0.72, 0.15], ["c", 0.15, 0.15, 0.33, 0.87, 0.45, 1.56], ["c", 0.06, 0.33, 0.06, 1.35, 0, 1.65], ["c", -0.06, 0.33, -0.15, 0.78, -0.27, 1.11], ["c", -0.12, 0.33, -0.45, 0.96, -0.66, 1.32], ["l", -0.18, 0.27], ["l", 0.09, 0.18], ["c", 0.48, 1.02, 0.72, 2.25, 0.69, 3.3], ["c", -0.06, 1.23, -0.42, 2.28, -1.26, 3.45], ["c", -0.57, 0.87, -0.99, 1.32, -3, 3.39], ["c", -1.56, 1.56, -2.22, 2.4, -2.76, 3.45], ["c", -0.42, 0.84, -0.66, 1.8, -0.66, 2.55], ["l", 0, 0.15], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -7.5], ["l", 0, -7.5], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 1.14], ["l", 0, 1.11], ["l", 0.27, -0.15], ["c", 1.11, -0.57, 1.77, -0.99, 2.52, -1.47], ["c", 2.37, -1.56, 3.69, -3.15, 4.05, -4.83], ["c", 0.03, -0.18, 0.03, -0.39, 0.03, -0.78], ["c", 0, -0.6, -0.03, -0.93, -0.24, -1.5], ["c", -0.06, -0.18, -0.12, -0.39, -0.15, -0.45], ["c", -0.03, -0.24, 0.12, -0.48, 0.36, -0.6], ["z"], ["m", -0.63, 7.5], ["c", -0.06, -0.18, -0.15, -0.36, -0.15, -0.36], ["c", -0.03, 0, -0.03, 0.03, -0.06, 0.06], ["c", -0.06, 0.12, -0.96, 1.02, -1.95, 1.98], ["c", -0.63, 0.57, -1.26, 1.17, -1.44, 1.35], ["c", -1.53, 1.62, -2.28, 2.85, -2.55, 4.32], ["c", -0.03, 0.18, -0.03, 0.54, -0.06, 0.99], ["l", 0, 0.69], ["l", 0.18, -0.09], ["c", 0.93, -0.54, 2.1, -1.29, 2.82, -1.83], ["c", 0.69, -0.51, 1.02, -0.81, 1.53, -1.29], ["c", 1.86, -1.89, 2.37, -3.66, 1.68, -5.82], ["z"]], w: 8.475, h: 22.591 },
      "flags.d32nd": { d: [["M", 6.84, -29.13], ["c", 0.27, -0.12, 0.57, -0.06, 0.72, 0.15], ["c", 0.12, 0.12, 0.27, 0.63, 0.36, 1.11], ["c", 0.33, 1.59, 0.06, 3.06, -0.81, 4.47], ["l", -0.18, 0.27], ["l", 0.09, 0.15], ["c", 0.12, 0.24, 0.33, 0.69, 0.45, 1.05], ["c", 0.63, 1.83, 0.45, 3.57, -0.57, 5.22], ["l", -0.18, 0.3], ["l", 0.15, 0.27], ["c", 0.42, 0.87, 0.6, 1.71, 0.57, 2.61], ["c", -0.06, 1.29, -0.48, 2.46, -1.35, 3.78], ["c", -0.54, 0.81, -0.93, 1.29, -2.46, 3], ["c", -0.51, 0.54, -1.05, 1.17, -1.26, 1.41], ["c", -1.56, 1.86, -2.25, 3.36, -2.37, 5.01], ["l", 0, 0.33], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -11.25], ["l", 0, -11.25], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 1.35], ["l", 0.03, 1.35], ["l", 0.78, -0.39], ["c", 1.38, -0.69, 2.34, -1.26, 3.24, -1.92], ["c", 1.38, -1.02, 2.28, -2.13, 2.64, -3.21], ["c", 0.15, -0.48, 0.18, -0.72, 0.18, -1.29], ["c", 0, -0.57, -0.06, -0.9, -0.24, -1.47], ["c", -0.06, -0.18, -0.12, -0.39, -0.15, -0.45], ["c", -0.03, -0.24, 0.12, -0.48, 0.36, -0.6], ["z"], ["m", -0.63, 7.2], ["c", -0.09, -0.18, -0.12, -0.21, -0.12, -0.15], ["c", -0.03, 0.09, -1.02, 1.08, -2.04, 2.04], ["c", -1.17, 1.08, -1.65, 1.56, -2.07, 2.04], ["c", -0.84, 0.96, -1.38, 1.86, -1.68, 2.76], ["c", -0.21, 0.57, -0.27, 0.99, -0.3, 1.65], ["l", 0, 0.54], ["l", 0.66, -0.33], ["c", 3.57, -1.86, 5.49, -3.69, 5.94, -5.7], ["c", 0.06, -0.39, 0.06, -1.2, -0.03, -1.65], ["c", -0.06, -0.39, -0.24, -0.9, -0.36, -1.2], ["z"], ["m", -0.06, 7.2], ["c", -0.06, -0.15, -0.12, -0.33, -0.15, -0.45], ["l", -0.06, -0.18], ["l", -0.18, 0.21], ["l", -1.83, 1.83], ["c", -0.87, 0.9, -1.77, 1.8, -1.95, 2.01], ["c", -1.08, 1.29, -1.62, 2.31, -1.89, 3.51], ["c", -0.06, 0.3, -0.06, 0.51, -0.09, 0.93], ["l", 0, 0.57], ["l", 0.09, -0.06], ["c", 0.75, -0.45, 1.89, -1.26, 2.52, -1.74], ["c", 0.81, -0.66, 1.74, -1.53, 2.22, -2.16], ["c", 1.26, -1.53, 1.68, -3.06, 1.32, -4.47], ["z"]], w: 8.385, h: 29.191 },
      "flags.d64th": { d: [["M", 7.08, -32.88], ["c", 0.3, -0.12, 0.66, -0.03, 0.78, 0.24], ["c", 0.18, 0.33, 0.27, 2.1, 0.15, 2.64], ["c", -0.09, 0.39, -0.21, 0.78, -0.39, 1.08], ["l", -0.15, 0.3], ["l", 0.09, 0.27], ["c", 0.03, 0.12, 0.09, 0.45, 0.12, 0.69], ["c", 0.27, 1.44, 0.18, 2.55, -0.3, 3.6], ["l", -0.12, 0.33], ["l", 0.06, 0.42], ["c", 0.27, 1.35, 0.33, 2.82, 0.21, 3.63], ["c", -0.12, 0.6, -0.3, 1.23, -0.57, 1.8], ["l", -0.15, 0.27], ["l", 0.03, 0.42], ["c", 0.06, 1.02, 0.06, 2.7, 0.03, 3.06], ["c", -0.15, 1.47, -0.66, 2.76, -1.74, 4.41], ["c", -0.45, 0.69, -0.75, 1.11, -1.74, 2.37], ["c", -1.05, 1.38, -1.5, 1.98, -1.95, 2.73], ["c", -0.93, 1.5, -1.38, 2.82, -1.44, 4.2], ["l", 0, 0.42], ["l", -0.21, 0], ["l", -0.21, 0], ["l", 0, -15], ["l", 0, -15], ["l", 0.21, 0], ["l", 0.21, 0], ["l", 0, 1.86], ["l", 0, 1.89], ["c", 0, 0, 0.21, -0.03, 0.45, -0.09], ["c", 2.22, -0.39, 4.08, -1.11, 5.19, -2.01], ["c", 0.63, -0.54, 1.02, -1.14, 1.2, -1.8], ["c", 0.06, -0.3, 0.06, -1.14, -0.03, -1.65], ["c", -0.03, -0.18, -0.06, -0.39, -0.09, -0.48], ["c", -0.03, -0.24, 0.12, -0.48, 0.36, -0.6], ["z"], ["m", -0.45, 6.15], ["c", -0.03, -0.18, -0.06, -0.42, -0.06, -0.54], ["l", -0.03, -0.18], ["l", -0.33, 0.3], ["c", -0.42, 0.36, -0.87, 0.72, -1.68, 1.29], ["c", -1.98, 1.38, -2.25, 1.59, -2.85, 2.16], ["c", -0.75, 0.69, -1.23, 1.44, -1.47, 2.19], ["c", -0.15, 0.45, -0.18, 0.63, -0.21, 1.35], ["l", 0, 0.66], ["l", 0.39, -0.18], ["c", 1.83, -0.9, 3.45, -1.95, 4.47, -2.91], ["c", 0.93, -0.9, 1.53, -1.83, 1.74, -2.82], ["c", 0.06, -0.33, 0.06, -0.87, 0.03, -1.32], ["z"], ["m", -0.27, 4.86], ["c", -0.03, -0.21, -0.06, -0.36, -0.06, -0.36], ["c", 0, -0.03, -0.12, 0.09, -0.24, 0.24], ["c", -0.39, 0.48, -0.99, 1.08, -2.16, 2.19], ["c", -1.47, 1.38, -1.92, 1.83, -2.46, 2.49], ["c", -0.66, 0.87, -1.08, 1.74, -1.29, 2.58], ["c", -0.09, 0.42, -0.15, 0.87, -0.15, 1.44], ["l", 0, 0.54], ["l", 0.48, -0.33], ["c", 1.5, -1.02, 2.58, -1.89, 3.51, -2.82], ["c", 1.47, -1.47, 2.25, -2.85, 2.4, -4.26], ["c", 0.03, -0.39, 0.03, -1.17, -0.03, -1.71], ["z"], ["m", -0.66, 7.68], ["c", 0.03, -0.15, 0.03, -0.6, 0.03, -0.99], ["l", 0, -0.72], ["l", -0.27, 0.33], ["l", -1.74, 1.98], ["c", -1.77, 1.92, -2.43, 2.76, -2.97, 3.9], ["c", -0.51, 1.02, -0.72, 1.77, -0.75, 2.91], ["c", 0, 0.63, 0, 0.63, 0.06, 0.6], ["c", 0.03, -0.03, 0.3, -0.27, 0.63, -0.54], ["c", 0.66, -0.6, 1.86, -1.8, 2.31, -2.31], ["c", 1.65, -1.89, 2.52, -3.54, 2.7, -5.16], ["z"]], w: 8.485, h: 32.932 },
      "clefs.C": { d: [["M", 0.06, -14.94], ["l", 0.09, -0.06], ["l", 1.92, 0], ["l", 1.92, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 14.85], ["l", 0, 14.82], ["l", -0.06, 0.09], ["l", -0.09, 0.06], ["l", -1.92, 0], ["l", -1.92, 0], ["l", -0.09, -0.06], ["l", -0.06, -0.09], ["l", 0, -14.82], ["l", 0, -14.85], ["z"], ["m", 5.37, 0], ["c", 0.09, -0.06, 0.09, -0.06, 0.57, -0.06], ["c", 0.45, 0, 0.45, 0, 0.54, 0.06], ["l", 0.06, 0.09], ["l", 0, 7.14], ["l", 0, 7.11], ["l", 0.09, -0.06], ["c", 0.18, -0.18, 0.72, -0.84, 0.96, -1.2], ["c", 0.3, -0.45, 0.66, -1.17, 0.84, -1.65], ["c", 0.36, -0.9, 0.57, -1.83, 0.6, -2.79], ["c", 0.03, -0.48, 0.03, -0.54, 0.09, -0.63], ["c", 0.12, -0.18, 0.36, -0.21, 0.54, -0.12], ["c", 0.18, 0.09, 0.21, 0.15, 0.24, 0.66], ["c", 0.06, 0.87, 0.21, 1.56, 0.57, 2.22], ["c", 0.51, 1.02, 1.26, 1.68, 2.22, 1.92], ["c", 0.21, 0.06, 0.33, 0.06, 0.78, 0.06], ["c", 0.45, 0, 0.57, 0, 0.84, -0.06], ["c", 0.45, -0.12, 0.81, -0.33, 1.08, -0.6], ["c", 0.57, -0.57, 0.87, -1.41, 0.99, -2.88], ["c", 0.06, -0.54, 0.06, -3, 0, -3.57], ["c", -0.21, -2.58, -0.84, -3.87, -2.16, -4.5], ["c", -0.48, -0.21, -1.17, -0.36, -1.77, -0.36], ["c", -0.69, 0, -1.29, 0.27, -1.5, 0.72], ["c", -0.06, 0.15, -0.06, 0.21, -0.06, 0.42], ["c", 0, 0.24, 0, 0.3, 0.06, 0.45], ["c", 0.12, 0.24, 0.24, 0.39, 0.63, 0.66], ["c", 0.42, 0.3, 0.57, 0.48, 0.69, 0.72], ["c", 0.06, 0.15, 0.06, 0.21, 0.06, 0.48], ["c", 0, 0.39, -0.03, 0.63, -0.21, 0.96], ["c", -0.3, 0.6, -0.87, 1.08, -1.5, 1.26], ["c", -0.27, 0.06, -0.87, 0.06, -1.14, 0], ["c", -0.78, -0.24, -1.44, -0.87, -1.65, -1.68], ["c", -0.12, -0.42, -0.09, -1.17, 0.09, -1.71], ["c", 0.51, -1.65, 1.98, -2.82, 3.81, -3.09], ["c", 0.84, -0.09, 2.46, 0.03, 3.51, 0.27], ["c", 2.22, 0.57, 3.69, 1.8, 4.44, 3.75], ["c", 0.36, 0.93, 0.57, 2.13, 0.57, 3.36], ["c", 0, 1.44, -0.48, 2.73, -1.38, 3.81], ["c", -1.26, 1.5, -3.27, 2.43, -5.28, 2.43], ["c", -0.48, 0, -0.51, 0, -0.75, -0.09], ["c", -0.15, -0.03, -0.48, -0.21, -0.78, -0.36], ["c", -0.69, -0.36, -0.87, -0.42, -1.26, -0.42], ["c", -0.27, 0, -0.3, 0, -0.51, 0.09], ["c", -0.57, 0.3, -0.81, 0.9, -0.81, 2.1], ["c", 0, 1.23, 0.24, 1.83, 0.81, 2.13], ["c", 0.21, 0.09, 0.24, 0.09, 0.51, 0.09], ["c", 0.39, 0, 0.57, -0.06, 1.26, -0.42], ["c", 0.3, -0.15, 0.63, -0.33, 0.78, -0.36], ["c", 0.24, -0.09, 0.27, -0.09, 0.75, -0.09], ["c", 2.01, 0, 4.02, 0.93, 5.28, 2.4], ["c", 0.9, 1.11, 1.38, 2.4, 1.38, 3.84], ["c", 0, 1.5, -0.3, 2.88, -0.84, 3.96], ["c", -0.78, 1.59, -2.19, 2.64, -4.17, 3.15], ["c", -1.05, 0.24, -2.67, 0.36, -3.51, 0.27], ["c", -1.83, -0.27, -3.3, -1.44, -3.81, -3.09], ["c", -0.18, -0.54, -0.21, -1.29, -0.09, -1.74], ["c", 0.15, -0.6, 0.63, -1.2, 1.23, -1.47], ["c", 0.36, -0.18, 0.57, -0.21, 0.99, -0.21], ["c", 0.42, 0, 0.63, 0.03, 1.02, 0.21], ["c", 0.42, 0.21, 0.84, 0.63, 1.05, 1.05], ["c", 0.18, 0.36, 0.21, 0.6, 0.21, 0.96], ["c", 0, 0.3, 0, 0.36, -0.06, 0.51], ["c", -0.12, 0.24, -0.27, 0.42, -0.69, 0.72], ["c", -0.57, 0.42, -0.69, 0.63, -0.69, 1.08], ["c", 0, 0.24, 0, 0.3, 0.06, 0.45], ["c", 0.12, 0.21, 0.3, 0.39, 0.57, 0.54], ["c", 0.42, 0.18, 0.87, 0.21, 1.53, 0.15], ["c", 1.08, -0.15, 1.8, -0.57, 2.34, -1.32], ["c", 0.54, -0.75, 0.84, -1.83, 0.99, -3.51], ["c", 0.06, -0.57, 0.06, -3.03, 0, -3.57], ["c", -0.12, -1.47, -0.42, -2.31, -0.99, -2.88], ["c", -0.27, -0.27, -0.63, -0.48, -1.08, -0.6], ["c", -0.27, -0.06, -0.39, -0.06, -0.84, -0.06], ["c", -0.45, 0, -0.57, 0, -0.78, 0.06], ["c", -1.14, 0.27, -2.01, 1.17, -2.46, 2.49], ["c", -0.21, 0.57, -0.3, 0.99, -0.33, 1.65], ["c", -0.03, 0.51, -0.06, 0.57, -0.24, 0.66], ["c", -0.12, 0.06, -0.27, 0.06, -0.39, 0], ["c", -0.21, -0.09, -0.21, -0.15, -0.24, -0.75], ["c", -0.09, -1.92, -0.78, -3.72, -2.01, -5.19], ["c", -0.18, -0.21, -0.36, -0.42, -0.39, -0.45], ["l", -0.09, -0.06], ["l", 0, 7.11], ["l", 0, 7.14], ["l", -0.06, 0.09], ["c", -0.09, 0.06, -0.09, 0.06, -0.54, 0.06], ["c", -0.48, 0, -0.48, 0, -0.57, -0.06], ["l", -0.06, -0.09], ["l", 0, -14.82], ["l", 0, -14.85], ["z"]], w: 20.31, h: 29.97 },
      "clefs.F": { d: [["M", 6.3, -7.8], ["c", 0.36, -0.03, 1.65, 0, 2.13, 0.03], ["c", 3.6, 0.42, 6.03, 2.1, 6.93, 4.86], ["c", 0.27, 0.84, 0.36, 1.5, 0.36, 2.58], ["c", 0, 0.9, -0.03, 1.35, -0.18, 2.16], ["c", -0.78, 3.78, -3.54, 7.08, -8.37, 9.96], ["c", -1.74, 1.05, -3.87, 2.13, -6.18, 3.12], ["c", -0.39, 0.18, -0.75, 0.33, -0.81, 0.36], ["c", -0.06, 0.03, -0.15, 0.06, -0.18, 0.06], ["c", -0.15, 0, -0.33, -0.18, -0.33, -0.33], ["c", 0, -0.15, 0.06, -0.21, 0.51, -0.48], ["c", 3, -1.77, 5.13, -3.21, 6.84, -4.74], ["c", 0.51, -0.45, 1.59, -1.5, 1.95, -1.95], ["c", 1.89, -2.19, 2.88, -4.32, 3.15, -6.78], ["c", 0.06, -0.42, 0.06, -1.77, 0, -2.19], ["c", -0.24, -2.01, -0.93, -3.63, -2.04, -4.71], ["c", -0.63, -0.63, -1.29, -1.02, -2.07, -1.2], ["c", -1.62, -0.39, -3.36, 0.15, -4.56, 1.44], ["c", -0.54, 0.6, -1.05, 1.47, -1.32, 2.22], ["l", -0.09, 0.21], ["l", 0.24, -0.12], ["c", 0.39, -0.21, 0.63, -0.24, 1.11, -0.24], ["c", 0.3, 0, 0.45, 0, 0.66, 0.06], ["c", 1.92, 0.48, 2.85, 2.55, 1.95, 4.38], ["c", -0.45, 0.99, -1.41, 1.62, -2.46, 1.71], ["c", -1.47, 0.09, -2.91, -0.87, -3.39, -2.25], ["c", -0.18, -0.57, -0.21, -1.32, -0.03, -2.28], ["c", 0.39, -2.25, 1.83, -4.2, 3.81, -5.19], ["c", 0.69, -0.36, 1.59, -0.6, 2.37, -0.69], ["z"], ["m", 11.58, 2.52], ["c", 0.84, -0.21, 1.71, 0.3, 1.89, 1.14], ["c", 0.3, 1.17, -0.72, 2.19, -1.89, 1.89], ["c", -0.99, -0.21, -1.5, -1.32, -1.02, -2.25], ["c", 0.18, -0.39, 0.6, -0.69, 1.02, -0.78], ["z"], ["m", 0, 7.5], ["c", 0.84, -0.21, 1.71, 0.3, 1.89, 1.14], ["c", 0.21, 0.87, -0.3, 1.71, -1.14, 1.89], ["c", -0.87, 0.21, -1.71, -0.3, -1.89, -1.14], ["c", -0.21, -0.84, 0.3, -1.71, 1.14, -1.89], ["z"]], w: 20.153, h: 23.142 },
      "clefs.G": { d: [["M", 9.69, -37.41], ["c", 0.09, -0.09, 0.24, -0.06, 0.36, 0], ["c", 0.12, 0.09, 0.57, 0.6, 0.96, 1.11], ["c", 1.77, 2.34, 3.21, 5.85, 3.57, 8.73], ["c", 0.21, 1.56, 0.03, 3.27, -0.45, 4.86], ["c", -0.69, 2.31, -1.92, 4.47, -4.23, 7.44], ["c", -0.3, 0.39, -0.57, 0.72, -0.6, 0.75], ["c", -0.03, 0.06, 0, 0.15, 0.18, 0.78], ["c", 0.54, 1.68, 1.38, 4.44, 1.68, 5.49], ["l", 0.09, 0.42], ["l", 0.39, 0], ["c", 1.47, 0.09, 2.76, 0.51, 3.96, 1.29], ["c", 1.83, 1.23, 3.06, 3.21, 3.39, 5.52], ["c", 0.09, 0.45, 0.12, 1.29, 0.06, 1.74], ["c", -0.09, 1.02, -0.33, 1.83, -0.75, 2.73], ["c", -0.84, 1.71, -2.28, 3.06, -4.02, 3.72], ["l", -0.33, 0.12], ["l", 0.03, 1.26], ["c", 0, 1.74, -0.06, 3.63, -0.21, 4.62], ["c", -0.45, 3.06, -2.19, 5.49, -4.47, 6.21], ["c", -0.57, 0.18, -0.9, 0.21, -1.59, 0.21], ["c", -0.69, 0, -1.02, -0.03, -1.65, -0.21], ["c", -1.14, -0.27, -2.13, -0.84, -2.94, -1.65], ["c", -0.99, -0.99, -1.56, -2.16, -1.71, -3.54], ["c", -0.09, -0.81, 0.06, -1.53, 0.45, -2.13], ["c", 0.63, -0.99, 1.83, -1.56, 3, -1.53], ["c", 1.5, 0.09, 2.64, 1.32, 2.73, 2.94], ["c", 0.06, 1.47, -0.93, 2.7, -2.37, 2.97], ["c", -0.45, 0.06, -0.84, 0.03, -1.29, -0.09], ["l", -0.21, -0.09], ["l", 0.09, 0.12], ["c", 0.39, 0.54, 0.78, 0.93, 1.32, 1.26], ["c", 1.35, 0.87, 3.06, 1.02, 4.35, 0.36], ["c", 1.44, -0.72, 2.52, -2.28, 2.97, -4.35], ["c", 0.15, -0.66, 0.24, -1.5, 0.3, -3.03], ["c", 0.03, -0.84, 0.03, -2.94, 0, -3], ["c", -0.03, 0, -0.18, 0, -0.36, 0.03], ["c", -0.66, 0.12, -0.99, 0.12, -1.83, 0.12], ["c", -1.05, 0, -1.71, -0.06, -2.61, -0.3], ["c", -4.02, -0.99, -7.11, -4.35, -7.8, -8.46], ["c", -0.12, -0.66, -0.12, -0.99, -0.12, -1.83], ["c", 0, -0.84, 0, -1.14, 0.15, -1.92], ["c", 0.36, -2.28, 1.41, -4.62, 3.3, -7.29], ["l", 2.79, -3.6], ["c", 0.54, -0.66, 0.96, -1.2, 0.96, -1.23], ["c", 0, -0.03, -0.09, -0.33, -0.18, -0.69], ["c", -0.96, -3.21, -1.41, -5.28, -1.59, -7.68], ["c", -0.12, -1.38, -0.15, -3.09, -0.06, -3.96], ["c", 0.33, -2.67, 1.38, -5.07, 3.12, -7.08], ["c", 0.36, -0.42, 0.99, -1.05, 1.17, -1.14], ["z"], ["m", 2.01, 4.71], ["c", -0.15, -0.3, -0.3, -0.54, -0.3, -0.54], ["c", -0.03, 0, -0.18, 0.09, -0.3, 0.21], ["c", -2.4, 1.74, -3.87, 4.2, -4.26, 7.11], ["c", -0.06, 0.54, -0.06, 1.41, -0.03, 1.89], ["c", 0.09, 1.29, 0.48, 3.12, 1.08, 5.22], ["c", 0.15, 0.42, 0.24, 0.78, 0.24, 0.81], ["c", 0, 0.03, 0.84, -1.11, 1.23, -1.68], ["c", 1.89, -2.73, 2.88, -5.07, 3.15, -7.53], ["c", 0.09, -0.57, 0.12, -1.74, 0.06, -2.37], ["c", -0.09, -1.23, -0.27, -1.92, -0.87, -3.12], ["z"], ["m", -2.94, 20.7], ["c", -0.21, -0.72, -0.39, -1.32, -0.42, -1.32], ["c", 0, 0, -1.2, 1.47, -1.86, 2.37], ["c", -2.79, 3.63, -4.02, 6.3, -4.35, 9.3], ["c", -0.03, 0.21, -0.03, 0.69, -0.03, 1.08], ["c", 0, 0.69, 0, 0.75, 0.06, 1.11], ["c", 0.12, 0.54, 0.27, 0.99, 0.51, 1.47], ["c", 0.69, 1.38, 1.83, 2.55, 3.42, 3.42], ["c", 0.96, 0.54, 2.07, 0.9, 3.21, 1.08], ["c", 0.78, 0.12, 2.04, 0.12, 2.94, -0.03], ["c", 0.51, -0.06, 0.45, -0.03, 0.42, -0.3], ["c", -0.24, -3.33, -0.72, -6.33, -1.62, -10.08], ["c", -0.09, -0.39, -0.18, -0.75, -0.18, -0.78], ["c", -0.03, -0.03, -0.42, 0, -0.81, 0.09], ["c", -0.9, 0.18, -1.65, 0.57, -2.22, 1.14], ["c", -0.72, 0.72, -1.08, 1.65, -1.05, 2.64], ["c", 0.06, 0.96, 0.48, 1.83, 1.23, 2.58], ["c", 0.36, 0.36, 0.72, 0.63, 1.17, 0.9], ["c", 0.33, 0.18, 0.36, 0.21, 0.42, 0.33], ["c", 0.18, 0.42, -0.18, 0.9, -0.6, 0.87], ["c", -0.18, -0.03, -0.84, -0.36, -1.26, -0.63], ["c", -0.78, -0.51, -1.38, -1.11, -1.86, -1.83], ["c", -1.77, -2.7, -0.99, -6.42, 1.71, -8.19], ["c", 0.3, -0.21, 0.81, -0.48, 1.17, -0.63], ["c", 0.3, -0.09, 1.02, -0.3, 1.14, -0.3], ["c", 0.06, 0, 0.09, 0, 0.09, -0.03], ["c", 0.03, -0.03, -0.51, -1.92, -1.23, -4.26], ["z"], ["m", 3.78, 7.41], ["c", -0.18, -0.03, -0.36, -0.06, -0.39, -0.06], ["c", -0.03, 0, 0, 0.21, 0.18, 1.02], ["c", 0.75, 3.18, 1.26, 6.3, 1.5, 9.09], ["c", 0.06, 0.72, 0, 0.69, 0.51, 0.42], ["c", 0.78, -0.36, 1.44, -0.96, 1.98, -1.77], ["c", 1.08, -1.62, 1.2, -3.69, 0.3, -5.55], ["c", -0.81, -1.62, -2.31, -2.79, -4.08, -3.15], ["z"]], w: 19.051, h: 57.057 },
      "clefs.perc": { d: [["M", 5.07, -7.44], ["l", 0.09, -0.06], ["l", 1.53, 0], ["l", 1.53, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 7.35], ["l", 0, 7.32], ["l", -0.06, 0.09], ["l", -0.09, 0.06], ["l", -1.53, 0], ["l", -1.53, 0], ["l", -0.09, -0.06], ["l", -0.06, -0.09], ["l", 0, -7.32], ["l", 0, -7.35], ["z"], ["m", 6.63, 0], ["l", 0.09, -0.06], ["l", 1.53, 0], ["l", 1.53, 0], ["l", 0.09, 0.06], ["l", 0.06, 0.09], ["l", 0, 7.35], ["l", 0, 7.32], ["l", -0.06, 0.09], ["l", -0.09, 0.06], ["l", -1.53, 0], ["l", -1.53, 0], ["l", -0.09, -0.06], ["l", -0.06, -0.09], ["l", 0, -7.32], ["l", 0, -7.35], ["z"]], w: 9.99, h: 14.97 },
      "timesig.common": { d: [["M", 6.66, -7.83], ["c", 0.72, -0.06, 1.41, -0.03, 1.98, 0.09], ["c", 1.2, 0.27, 2.34, 0.96, 3.09, 1.92], ["c", 0.63, 0.81, 1.08, 1.86, 1.14, 2.73], ["c", 0.06, 1.02, -0.51, 1.92, -1.44, 2.22], ["c", -0.24, 0.09, -0.3, 0.09, -0.63, 0.09], ["c", -0.33, 0, -0.42, 0, -0.63, -0.06], ["c", -0.66, -0.24, -1.14, -0.63, -1.41, -1.2], ["c", -0.15, -0.3, -0.21, -0.51, -0.24, -0.9], ["c", -0.06, -1.08, 0.57, -2.04, 1.56, -2.37], ["c", 0.18, -0.06, 0.27, -0.06, 0.63, -0.06], ["l", 0.45, 0], ["c", 0.06, 0.03, 0.09, 0.03, 0.09, 0], ["c", 0, 0, -0.09, -0.12, -0.24, -0.27], ["c", -1.02, -1.11, -2.55, -1.68, -4.08, -1.5], ["c", -1.29, 0.15, -2.04, 0.69, -2.4, 1.74], ["c", -0.36, 0.93, -0.42, 1.89, -0.42, 5.37], ["c", 0, 2.97, 0.06, 3.96, 0.24, 4.77], ["c", 0.24, 1.08, 0.63, 1.68, 1.41, 2.07], ["c", 0.81, 0.39, 2.16, 0.45, 3.18, 0.09], ["c", 1.29, -0.45, 2.37, -1.53, 3.03, -2.97], ["c", 0.15, -0.33, 0.33, -0.87, 0.39, -1.17], ["c", 0.09, -0.24, 0.15, -0.36, 0.3, -0.39], ["c", 0.21, -0.03, 0.42, 0.15, 0.39, 0.36], ["c", -0.06, 0.39, -0.42, 1.38, -0.69, 1.89], ["c", -0.96, 1.8, -2.49, 2.94, -4.23, 3.18], ["c", -0.99, 0.12, -2.58, -0.06, -3.63, -0.45], ["c", -0.96, -0.36, -1.71, -0.84, -2.4, -1.5], ["c", -1.11, -1.11, -1.8, -2.61, -2.04, -4.56], ["c", -0.06, -0.6, -0.06, -2.01, 0, -2.61], ["c", 0.24, -1.95, 0.9, -3.45, 2.01, -4.56], ["c", 0.69, -0.66, 1.44, -1.11, 2.37, -1.47], ["c", 0.63, -0.24, 1.47, -0.42, 2.22, -0.48], ["z"]], w: 13.038, h: 15.689 },
      "timesig.cut": { d: [["M", 6.24, -10.44], ["c", 0.09, -0.06, 0.09, -0.06, 0.48, -0.06], ["c", 0.36, 0, 0.36, 0, 0.45, 0.06], ["l", 0.06, 0.09], ["l", 0, 1.23], ["l", 0, 1.26], ["l", 0.27, 0], ["c", 1.26, 0, 2.49, 0.45, 3.48, 1.29], ["c", 1.05, 0.87, 1.8, 2.28, 1.89, 3.48], ["c", 0.06, 1.02, -0.51, 1.92, -1.44, 2.22], ["c", -0.24, 0.09, -0.3, 0.09, -0.63, 0.09], ["c", -0.33, 0, -0.42, 0, -0.63, -0.06], ["c", -0.66, -0.24, -1.14, -0.63, -1.41, -1.2], ["c", -0.15, -0.3, -0.21, -0.51, -0.24, -0.9], ["c", -0.06, -1.08, 0.57, -2.04, 1.56, -2.37], ["c", 0.18, -0.06, 0.27, -0.06, 0.63, -0.06], ["l", 0.45, 0], ["c", 0.06, 0.03, 0.09, 0.03, 0.09, 0], ["c", 0, -0.03, -0.45, -0.51, -0.66, -0.69], ["c", -0.87, -0.69, -1.83, -1.05, -2.94, -1.11], ["l", -0.42, 0], ["l", 0, 7.17], ["l", 0, 7.14], ["l", 0.42, 0], ["c", 0.69, -0.03, 1.23, -0.18, 1.86, -0.51], ["c", 1.05, -0.51, 1.89, -1.47, 2.46, -2.7], ["c", 0.15, -0.33, 0.33, -0.87, 0.39, -1.17], ["c", 0.09, -0.24, 0.15, -0.36, 0.3, -0.39], ["c", 0.21, -0.03, 0.42, 0.15, 0.39, 0.36], ["c", -0.03, 0.24, -0.21, 0.78, -0.39, 1.2], ["c", -0.96, 2.37, -2.94, 3.9, -5.13, 3.9], ["l", -0.3, 0], ["l", 0, 1.26], ["l", 0, 1.23], ["l", -0.06, 0.09], ["c", -0.09, 0.06, -0.09, 0.06, -0.45, 0.06], ["c", -0.39, 0, -0.39, 0, -0.48, -0.06], ["l", -0.06, -0.09], ["l", 0, -1.29], ["l", 0, -1.29], ["l", -0.21, -0.03], ["c", -1.23, -0.21, -2.31, -0.63, -3.21, -1.29], ["c", -0.15, -0.09, -0.45, -0.36, -0.66, -0.57], ["c", -1.11, -1.11, -1.8, -2.61, -2.04, -4.56], ["c", -0.06, -0.6, -0.06, -2.01, 0, -2.61], ["c", 0.24, -1.95, 0.93, -3.45, 2.04, -4.59], ["c", 0.42, -0.39, 0.78, -0.66, 1.26, -0.93], ["c", 0.75, -0.45, 1.65, -0.75, 2.61, -0.9], ["l", 0.21, -0.03], ["l", 0, -1.29], ["l", 0, -1.29], ["z"], ["m", -0.06, 10.44], ["c", 0, -5.58, 0, -6.99, -0.03, -6.99], ["c", -0.15, 0, -0.63, 0.27, -0.87, 0.45], ["c", -0.45, 0.36, -0.75, 0.93, -0.93, 1.77], ["c", -0.18, 0.81, -0.24, 1.8, -0.24, 4.74], ["c", 0, 2.97, 0.06, 3.96, 0.24, 4.77], ["c", 0.24, 1.08, 0.66, 1.68, 1.41, 2.07], ["c", 0.12, 0.06, 0.3, 0.12, 0.33, 0.15], ["l", 0.09, 0], ["l", 0, -6.96], ["z"]], w: 13.038, h: 20.97 },
      "timesig.imperfectum": { d: [["M", 13, -5], ["a", 8, 8, 0, 1, 0, 0, 10]], w: 13.038, h: 20.97 },
      "timesig.imperfectum2": { d: [["M", 13, -5], ["a", 8, 8, 0, 1, 0, 0, 10]], w: 13.038, h: 20.97 },
      "timesig.perfectum": { d: [["M", 13, -5], ["a", 8, 8, 0, 1, 0, 0, 10]], w: 13.038, h: 20.97 },
      "timesig.perfectum2": { d: [["M", 13, -5], ["a", 8, 8, 0, 1, 0, 0, 10]], w: 13.038, h: 20.97 },
      "f": { d: [["M", 9.93, -14.28], ["c", 1.53, -0.18, 2.88, 0.45, 3.12, 1.5], ["c", 0.12, 0.51, 0, 1.32, -0.27, 1.86], ["c", -0.15, 0.3, -0.42, 0.57, -0.63, 0.69], ["c", -0.69, 0.36, -1.56, 0.03, -1.83, -0.69], ["c", -0.09, -0.24, -0.09, -0.69, 0, -0.87], ["c", 0.06, -0.12, 0.21, -0.24, 0.45, -0.42], ["c", 0.42, -0.24, 0.57, -0.45, 0.6, -0.72], ["c", 0.03, -0.33, -0.09, -0.39, -0.63, -0.42], ["c", -0.3, 0, -0.45, 0, -0.6, 0.03], ["c", -0.81, 0.21, -1.35, 0.93, -1.74, 2.46], ["c", -0.06, 0.27, -0.48, 2.25, -0.48, 2.31], ["c", 0, 0.03, 0.39, 0.03, 0.9, 0.03], ["c", 0.72, 0, 0.9, 0, 0.99, 0.06], ["c", 0.42, 0.15, 0.45, 0.72, 0.03, 0.9], ["c", -0.12, 0.06, -0.24, 0.06, -1.17, 0.06], ["l", -1.05, 0], ["l", -0.78, 2.55], ["c", -0.45, 1.41, -0.87, 2.79, -0.96, 3.06], ["c", -0.87, 2.37, -2.37, 4.74, -3.78, 5.91], ["c", -1.05, 0.9, -2.04, 1.23, -3.09, 1.08], ["c", -1.11, -0.18, -1.89, -0.78, -2.04, -1.59], ["c", -0.12, -0.66, 0.15, -1.71, 0.54, -2.19], ["c", 0.69, -0.75, 1.86, -0.54, 2.22, 0.39], ["c", 0.06, 0.15, 0.09, 0.27, 0.09, 0.48], ["c", 0, 0.24, -0.03, 0.27, -0.12, 0.42], ["c", -0.03, 0.09, -0.15, 0.18, -0.27, 0.27], ["c", -0.09, 0.06, -0.27, 0.21, -0.36, 0.27], ["c", -0.24, 0.18, -0.36, 0.36, -0.39, 0.6], ["c", -0.03, 0.33, 0.09, 0.39, 0.63, 0.42], ["c", 0.42, 0, 0.63, -0.03, 0.9, -0.15], ["c", 0.6, -0.3, 0.96, -0.96, 1.38, -2.64], ["c", 0.09, -0.42, 0.63, -2.55, 1.17, -4.77], ["l", 1.02, -4.08], ["c", 0, -0.03, -0.36, -0.03, -0.81, -0.03], ["c", -0.72, 0, -0.81, 0, -0.93, -0.06], ["c", -0.42, -0.18, -0.39, -0.75, 0.03, -0.9], ["c", 0.09, -0.06, 0.27, -0.06, 1.05, -0.06], ["l", 0.96, 0], ["l", 0, -0.09], ["c", 0.06, -0.18, 0.3, -0.72, 0.51, -1.17], ["c", 1.2, -2.46, 3.3, -4.23, 5.34, -4.5], ["z"]], w: 16.155, h: 19.445 },
      "m": { d: [["M", 2.79, -8.91], ["c", 0.09, 0, 0.3, -0.03, 0.45, -0.03], ["c", 0.24, 0.03, 0.3, 0.03, 0.45, 0.12], ["c", 0.36, 0.15, 0.63, 0.54, 0.75, 1.02], ["l", 0.03, 0.21], ["l", 0.33, -0.3], ["c", 0.69, -0.69, 1.38, -1.02, 2.07, -1.02], ["c", 0.27, 0, 0.33, 0, 0.48, 0.06], ["c", 0.21, 0.09, 0.48, 0.36, 0.63, 0.6], ["c", 0.03, 0.09, 0.12, 0.27, 0.18, 0.42], ["c", 0.03, 0.15, 0.09, 0.27, 0.12, 0.27], ["c", 0, 0, 0.09, -0.09, 0.18, -0.21], ["c", 0.33, -0.39, 0.87, -0.81, 1.29, -0.99], ["c", 0.78, -0.33, 1.47, -0.21, 2.01, 0.33], ["c", 0.3, 0.33, 0.48, 0.69, 0.6, 1.14], ["c", 0.09, 0.42, 0.06, 0.54, -0.54, 3.06], ["c", -0.33, 1.29, -0.57, 2.4, -0.57, 2.43], ["c", 0, 0.12, 0.09, 0.21, 0.21, 0.21], ["c", 0.24, 0, 0.75, -0.3, 1.2, -0.72], ["c", 0.45, -0.39, 0.6, -0.45, 0.78, -0.27], ["c", 0.18, 0.18, 0.09, 0.36, -0.45, 0.87], ["c", -1.05, 0.96, -1.83, 1.47, -2.58, 1.71], ["c", -0.93, 0.33, -1.53, 0.21, -1.8, -0.33], ["c", -0.06, -0.15, -0.06, -0.21, -0.06, -0.45], ["c", 0, -0.24, 0.03, -0.48, 0.6, -2.82], ["c", 0.42, -1.71, 0.6, -2.64, 0.63, -2.79], ["c", 0.03, -0.57, -0.3, -0.75, -0.84, -0.48], ["c", -0.24, 0.12, -0.54, 0.39, -0.66, 0.63], ["c", -0.03, 0.09, -0.42, 1.38, -0.9, 3], ["c", -0.9, 3.15, -0.84, 3, -1.14, 3.15], ["l", -0.15, 0.09], ["l", -0.78, 0], ["c", -0.6, 0, -0.78, 0, -0.84, -0.06], ["c", -0.09, -0.03, -0.18, -0.18, -0.18, -0.27], ["c", 0, -0.03, 0.36, -1.38, 0.84, -2.97], ["c", 0.57, -2.04, 0.81, -2.97, 0.84, -3.12], ["c", 0.03, -0.54, -0.3, -0.72, -0.84, -0.45], ["c", -0.24, 0.12, -0.57, 0.42, -0.66, 0.63], ["c", -0.06, 0.09, -0.51, 1.44, -1.05, 2.97], ["c", -0.51, 1.56, -0.99, 2.85, -0.99, 2.91], ["c", -0.06, 0.12, -0.21, 0.24, -0.36, 0.3], ["c", -0.12, 0.06, -0.21, 0.06, -0.9, 0.06], ["c", -0.6, 0, -0.78, 0, -0.84, -0.06], ["c", -0.09, -0.03, -0.18, -0.18, -0.18, -0.27], ["c", 0, -0.03, 0.45, -1.38, 0.99, -2.97], ["c", 1.05, -3.18, 1.05, -3.18, 0.93, -3.45], ["c", -0.12, -0.27, -0.39, -0.3, -0.72, -0.15], ["c", -0.54, 0.27, -1.14, 1.17, -1.56, 2.4], ["c", -0.06, 0.15, -0.15, 0.3, -0.18, 0.36], ["c", -0.21, 0.21, -0.57, 0.27, -0.72, 0.09], ["c", -0.09, -0.09, -0.06, -0.21, 0.06, -0.63], ["c", 0.48, -1.26, 1.26, -2.46, 2.01, -3.21], ["c", 0.57, -0.54, 1.2, -0.87, 1.83, -1.02], ["z"]], w: 14.687, h: 9.126 },
      "p": { d: [["M", 1.92, -8.7], ["c", 0.27, -0.09, 0.81, -0.06, 1.11, 0.03], ["c", 0.54, 0.18, 0.93, 0.51, 1.17, 0.99], ["c", 0.09, 0.15, 0.15, 0.33, 0.18, 0.36], ["l", 0, 0.12], ["l", 0.3, -0.27], ["c", 0.66, -0.6, 1.35, -1.02, 2.13, -1.2], ["c", 0.21, -0.06, 0.33, -0.06, 0.78, -0.06], ["c", 0.45, 0, 0.51, 0, 0.84, 0.09], ["c", 1.29, 0.33, 2.07, 1.32, 2.25, 2.79], ["c", 0.09, 0.81, -0.09, 2.01, -0.45, 2.79], ["c", -0.54, 1.26, -1.86, 2.55, -3.18, 3.03], ["c", -0.45, 0.18, -0.81, 0.24, -1.29, 0.24], ["c", -0.69, -0.03, -1.35, -0.18, -1.86, -0.45], ["c", -0.3, -0.15, -0.51, -0.18, -0.69, -0.09], ["c", -0.09, 0.03, -0.18, 0.09, -0.18, 0.12], ["c", -0.09, 0.12, -1.05, 2.94, -1.05, 3.06], ["c", 0, 0.24, 0.18, 0.48, 0.51, 0.63], ["c", 0.18, 0.06, 0.54, 0.15, 0.75, 0.15], ["c", 0.21, 0, 0.36, 0.06, 0.42, 0.18], ["c", 0.12, 0.18, 0.06, 0.42, -0.12, 0.54], ["c", -0.09, 0.03, -0.15, 0.03, -0.78, 0], ["c", -1.98, -0.15, -3.81, -0.15, -5.79, 0], ["c", -0.63, 0.03, -0.69, 0.03, -0.78, 0], ["c", -0.24, -0.15, -0.24, -0.57, 0.03, -0.66], ["c", 0.06, -0.03, 0.48, -0.09, 0.99, -0.12], ["c", 0.87, -0.06, 1.11, -0.09, 1.35, -0.21], ["c", 0.18, -0.06, 0.33, -0.18, 0.39, -0.3], ["c", 0.06, -0.12, 3.24, -9.42, 3.27, -9.6], ["c", 0.06, -0.33, 0.03, -0.57, -0.15, -0.69], ["c", -0.09, -0.06, -0.12, -0.06, -0.3, -0.06], ["c", -0.69, 0.06, -1.53, 1.02, -2.28, 2.61], ["c", -0.09, 0.21, -0.21, 0.45, -0.27, 0.51], ["c", -0.09, 0.12, -0.33, 0.24, -0.48, 0.24], ["c", -0.18, 0, -0.36, -0.15, -0.36, -0.3], ["c", 0, -0.24, 0.78, -1.83, 1.26, -2.55], ["c", 0.72, -1.11, 1.47, -1.74, 2.28, -1.92], ["z"], ["m", 5.37, 1.47], ["c", -0.27, -0.12, -0.75, -0.03, -1.14, 0.21], ["c", -0.75, 0.48, -1.47, 1.68, -1.89, 3.15], ["c", -0.45, 1.47, -0.42, 2.34, 0, 2.7], ["c", 0.45, 0.39, 1.26, 0.21, 1.83, -0.36], ["c", 0.51, -0.51, 0.99, -1.68, 1.38, -3.27], ["c", 0.3, -1.17, 0.33, -1.74, 0.15, -2.13], ["c", -0.09, -0.15, -0.15, -0.21, -0.33, -0.3], ["z"]], w: 14.689, h: 13.127 },
      "r": { d: [["M", 6.33, -9.12], ["c", 0.27, -0.03, 0.93, 0, 1.2, 0.06], ["c", 0.84, 0.21, 1.23, 0.81, 1.02, 1.53], ["c", -0.24, 0.75, -0.9, 1.17, -1.56, 0.96], ["c", -0.33, -0.09, -0.51, -0.3, -0.66, -0.75], ["c", -0.03, -0.12, -0.09, -0.24, -0.12, -0.3], ["c", -0.09, -0.15, -0.3, -0.24, -0.48, -0.24], ["c", -0.57, 0, -1.38, 0.54, -1.65, 1.08], ["c", -0.06, 0.15, -0.33, 1.17, -0.9, 3.27], ["c", -0.57, 2.31, -0.81, 3.12, -0.87, 3.21], ["c", -0.03, 0.06, -0.12, 0.15, -0.18, 0.21], ["l", -0.12, 0.06], ["l", -0.81, 0.03], ["c", -0.69, 0, -0.81, 0, -0.9, -0.03], ["c", -0.09, -0.06, -0.18, -0.21, -0.18, -0.3], ["c", 0, -0.06, 0.39, -1.62, 0.9, -3.51], ["c", 0.84, -3.24, 0.87, -3.45, 0.87, -3.72], ["c", 0, -0.21, 0, -0.27, -0.03, -0.36], ["c", -0.12, -0.15, -0.21, -0.24, -0.42, -0.24], ["c", -0.24, 0, -0.45, 0.15, -0.78, 0.42], ["c", -0.33, 0.36, -0.45, 0.54, -0.72, 1.14], ["c", -0.03, 0.12, -0.21, 0.24, -0.36, 0.27], ["c", -0.12, 0, -0.15, 0, -0.24, -0.06], ["c", -0.18, -0.12, -0.18, -0.21, -0.06, -0.54], ["c", 0.21, -0.57, 0.42, -0.93, 0.78, -1.32], ["c", 0.54, -0.51, 1.2, -0.81, 1.95, -0.87], ["c", 0.81, -0.03, 1.53, 0.3, 1.92, 0.87], ["l", 0.12, 0.18], ["l", 0.09, -0.09], ["c", 0.57, -0.45, 1.41, -0.84, 2.19, -0.96], ["z"]], w: 9.41, h: 9.132 },
      "s": { d: [["M", 4.47, -8.73], ["c", 0.09, 0, 0.36, -0.03, 0.57, -0.03], ["c", 0.75, 0.03, 1.29, 0.24, 1.71, 0.63], ["c", 0.51, 0.54, 0.66, 1.26, 0.36, 1.83], ["c", -0.24, 0.42, -0.63, 0.57, -1.11, 0.42], ["c", -0.33, -0.09, -0.6, -0.36, -0.6, -0.57], ["c", 0, -0.03, 0.06, -0.21, 0.15, -0.39], ["c", 0.12, -0.21, 0.15, -0.33, 0.18, -0.48], ["c", 0, -0.24, -0.06, -0.48, -0.15, -0.6], ["c", -0.15, -0.21, -0.42, -0.24, -0.75, -0.15], ["c", -0.27, 0.06, -0.48, 0.18, -0.69, 0.36], ["c", -0.39, 0.39, -0.51, 0.96, -0.33, 1.38], ["c", 0.09, 0.21, 0.42, 0.51, 0.78, 0.72], ["c", 1.11, 0.69, 1.59, 1.11, 1.89, 1.68], ["c", 0.21, 0.39, 0.24, 0.78, 0.15, 1.29], ["c", -0.18, 1.2, -1.17, 2.16, -2.52, 2.52], ["c", -1.02, 0.24, -1.95, 0.12, -2.7, -0.42], ["c", -0.72, -0.51, -0.99, -1.47, -0.6, -2.19], ["c", 0.24, -0.48, 0.72, -0.63, 1.17, -0.42], ["c", 0.33, 0.18, 0.54, 0.45, 0.57, 0.81], ["c", 0, 0.21, -0.03, 0.3, -0.33, 0.51], ["c", -0.33, 0.24, -0.39, 0.42, -0.27, 0.69], ["c", 0.06, 0.15, 0.21, 0.27, 0.45, 0.33], ["c", 0.3, 0.09, 0.87, 0.09, 1.2, 0], ["c", 0.75, -0.21, 1.23, -0.72, 1.29, -1.35], ["c", 0.03, -0.42, -0.15, -0.81, -0.54, -1.2], ["c", -0.24, -0.24, -0.48, -0.42, -1.41, -1.02], ["c", -0.69, -0.42, -1.05, -0.93, -1.05, -1.47], ["c", 0, -0.39, 0.12, -0.87, 0.3, -1.23], ["c", 0.27, -0.57, 0.78, -1.05, 1.38, -1.35], ["c", 0.24, -0.12, 0.63, -0.27, 0.9, -0.3], ["z"]], w: 6.632, h: 8.758 },
      "z": { d: [["M", 2.64, -7.95], ["c", 0.36, -0.09, 0.81, -0.03, 1.71, 0.27], ["c", 0.78, 0.21, 0.96, 0.27, 1.74, 0.3], ["c", 0.87, 0.06, 1.02, 0.03, 1.38, -0.21], ["c", 0.21, -0.15, 0.33, -0.15, 0.48, -0.06], ["c", 0.15, 0.09, 0.21, 0.3, 0.15, 0.45], ["c", -0.03, 0.06, -1.26, 1.26, -2.76, 2.67], ["l", -2.73, 2.55], ["l", 0.54, 0.03], ["c", 0.54, 0.03, 0.72, 0.03, 2.01, 0.15], ["c", 0.36, 0.03, 0.9, 0.06, 1.2, 0.09], ["c", 0.66, 0, 0.81, -0.03, 1.02, -0.24], ["c", 0.3, -0.3, 0.39, -0.72, 0.27, -1.23], ["c", -0.06, -0.27, -0.06, -0.27, -0.03, -0.39], ["c", 0.15, -0.3, 0.54, -0.27, 0.69, 0.03], ["c", 0.15, 0.33, 0.27, 1.02, 0.27, 1.5], ["c", 0, 1.47, -1.11, 2.7, -2.52, 2.79], ["c", -0.57, 0.03, -1.02, -0.09, -2.01, -0.51], ["c", -1.02, -0.42, -1.23, -0.48, -2.13, -0.54], ["c", -0.81, -0.06, -0.96, -0.03, -1.26, 0.18], ["c", -0.12, 0.06, -0.24, 0.12, -0.27, 0.12], ["c", -0.27, 0, -0.45, -0.3, -0.36, -0.51], ["c", 0.03, -0.06, 1.32, -1.32, 2.91, -2.79], ["l", 2.88, -2.73], ["c", -0.03, 0, -0.21, 0.03, -0.42, 0.06], ["c", -0.21, 0.03, -0.78, 0.09, -1.23, 0.12], ["c", -1.11, 0.12, -1.23, 0.15, -1.95, 0.27], ["c", -0.72, 0.15, -1.17, 0.18, -1.29, 0.09], ["c", -0.27, -0.18, -0.21, -0.75, 0.12, -1.26], ["c", 0.39, -0.6, 0.93, -1.02, 1.59, -1.2], ["z"]], w: 8.573, h: 8.743 },
      "+": { d: [["M", 3.48, -9.3], ["c", 0.18, -0.09, 0.36, -0.09, 0.54, 0], ["c", 0.18, 0.09, 0.24, 0.15, 0.33, 0.3], ["l", 0.06, 0.15], ["l", 0, 1.29], ["l", 0, 1.29], ["l", 1.29, 0], ["c", 1.23, 0, 1.29, 0, 1.41, 0.06], ["c", 0.06, 0.03, 0.15, 0.09, 0.18, 0.12], ["c", 0.12, 0.09, 0.21, 0.33, 0.21, 0.48], ["c", 0, 0.15, -0.09, 0.39, -0.21, 0.48], ["c", -0.03, 0.03, -0.12, 0.09, -0.18, 0.12], ["c", -0.12, 0.06, -0.18, 0.06, -1.41, 0.06], ["l", -1.29, 0], ["l", 0, 1.29], ["c", 0, 1.23, 0, 1.29, -0.06, 1.41], ["c", -0.09, 0.18, -0.15, 0.24, -0.3, 0.33], ["c", -0.21, 0.09, -0.39, 0.09, -0.57, 0], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["c", -0.06, -0.12, -0.06, -0.18, -0.06, -1.41], ["l", 0, -1.29], ["l", -1.29, 0], ["c", -1.23, 0, -1.29, 0, -1.41, -0.06], ["c", -0.18, -0.09, -0.24, -0.15, -0.33, -0.33], ["c", -0.09, -0.18, -0.09, -0.36, 0, -0.54], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["l", 0.15, -0.06], ["l", 1.26, 0], ["l", 1.29, 0], ["l", 0, -1.29], ["c", 0, -1.23, 0, -1.29, 0.06, -1.41], ["c", 0.09, -0.18, 0.15, -0.24, 0.33, -0.33], ["z"]], w: 7.507, h: 7.515 },
      ",": { d: [["M", 1.32, -3.36], ["c", 0.57, -0.15, 1.17, 0.03, 1.59, 0.45], ["c", 0.45, 0.45, 0.6, 0.96, 0.51, 1.89], ["c", -0.09, 1.23, -0.42, 2.46, -0.99, 3.93], ["c", -0.3, 0.72, -0.72, 1.62, -0.78, 1.68], ["c", -0.18, 0.21, -0.51, 0.18, -0.66, -0.06], ["c", -0.03, -0.06, -0.06, -0.15, -0.06, -0.18], ["c", 0, -0.06, 0.12, -0.33, 0.24, -0.63], ["c", 0.84, -1.8, 1.02, -2.61, 0.69, -3.24], ["c", -0.12, -0.24, -0.27, -0.36, -0.75, -0.6], ["c", -0.36, -0.15, -0.42, -0.21, -0.6, -0.39], ["c", -0.69, -0.69, -0.69, -1.71, 0, -2.4], ["c", 0.21, -0.21, 0.51, -0.39, 0.81, -0.45], ["z"]], w: 3.452, h: 8.143 },
      "-": { d: [["M", 0.18, -5.34], ["c", 0.09, -0.06, 0.15, -0.06, 2.31, -0.06], ["c", 2.46, 0, 2.37, 0, 2.46, 0.21], ["c", 0.12, 0.21, 0.03, 0.42, -0.15, 0.54], ["c", -0.09, 0.06, -0.15, 0.06, -2.28, 0.06], ["c", -2.16, 0, -2.22, 0, -2.31, -0.06], ["c", -0.27, -0.15, -0.27, -0.54, -0.03, -0.69], ["z"]], w: 5.001, h: 0.81 },
      ".": { d: [["M", 1.32, -3.36], ["c", 1.05, -0.27, 2.1, 0.57, 2.1, 1.65], ["c", 0, 1.08, -1.05, 1.92, -2.1, 1.65], ["c", -0.9, -0.21, -1.5, -1.14, -1.26, -2.04], ["c", 0.12, -0.63, 0.63, -1.11, 1.26, -1.26], ["z"]], w: 3.413, h: 3.402 },
      "scripts.wedge": { d: [["M", -3.66, -7.44], ["c", 0.06, -0.09, 0, -0.09, 0.81, 0.03], ["c", 1.86, 0.3, 3.84, 0.3, 5.73, 0], ["c", 0.78, -0.12, 0.72, -0.12, 0.78, -0.03], ["c", 0.15, 0.15, 0.12, 0.24, -0.24, 0.6], ["c", -0.93, 0.93, -1.98, 2.76, -2.67, 4.62], ["c", -0.3, 0.78, -0.51, 1.71, -0.51, 2.13], ["c", 0, 0.15, 0, 0.18, -0.06, 0.27], ["c", -0.12, 0.09, -0.24, 0.09, -0.36, 0], ["c", -0.06, -0.09, -0.06, -0.12, -0.06, -0.27], ["c", 0, -0.42, -0.21, -1.35, -0.51, -2.13], ["c", -0.69, -1.86, -1.74, -3.69, -2.67, -4.62], ["c", -0.36, -0.36, -0.39, -0.45, -0.24, -0.6], ["z"]], w: 7.49, h: 7.752 },
      "scripts.thumb": { d: [["M", -0.54, -3.69], ["c", 0.15, -0.03, 0.36, -0.06, 0.51, -0.06], ["c", 1.44, 0, 2.58, 1.11, 2.94, 2.85], ["c", 0.09, 0.48, 0.09, 1.32, 0, 1.8], ["c", -0.27, 1.41, -1.08, 2.43, -2.16, 2.73], ["l", -0.18, 0.06], ["l", 0, 0.12], ["c", 0.03, 0.06, 0.06, 0.45, 0.09, 0.87], ["c", 0.03, 0.57, 0.03, 0.78, 0, 0.84], ["c", -0.09, 0.27, -0.39, 0.48, -0.66, 0.48], ["c", -0.27, 0, -0.57, -0.21, -0.66, -0.48], ["c", -0.03, -0.06, -0.03, -0.27, 0, -0.84], ["c", 0.03, -0.42, 0.06, -0.81, 0.09, -0.87], ["l", 0, -0.12], ["l", -0.18, -0.06], ["c", -1.08, -0.3, -1.89, -1.32, -2.16, -2.73], ["c", -0.09, -0.48, -0.09, -1.32, 0, -1.8], ["c", 0.15, -0.84, 0.51, -1.53, 1.02, -2.04], ["c", 0.39, -0.39, 0.84, -0.63, 1.35, -0.75], ["z"], ["m", 1.05, 0.9], ["c", -0.15, -0.09, -0.21, -0.09, -0.45, -0.12], ["c", -0.15, 0, -0.3, 0.03, -0.39, 0.03], ["c", -0.57, 0.18, -0.9, 0.72, -1.08, 1.74], ["c", -0.06, 0.48, -0.06, 1.8, 0, 2.28], ["c", 0.15, 0.9, 0.42, 1.44, 0.9, 1.65], ["c", 0.18, 0.09, 0.21, 0.09, 0.51, 0.09], ["c", 0.3, 0, 0.33, 0, 0.51, -0.09], ["c", 0.48, -0.21, 0.75, -0.75, 0.9, -1.65], ["c", 0.03, -0.27, 0.03, -0.54, 0.03, -1.14], ["c", 0, -0.6, 0, -0.87, -0.03, -1.14], ["c", -0.15, -0.9, -0.45, -1.44, -0.9, -1.65], ["z"]], w: 5.955, h: 9.75 },
      "scripts.open": { d: [["M", -0.54, -3.69], ["c", 0.15, -0.03, 0.36, -0.06, 0.51, -0.06], ["c", 1.44, 0, 2.58, 1.11, 2.94, 2.85], ["c", 0.09, 0.48, 0.09, 1.32, 0, 1.8], ["c", -0.33, 1.74, -1.47, 2.85, -2.91, 2.85], ["c", -1.44, 0, -2.58, -1.11, -2.91, -2.85], ["c", -0.09, -0.48, -0.09, -1.32, 0, -1.8], ["c", 0.15, -0.84, 0.51, -1.53, 1.02, -2.04], ["c", 0.39, -0.39, 0.84, -0.63, 1.35, -0.75], ["z"], ["m", 1.11, 0.9], ["c", -0.21, -0.09, -0.27, -0.09, -0.51, -0.12], ["c", -0.3, 0, -0.42, 0.03, -0.66, 0.15], ["c", -0.24, 0.12, -0.51, 0.39, -0.66, 0.63], ["c", -0.54, 0.93, -0.63, 2.64, -0.21, 3.81], ["c", 0.21, 0.54, 0.51, 0.9, 0.93, 1.11], ["c", 0.21, 0.09, 0.24, 0.09, 0.54, 0.09], ["c", 0.3, 0, 0.33, 0, 0.54, -0.09], ["c", 0.42, -0.21, 0.72, -0.57, 0.93, -1.11], ["c", 0.36, -0.99, 0.36, -2.37, 0, -3.36], ["c", -0.21, -0.54, -0.51, -0.9, -0.9, -1.11], ["z"]], w: 5.955, h: 7.5 },
      "scripts.longphrase": { d: [["M", 1.47, -15.09], ["c", 0.36, -0.09, 0.66, -0.18, 0.69, -0.18], ["c", 0.06, 0, 0.06, 0.54, 0.06, 11.25], ["l", 0, 11.25], ["l", -0.63, 0.15], ["c", -0.66, 0.18, -1.44, 0.39, -1.5, 0.39], ["c", -0.03, 0, -0.03, -3.39, -0.03, -11.25], ["l", 0, -11.25], ["l", 0.36, -0.09], ["c", 0.21, -0.06, 0.66, -0.18, 1.05, -0.27], ["z"]], w: 2.16, h: 23.04 },
      "scripts.mediumphrase": { d: [["M", 1.47, -7.59], ["c", 0.36, -0.09, 0.66, -0.18, 0.69, -0.18], ["c", 0.06, 0, 0.06, 0.39, 0.06, 7.5], ["l", 0, 7.5], ["l", -0.63, 0.15], ["c", -0.66, 0.18, -1.44, 0.39, -1.5, 0.39], ["c", -0.03, 0, -0.03, -2.28, -0.03, -7.5], ["l", 0, -7.5], ["l", 0.36, -0.09], ["c", 0.21, -0.06, 0.66, -0.18, 1.05, -0.27], ["z"]], w: 2.16, h: 15.54 },
      "scripts.shortphrase": { d: [["M", 1.47, -7.59], ["c", 0.36, -0.09, 0.66, -0.18, 0.69, -0.18], ["c", 0.06, 0, 0.06, 0.21, 0.06, 3.75], ["l", 0, 3.75], ["l", -0.42, 0.09], ["c", -0.57, 0.18, -1.65, 0.45, -1.71, 0.45], ["c", -0.03, 0, -0.03, -0.72, -0.03, -3.75], ["l", 0, -3.75], ["l", 0.36, -0.09], ["c", 0.21, -0.06, 0.66, -0.18, 1.05, -0.27], ["z"]], w: 2.16, h: 8.04 },
      "scripts.snap": { d: [["M", 4.5, -3.39], ["c", 0.36, -0.03, 0.96, -0.03, 1.35, 0], ["c", 1.56, 0.15, 3.15, 0.9, 4.2, 2.01], ["c", 0.24, 0.27, 0.33, 0.42, 0.33, 0.6], ["c", 0, 0.27, 0.03, 0.24, -2.46, 2.22], ["c", -1.29, 1.02, -2.4, 1.86, -2.49, 1.92], ["c", -0.18, 0.09, -0.3, 0.09, -0.48, 0], ["c", -0.09, -0.06, -1.2, -0.9, -2.49, -1.92], ["c", -2.49, -1.98, -2.46, -1.95, -2.46, -2.22], ["c", 0, -0.18, 0.09, -0.33, 0.33, -0.6], ["c", 1.05, -1.08, 2.64, -1.86, 4.17, -2.01], ["z"], ["m", 1.29, 1.17], ["c", -1.47, -0.15, -2.97, 0.3, -4.14, 1.2], ["l", -0.18, 0.15], ["l", 0.06, 0.09], ["c", 0.15, 0.12, 3.63, 2.85, 3.66, 2.85], ["c", 0.03, 0, 3.51, -2.73, 3.66, -2.85], ["l", 0.06, -0.09], ["l", -0.18, -0.15], ["c", -0.84, -0.66, -1.89, -1.08, -2.94, -1.2], ["z"]], w: 10.38, h: 6.84 }
    };
    glyphs["noteheads.slash.whole"] = { d: [["M", 5, -5], ["l", 1, 1], ["l", -5, 5], ["l", -1, -1], ["z"], ["m", 4, 6], ["l", -5, -5], ["l", 2, -2], ["l", 5, 5], ["z"], ["m", 0, -2], ["l", 1, 1], ["l", -5, 5], ["l", -1, -1], ["z"], ["m", -4, 6], ["l", -5, -5], ["l", 2, -2], ["l", 5, 5], ["z"]], w: 10.81, h: 15.63 };
    glyphs["noteheads.slash.quarter"] = { d: [["M", 9, -6], ["l", 0, 4], ["l", -9, 9], ["l", 0, -4], ["z"]], w: 9, h: 9 };
    glyphs["noteheads.harmonic.quarter"] = { d: [["M", 3.63, -4.02], ["c", 0.09, -0.06, 0.18, -0.09, 0.24, -0.03], ["c", 0.03, 0.03, 0.87, 0.93, 1.83, 2.01], ["c", 1.5, 1.65, 1.8, 1.98, 1.8, 2.04], ["c", 0, 0.06, -0.3, 0.39, -1.8, 2.04], ["c", -0.96, 1.08, -1.8, 1.98, -1.83, 2.01], ["c", -0.06, 0.06, -0.15, 0.03, -0.24, -0.03], ["c", -0.12, -0.09, -3.54, -3.84, -3.6, -3.93], ["c", -0.03, -0.03, -0.03, -0.09, -0.03, -0.15], ["c", 0.03, -0.06, 3.45, -3.84, 3.63, -3.96], ["z"]], w: 7.5, h: 8.165 };
    var pathClone = function(pathArray) {
      var res = [];
      for (var i = 0, ii = pathArray.length; i < ii; i++) {
        res[i] = [];
        for (var j = 0, jj = pathArray[i].length; j < jj; j++) {
          res[i][j] = pathArray[i][j];
        }
      }
      return res;
    };
    var pathScale = function(pathArray, kx, ky) {
      for (var i = 0, ii = pathArray.length; i < ii; i++) {
        var p = pathArray[i];
        var j, jj;
        for (j = 1, jj = p.length; j < jj; j++) {
          p[j] *= j % 2 ? kx : ky;
        }
      }
    };
    var Glyphs = {
      printSymbol: function(x, y, symb, paper, klass) {
        if (!glyphs[symb]) return null;
        var pathArray = pathClone(glyphs[symb].d);
        pathArray[0][1] += x;
        pathArray[0][2] += y;
        var path = "";
        for (var i = 0; i < pathArray.length; i++)
          path += pathArray[i].join(" ");
        return paper.path({ path, stroke: "none", fill: "#000000", "class": klass });
      },
      getPathForSymbol: function(x, y, symb, scalex, scaley) {
        scalex = scalex || 1;
        scaley = scaley || 1;
        if (!glyphs[symb]) return null;
        var pathArray = pathClone(glyphs[symb].d);
        if (scalex !== 1 || scaley !== 1) pathScale(pathArray, scalex, scaley);
        pathArray[0][1] += x;
        pathArray[0][2] += y;
        return pathArray;
      },
      getSymbolWidth: function(symbol) {
        if (glyphs[symbol]) return glyphs[symbol].w;
        return 0;
      },
      symbolHeightInPitches: function(symbol) {
        var height = glyphs[symbol] ? glyphs[symbol].h : 0;
        return height / spacing.STEP;
      },
      getSymbolAlign: function(symbol) {
        if (symbol.substring(0, 7) === "scripts" && symbol !== "scripts.roll") {
          return "center";
        }
        return "left";
      },
      getYCorr: function(symbol) {
        switch (symbol) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
          case "+":
            return -2;
          case "timesig.common":
          case "timesig.cut":
            return 0;
          case "flags.d32nd":
            return -1;
          case "flags.d64th":
            return -2;
          case "flags.u32nd":
            return 1;
          case "flags.u64th":
            return 3;
          case "rests.whole":
            return 1;
          case "rests.half":
            return -1;
          case "rests.8th":
            return -1;
          case "rests.quarter":
            return -1;
          case "rests.16th":
            return -1;
          case "rests.32nd":
            return -1;
          case "rests.64th":
            return -1;
          case "f":
          case "m":
          case "p":
          case "s":
          case "z":
            return -4;
          case "scripts.trill":
          case "scripts.upbow":
          case "scripts.downbow":
            return -2;
          case "scripts.ufermata":
          case "scripts.wedge":
          case "scripts.roll":
          case "scripts.shortphrase":
          case "scripts.longphrase":
            return -1;
          case "scripts.dfermata":
            return 1;
          default:
            return 0;
        }
      },
      setSymbol: function(name, path) {
        glyphs[name] = path;
      }
    };
    module.exports = Glyphs;
  }
});

// node_modules/abcjs/src/write/abc_create_clef.js
var require_abc_create_clef = __commonJS({
  "node_modules/abcjs/src/write/abc_create_clef.js"(exports, module) {
    var AbsoluteElement = require_abc_absolute_element();
    var glyphs = require_abc_glyphs();
    var RelativeElement = require_abc_relative_element();
    var createClef;
    (function() {
      "use strict";
      createClef = function(elem, tuneNumber) {
        var clef;
        var octave = 0;
        var abselem = new AbsoluteElement(elem, 0, 10, "staff-extra", tuneNumber);
        abselem.isClef = true;
        switch (elem.type) {
          case "treble":
            clef = "clefs.G";
            break;
          case "tenor":
            clef = "clefs.C";
            break;
          case "alto":
            clef = "clefs.C";
            break;
          case "bass":
            clef = "clefs.F";
            break;
          case "treble+8":
            clef = "clefs.G";
            octave = 1;
            break;
          case "tenor+8":
            clef = "clefs.C";
            octave = 1;
            break;
          case "bass+8":
            clef = "clefs.F";
            octave = 1;
            break;
          case "alto+8":
            clef = "clefs.C";
            octave = 1;
            break;
          case "treble-8":
            clef = "clefs.G";
            octave = -1;
            break;
          case "tenor-8":
            clef = "clefs.C";
            octave = -1;
            break;
          case "bass-8":
            clef = "clefs.F";
            octave = -1;
            break;
          case "alto-8":
            clef = "clefs.C";
            octave = -1;
            break;
          case "none":
            return null;
          case "perc":
            clef = "clefs.perc";
            break;
          default:
            abselem.addChild(new RelativeElement("clef=" + elem.type, 0, 0, void 0, { type: "debug" }));
        }
        var dx = 5;
        if (clef) {
          abselem.addRight(new RelativeElement(clef, dx, glyphs.getSymbolWidth(clef), elem.clefPos));
          if (clef === "clefs.G") {
            abselem.top = 13;
            abselem.bottom = -1;
          } else {
            abselem.top = 10;
            abselem.bottom = 2;
          }
          if (octave !== 0) {
            var scale = 2 / 3;
            var adjustspacing = (glyphs.getSymbolWidth(clef) - glyphs.getSymbolWidth("8") * scale) / 2;
            abselem.addRight(new RelativeElement("8", dx + adjustspacing, glyphs.getSymbolWidth("8") * scale, octave > 0 ? abselem.top + 3 : abselem.bottom - 1, {
              scalex: scale,
              scaley: scale
            }));
            abselem.top += 2;
          }
        }
        return abselem;
      };
    })();
    module.exports = createClef;
  }
});

// node_modules/abcjs/src/write/abc_create_key_signature.js
var require_abc_create_key_signature = __commonJS({
  "node_modules/abcjs/src/write/abc_create_key_signature.js"(exports, module) {
    var AbsoluteElement = require_abc_absolute_element();
    var glyphs = require_abc_glyphs();
    var RelativeElement = require_abc_relative_element();
    var parseCommon = require_abc_common();
    var createKeySignature;
    (function() {
      "use strict";
      createKeySignature = function(elem, tuneNumber) {
        if (!elem.accidentals || elem.accidentals.length === 0)
          return null;
        var abselem = new AbsoluteElement(elem, 0, 10, "staff-extra", tuneNumber);
        abselem.isKeySig = true;
        var dx = 0;
        parseCommon.each(elem.accidentals, function(acc) {
          var symbol;
          switch (acc.acc) {
            case "sharp":
              symbol = "accidentals.sharp";
              break;
            case "natural":
              symbol = "accidentals.nat";
              break;
            case "flat":
              symbol = "accidentals.flat";
              break;
            case "quartersharp":
              symbol = "accidentals.halfsharp";
              break;
            case "quarterflat":
              symbol = "accidentals.halfflat";
              break;
            default:
              symbol = "accidentals.flat";
          }
          abselem.addRight(new RelativeElement(symbol, dx, glyphs.getSymbolWidth(symbol), acc.verticalPos, { thickness: glyphs.symbolHeightInPitches(symbol) }));
          dx += glyphs.getSymbolWidth(symbol) + 2;
        }, this);
        return abselem;
      };
    })();
    module.exports = createKeySignature;
  }
});

// node_modules/abcjs/src/write/abc_create_time_signature.js
var require_abc_create_time_signature = __commonJS({
  "node_modules/abcjs/src/write/abc_create_time_signature.js"(exports, module) {
    var AbsoluteElement = require_abc_absolute_element();
    var glyphs = require_abc_glyphs();
    var RelativeElement = require_abc_relative_element();
    var createTimeSignature;
    (function() {
      "use strict";
      createTimeSignature = function(elem, tuneNumber) {
        var abselem = new AbsoluteElement(elem, 0, 10, "staff-extra", tuneNumber);
        if (elem.type === "specified") {
          var x = 0;
          for (var i = 0; i < elem.value.length; i++) {
            if (i !== 0) {
              abselem.addRight(new RelativeElement("+", x + 1, glyphs.getSymbolWidth("+"), 6, { thickness: glyphs.symbolHeightInPitches("+") }));
              x += glyphs.getSymbolWidth("+") + 2;
            }
            if (elem.value[i].den) {
              var numWidth = 0;
              for (var i2 = 0; i2 < elem.value[i].num.length; i2++)
                numWidth += glyphs.getSymbolWidth(elem.value[i].num.charAt(i2));
              var denWidth = 0;
              for (i2 = 0; i2 < elem.value[i].num.length; i2++)
                denWidth += glyphs.getSymbolWidth(elem.value[i].den.charAt(i2));
              var maxWidth = Math.max(numWidth, denWidth);
              abselem.addRight(new RelativeElement(elem.value[i].num, x + (maxWidth - numWidth) / 2, numWidth, 8, { thickness: glyphs.symbolHeightInPitches(elem.value[i].num.charAt(0)) }));
              abselem.addRight(new RelativeElement(elem.value[i].den, x + (maxWidth - denWidth) / 2, denWidth, 4, { thickness: glyphs.symbolHeightInPitches(elem.value[i].den.charAt(0)) }));
              x += maxWidth;
            } else {
              var thisWidth = 0;
              for (var i3 = 0; i3 < elem.value[i].num.length; i3++)
                thisWidth += glyphs.getSymbolWidth(elem.value[i].num.charAt(i3));
              abselem.addRight(new RelativeElement(elem.value[i].num, x, thisWidth, 6, { thickness: glyphs.symbolHeightInPitches(elem.value[i].num.charAt(0)) }));
              x += thisWidth;
            }
          }
        } else if (elem.type === "common_time") {
          abselem.addRight(new RelativeElement("timesig.common", 0, glyphs.getSymbolWidth("timesig.common"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.common") }));
        } else if (elem.type === "cut_time") {
          abselem.addRight(new RelativeElement("timesig.cut", 0, glyphs.getSymbolWidth("timesig.cut"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.cut") }));
        } else if (elem.type === "tempus_imperfectum") {
          abselem.addRight(new RelativeElement("timesig.imperfectum", 0, glyphs.getSymbolWidth("timesig.imperfectum"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.imperfectum") }));
        } else if (elem.type === "tempus_imperfectum_prolatio") {
          abselem.addRight(new RelativeElement("timesig.imperfectum2", 0, glyphs.getSymbolWidth("timesig.imperfectum2"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.imperfectum2") }));
        } else if (elem.type === "tempus_perfectum") {
          abselem.addRight(new RelativeElement("timesig.perfectum", 0, glyphs.getSymbolWidth("timesig.perfectum"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.perfectum") }));
        } else if (elem.type === "tempus_perfectum_prolatio") {
          abselem.addRight(new RelativeElement("timesig.perfectum2", 0, glyphs.getSymbolWidth("timesig.perfectum2"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.perfectum2") }));
        } else {
          console.log("time signature:", elem);
        }
        return abselem;
      };
    })();
    module.exports = createTimeSignature;
  }
});

// node_modules/abcjs/src/write/abc_dynamic_decoration.js
var require_abc_dynamic_decoration = __commonJS({
  "node_modules/abcjs/src/write/abc_dynamic_decoration.js"(exports, module) {
    var spacing = require_abc_spacing();
    var DynamicDecoration = function DynamicDecoration2(anchor, dec, position) {
      this.anchor = anchor;
      this.dec = dec;
      if (position === "below")
        this.volumeHeightBelow = 5;
      else
        this.volumeHeightAbove = 5;
      this.pitch = void 0;
    };
    DynamicDecoration.prototype.setUpperAndLowerElements = function(positionY) {
      if (this.volumeHeightAbove)
        this.pitch = positionY.volumeHeightAbove;
      else
        this.pitch = positionY.volumeHeightBelow;
    };
    DynamicDecoration.prototype.draw = function(renderer, linestartx, lineendx) {
      if (this.pitch === void 0)
        window.console.error("Dynamic Element y-coordinate not set.");
      var scalex = 1;
      var scaley = 1;
      renderer.printSymbol(this.anchor.x, this.pitch, this.dec, scalex, scaley, renderer.addClasses("decoration"));
    };
    module.exports = DynamicDecoration;
  }
});

// node_modules/abcjs/src/write/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/abcjs/src/write/sprintf.js"(exports, module) {
    var sprintf = function() {
      var i = 0, a, f = arguments[i++], o = [], m, p, c, x;
      while (f) {
        if (m = /^[^\x25]+/.exec(f)) o.push(m[0]);
        else if (m = /^\x25{2}/.exec(f)) o.push("%");
        else if (m = /^\x25(?:(\d+)\$)?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(f)) {
          if ((a = arguments[m[1] || i++]) == null || a == void 0) throw "Too few arguments.";
          if (/[^s]/.test(m[7]) && typeof a != "number")
            throw "Expecting number but found " + typeof a;
          switch (m[7]) {
            case "b":
              a = a.toString(2);
              break;
            case "c":
              a = String.fromCharCode(a);
              break;
            case "d":
              a = parseInt(a);
              break;
            case "e":
              a = m[6] ? a.toExponential(m[6]) : a.toExponential();
              break;
            case "f":
              a = m[6] ? parseFloat(a).toFixed(m[6]) : parseFloat(a);
              break;
            case "o":
              a = a.toString(8);
              break;
            case "s":
              a = (a = String(a)) && m[6] ? a.substring(0, m[6]) : a;
              break;
            case "u":
              a = Math.abs(a);
              break;
            case "x":
              a = a.toString(16);
              break;
            case "X":
              a = a.toString(16).toUpperCase();
              break;
          }
          a = /[def]/.test(m[7]) && m[2] && a > 0 ? "+" + a : a;
          c = m[3] ? m[3] == "0" ? "0" : m[3].charAt(1) : " ";
          x = m[5] - String(a).length;
          p = m[5] ? str_repeat(c, x) : "";
          o.push(m[4] ? a + p : p + a);
        } else throw "Huh ?!";
        f = f.substring(m[0].length);
      }
      return o.join("");
    };
    module.exports = sprintf;
  }
});

// node_modules/abcjs/src/write/abc_crescendo_element.js
var require_abc_crescendo_element = __commonJS({
  "node_modules/abcjs/src/write/abc_crescendo_element.js"(exports, module) {
    var sprintf = require_sprintf();
    var CrescendoElem = function CrescendoElem2(anchor1, anchor2, dir, positioning) {
      this.anchor1 = anchor1;
      this.anchor2 = anchor2;
      this.dir = dir;
      if (positioning === "above")
        this.dynamicHeightAbove = 4;
      else
        this.dynamicHeightBelow = 4;
      this.pitch = void 0;
    };
    CrescendoElem.prototype.setUpperAndLowerElements = function(positionY) {
      if (this.dynamicHeightAbove)
        this.pitch = positionY.dynamicHeightAbove;
      else
        this.pitch = positionY.dynamicHeightBelow;
    };
    CrescendoElem.prototype.draw = function(renderer) {
      if (this.pitch === void 0)
        window.console.error("Crescendo Element y-coordinate not set.");
      var y = renderer.calcY(this.pitch) + 4;
      var height = 8;
      if (this.dir === "<") {
        this.drawLine(renderer, y + height / 2, y);
        this.drawLine(renderer, y + height / 2, y + height);
      } else {
        this.drawLine(renderer, y, y + height / 2);
        this.drawLine(renderer, y + height, y + height / 2);
      }
    };
    CrescendoElem.prototype.drawLine = function(renderer, y1, y2) {
      var left = this.anchor1 ? this.anchor1.x : 0;
      var right = this.anchor2 ? this.anchor2.x : 800;
      var pathString = sprintf(
        "M %f %f L %f %f",
        left,
        y1,
        right,
        y2
      );
      renderer.printPath({ path: pathString, stroke: "#000000", "class": renderer.addClasses("decoration") });
    };
    module.exports = CrescendoElem;
  }
});

// node_modules/abcjs/src/write/abc_tie_element.js
var require_abc_tie_element = __commonJS({
  "node_modules/abcjs/src/write/abc_tie_element.js"(exports, module) {
    var TieElem = function TieElem2(options) {
      this.anchor1 = options.anchor1;
      this.anchor2 = options.anchor2;
      if (options.isGrace)
        this.isGrace = true;
      if (options.fixedY)
        this.fixedY = true;
      if (options.stemDir)
        this.stemDir = options.stemDir;
      if (options.voiceNumber !== void 0)
        this.voiceNumber = options.voiceNumber;
      this.internalNotes = [];
    };
    TieElem.prototype.addInternalNote = function(note) {
      this.internalNotes.push(note);
    };
    TieElem.prototype.setEndAnchor = function(anchor2) {
      this.anchor2 = anchor2;
    };
    TieElem.prototype.setStartX = function(startLimitElem) {
      this.startLimitX = startLimitElem;
    };
    TieElem.prototype.setEndX = function(endLimitElem) {
      this.endLimitX = endLimitElem;
    };
    TieElem.prototype.setHint = function() {
      this.hint = true;
    };
    TieElem.prototype.setUpperAndLowerElements = function(positionY) {
    };
    TieElem.prototype.calcTieDirection = function() {
      if (this.isGrace)
        this.above = false;
      else if (this.voiceNumber === 0)
        this.above = true;
      else if (this.voiceNumber > 0)
        this.above = false;
      else {
        var referencePitch;
        if (this.anchor1)
          referencePitch = this.anchor1.pitch;
        else if (this.anchor2)
          referencePitch = this.anchor2.pitch;
        else
          referencePitch = 14;
        if (this.anchor1 && this.anchor1.stemDir === "down" && (this.anchor2 && this.anchor2.stemDir === "down"))
          this.above = true;
        else if (this.anchor1 && this.anchor1.stemDir === "up" && (this.anchor2 && this.anchor2.stemDir === "up"))
          this.above = false;
        else if (this.anchor1 && this.anchor2)
          this.above = referencePitch >= 6;
        else if (this.anchor1)
          this.above = this.anchor1.stemDir === "down";
        else if (this.anchor2)
          this.above = this.anchor2.stemDir === "down";
        else
          this.above = referencePitch >= 6;
      }
    };
    TieElem.prototype.calcSlurDirection = function() {
      if (this.isGrace)
        this.above = false;
      else if (this.voiceNumber === 0)
        this.above = true;
      else if (this.voiceNumber > 0)
        this.above = false;
      else {
        var hasDownStem = false;
        if (this.anchor1 && this.anchor1.stemDir === "down")
          hasDownStem = true;
        if (this.anchor2 && this.anchor2.stemDir === "down")
          hasDownStem = true;
        for (var i = 0; i < this.internalNotes.length; i++) {
          var n = this.internalNotes[i];
          if (n.stemDir === "down")
            hasDownStem = true;
        }
        this.above = hasDownStem;
      }
    };
    TieElem.prototype.calcX = function(lineStartX, lineEndX) {
      if (this.anchor1) {
        this.startX = this.anchor1.x;
        if (this.anchor1.scalex < 1)
          this.startX -= 3;
      } else if (this.startLimitX)
        this.startX = this.startLimitX.x + this.startLimitX.w;
      else
        this.startX = lineStartX;
      if (this.anchor2)
        this.endX = this.anchor2.x;
      else if (this.endLimitX)
        this.endX = this.endLimitX.x;
      else
        this.endX = lineEndX;
    };
    TieElem.prototype.calcTieY = function() {
      if (this.anchor1)
        this.startY = this.anchor1.pitch;
      else if (this.anchor2)
        this.startY = this.anchor2.pitch;
      else
        this.startY = this.above ? 14 : 0;
      if (this.anchor2)
        this.endY = this.anchor2.pitch;
      else if (this.anchor1)
        this.endY = this.anchor1.pitch;
      else
        this.endY = this.above ? 14 : 0;
    };
    TieElem.prototype.calcSlurY = function() {
      if (this.anchor1 && this.anchor2) {
        if (this.above && this.anchor1.stemDir === "up" && !this.fixedY) {
          this.startY = (this.anchor1.highestVert + this.anchor1.pitch) / 2;
          this.startX += this.anchor1.w / 2;
        } else
          this.startY = this.anchor1.pitch;
        var beamInterferes = this.anchor2.parent.beam && this.anchor2.parent.beam.stemsUp && this.anchor2.parent.beam.elems[0] !== this.anchor2.parent;
        var midPoint = (this.anchor2.highestVert + this.anchor2.pitch) / 2;
        if (this.above && this.anchor2.stemDir === "up" && !this.fixedY && !beamInterferes && midPoint < this.startY) {
          this.endY = midPoint;
          this.endX += this.anchor2.w / 2;
        } else
          this.endY = this.above && beamInterferes ? this.anchor2.highestVert : this.anchor2.pitch;
      } else if (this.anchor1) {
        this.startY = this.endY = this.anchor1.pitch;
      } else if (this.anchor2) {
        this.startY = this.endY = this.anchor2.pitch;
      } else {
        this.startY = this.above ? 14 : 0;
        this.endY = this.above ? 14 : 0;
      }
    };
    TieElem.prototype.avoidCollisionAbove = function() {
      if (this.above) {
        var maxInnerHeight = -50;
        for (var i = 0; i < this.internalNotes.length; i++) {
          if (this.internalNotes[i].highestVert > maxInnerHeight)
            maxInnerHeight = this.internalNotes[i].highestVert;
        }
        if (maxInnerHeight > this.startY && maxInnerHeight > this.endY)
          this.startY = this.endY = maxInnerHeight - 1;
      }
    };
    TieElem.prototype.layout = function(lineStartX, lineEndX) {
      if (!this.anchor1 || !this.anchor2)
        this.isTie = true;
      else if (this.anchor1.pitch === this.anchor2.pitch && this.internalNotes.length === 0)
        this.isTie = true;
      else
        this.isTie = false;
      if (this.isTie) {
        this.calcTieDirection();
        this.calcX(lineStartX, lineEndX);
        this.calcTieY();
      } else {
        this.calcSlurDirection();
        this.calcX(lineStartX, lineEndX);
        this.calcSlurY();
      }
      this.avoidCollisionAbove();
    };
    TieElem.prototype.draw = function(renderer, linestartx, lineendx) {
      this.layout(linestartx, lineendx);
      var klass;
      if (this.hint)
        klass = "abcjs-hint";
      var fudgeY = this.fixedY ? 1.5 : 0;
      renderer.drawArc(this.startX, this.endX, this.startY + fudgeY, this.endY + fudgeY, this.above, klass, this.isTie);
    };
    module.exports = TieElem;
  }
});

// node_modules/abcjs/src/write/abc_decoration.js
var require_abc_decoration = __commonJS({
  "node_modules/abcjs/src/write/abc_decoration.js"(exports, module) {
    var DynamicDecoration = require_abc_dynamic_decoration();
    var CrescendoElem = require_abc_crescendo_element();
    var glyphs = require_abc_glyphs();
    var RelativeElement = require_abc_relative_element();
    var TieElem = require_abc_tie_element();
    var Decoration;
    (function() {
      "use strict";
      Decoration = function Decoration2() {
        this.startDiminuendoX = void 0;
        this.startCrescendoX = void 0;
        this.minTop = 12;
        this.minBottom = 0;
      };
      var closeDecoration = function(voice, decoration, pitch, width, abselem, roomtaken, dir, minPitch) {
        var yPos;
        for (var i = 0; i < decoration.length; i++) {
          if (decoration[i] === "staccato" || decoration[i] === "tenuto" || decoration[i] === "accent") {
            var symbol = "scripts." + decoration[i];
            if (decoration[i] === "accent") symbol = "scripts.sforzato";
            if (yPos === void 0)
              yPos = dir === "down" ? pitch + 2 : minPitch - 2;
            else
              yPos = dir === "down" ? yPos + 2 : yPos - 2;
            if (decoration[i] === "accent") {
              if (dir === "up") yPos--;
              else yPos++;
            } else {
              switch (yPos) {
                case 2:
                case 4:
                case 6:
                case 8:
                case 10:
                  if (dir === "up") yPos--;
                  else yPos++;
                  break;
              }
            }
            if (pitch > 9) yPos++;
            var deltaX = width / 2;
            if (glyphs.getSymbolAlign(symbol) !== "center") {
              deltaX -= glyphs.getSymbolWidth(symbol) / 2;
            }
            abselem.addChild(new RelativeElement(symbol, deltaX, glyphs.getSymbolWidth(symbol), yPos));
          }
          if (decoration[i] === "slide" && abselem.heads[0]) {
            var yPos2 = abselem.heads[0].pitch;
            yPos2 -= 2;
            var blank1 = new RelativeElement("", -roomtaken - 15, 0, yPos2 - 1);
            var blank2 = new RelativeElement("", -roomtaken - 5, 0, yPos2 + 1);
            abselem.addChild(blank1);
            abselem.addChild(blank2);
            voice.addOther(new TieElem({ anchor1: blank1, anchor2: blank2, fixedY: true }));
          }
        }
        if (yPos === void 0)
          yPos = pitch;
        return { above: yPos, below: abselem.bottom };
      };
      var volumeDecoration = function(voice, decoration, abselem, positioning) {
        for (var i = 0; i < decoration.length; i++) {
          switch (decoration[i]) {
            case "p":
            case "mp":
            case "pp":
            case "ppp":
            case "pppp":
            case "f":
            case "ff":
            case "fff":
            case "ffff":
            case "sfz":
            case "mf":
              var elem = new DynamicDecoration(abselem, decoration[i], positioning);
              voice.addOther(elem);
          }
        }
      };
      var compoundDecoration = function(decoration, pitch, width, abselem, dir) {
        function highestPitch() {
          if (abselem.heads.length === 0)
            return 10;
          var pitch2 = abselem.heads[0].pitch;
          for (var i2 = 1; i2 < abselem.heads.length; i2++)
            pitch2 = Math.max(pitch2, abselem.heads[i2].pitch);
          return pitch2;
        }
        function lowestPitch() {
          if (abselem.heads.length === 0)
            return 2;
          var pitch2 = abselem.heads[0].pitch;
          for (var i2 = 1; i2 < abselem.heads.length; i2++)
            pitch2 = Math.min(pitch2, abselem.heads[i2].pitch);
          return pitch2;
        }
        function compoundDecoration2(symbol, count) {
          var placement = dir === "down" ? lowestPitch() + 1 : highestPitch() + 9;
          if (dir !== "down" && count === 1)
            placement--;
          var deltaX = width / 2;
          deltaX += dir === "down" ? -5 : 3;
          for (var i2 = 0; i2 < count; i2++) {
            placement -= 1;
            abselem.addChild(new RelativeElement(symbol, deltaX, glyphs.getSymbolWidth(symbol), placement));
          }
        }
        for (var i = 0; i < decoration.length; i++) {
          switch (decoration[i]) {
            case "/":
              compoundDecoration2("flags.ugrace", 1);
              break;
            case "//":
              compoundDecoration2("flags.ugrace", 2);
              break;
            case "///":
              compoundDecoration2("flags.ugrace", 3);
              break;
            case "////":
              compoundDecoration2("flags.ugrace", 4);
              break;
          }
        }
      };
      var stackedDecoration = function(decoration, width, abselem, yPos, positioning, minTop, minBottom) {
        function incrementPlacement(placement, height) {
          if (placement === "above")
            yPos.above += height;
          else
            yPos.below -= height;
        }
        function getPlacement(placement) {
          var y;
          if (placement === "above") {
            y = yPos.above;
            if (y < minTop)
              y = minTop;
          } else {
            y = yPos.below;
            if (y > minBottom)
              y = minBottom;
          }
          return y;
        }
        function textDecoration(text, placement) {
          var y = getPlacement(placement);
          var textFudge = 2;
          var textHeight = 5;
          abselem.addChild(new RelativeElement(text, width / 2, 0, y + textFudge, { type: "decoration", klass: "ornament", thickness: 3 }));
          incrementPlacement(placement, textHeight);
        }
        function symbolDecoration(symbol, placement) {
          var deltaX = width / 2;
          if (glyphs.getSymbolAlign(symbol) !== "center") {
            deltaX -= glyphs.getSymbolWidth(symbol) / 2;
          }
          var height = glyphs.symbolHeightInPitches(symbol) + 1;
          var y = getPlacement(placement);
          y = placement === "above" ? y + height / 2 : y - height / 2;
          abselem.addChild(new RelativeElement(symbol, deltaX, glyphs.getSymbolWidth(symbol), y, { klass: "ornament", thickness: glyphs.symbolHeightInPitches(symbol) }));
          incrementPlacement(placement, height);
        }
        var symbolList = {
          "+": "scripts.stopped",
          "open": "scripts.open",
          "snap": "scripts.snap",
          "wedge": "scripts.wedge",
          "thumb": "scripts.thumb",
          "shortphrase": "scripts.shortphrase",
          "mediumphrase": "scripts.mediumphrase",
          "longphrase": "scripts.longphrase",
          "trill": "scripts.trill",
          "roll": "scripts.roll",
          "irishroll": "scripts.roll",
          "marcato": "scripts.umarcato",
          "dmarcato": "scripts.dmarcato",
          "umarcato": "scripts.umarcato",
          "turn": "scripts.turn",
          "uppermordent": "scripts.prall",
          "pralltriller": "scripts.prall",
          "mordent": "scripts.mordent",
          "lowermordent": "scripts.mordent",
          "downbow": "scripts.downbow",
          "upbow": "scripts.upbow",
          "fermata": "scripts.ufermata",
          "invertedfermata": "scripts.dfermata",
          "breath": ",",
          "coda": "scripts.coda",
          "segno": "scripts.segno"
        };
        var hasOne = false;
        for (var i = 0; i < decoration.length; i++) {
          switch (decoration[i]) {
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "D.C.":
            case "D.S.":
              textDecoration(decoration[i], positioning);
              hasOne = true;
              break;
            case "fine":
              textDecoration("FINE", positioning);
              hasOne = true;
              break;
            case "+":
            case "open":
            case "snap":
            case "wedge":
            case "thumb":
            case "shortphrase":
            case "mediumphrase":
            case "longphrase":
            case "trill":
            case "roll":
            case "irishroll":
            case "marcato":
            case "dmarcato":
            case "turn":
            case "uppermordent":
            case "pralltriller":
            case "mordent":
            case "lowermordent":
            case "downbow":
            case "upbow":
            case "fermata":
            case "breath":
            case "umarcato":
            case "coda":
            case "segno":
              symbolDecoration(symbolList[decoration[i]], positioning);
              hasOne = true;
              break;
            case "invertedfermata":
              symbolDecoration(symbolList[decoration[i]], "below");
              hasOne = true;
              break;
            case "mark":
              abselem.klass = "mark";
              break;
          }
        }
        return hasOne;
      };
      function leftDecoration(decoration, abselem, roomtaken) {
        for (var i = 0; i < decoration.length; i++) {
          switch (decoration[i]) {
            case "arpeggio":
              for (var j = abselem.abcelem.minpitch - 1; j <= abselem.abcelem.maxpitch; j += 2) {
                abselem.addExtra(
                  new RelativeElement(
                    "scripts.arpeggio",
                    -glyphs.getSymbolWidth("scripts.arpeggio") * 2 - roomtaken,
                    0,
                    j + 2,
                    { klass: "ornament", thickness: glyphs.symbolHeightInPitches("scripts.arpeggio") }
                  )
                );
              }
              break;
          }
        }
      }
      Decoration.prototype.dynamicDecoration = function(voice, decoration, abselem, positioning) {
        var diminuendo;
        var crescendo;
        for (var i = 0; i < decoration.length; i++) {
          switch (decoration[i]) {
            case "diminuendo(":
              this.startDiminuendoX = abselem;
              diminuendo = void 0;
              break;
            case "diminuendo)":
              diminuendo = { start: this.startDiminuendoX, stop: abselem };
              this.startDiminuendoX = void 0;
              break;
            case "crescendo(":
              this.startCrescendoX = abselem;
              crescendo = void 0;
              break;
            case "crescendo)":
              crescendo = { start: this.startCrescendoX, stop: abselem };
              this.startCrescendoX = void 0;
              break;
          }
        }
        if (diminuendo) {
          voice.addOther(new CrescendoElem(diminuendo.start, diminuendo.stop, ">", positioning));
        }
        if (crescendo) {
          voice.addOther(new CrescendoElem(crescendo.start, crescendo.stop, "<", positioning));
        }
      };
      Decoration.prototype.createDecoration = function(voice, decoration, pitch, width, abselem, roomtaken, dir, minPitch, positioning, hasVocals) {
        if (!positioning)
          positioning = { ornamentPosition: "above", volumePosition: hasVocals ? "above" : "below", dynamicPosition: hasVocals ? "above" : "below" };
        volumeDecoration(voice, decoration, abselem, positioning.volumePosition);
        this.dynamicDecoration(voice, decoration, abselem, positioning.dynamicPosition);
        compoundDecoration(decoration, pitch, width, abselem, dir);
        var yPos = closeDecoration(voice, decoration, pitch, width, abselem, roomtaken, dir, minPitch);
        yPos.above = Math.max(yPos.above, this.minTop);
        var hasOne = stackedDecoration(decoration, width, abselem, yPos, positioning.ornamentPosition, this.minTop, this.minBottom);
        if (hasOne) {
        }
        leftDecoration(decoration, abselem, roomtaken);
      };
    })();
    module.exports = Decoration;
  }
});

// node_modules/abcjs/src/write/abc_ending_element.js
var require_abc_ending_element = __commonJS({
  "node_modules/abcjs/src/write/abc_ending_element.js"(exports, module) {
    var sprintf = require_sprintf();
    var EndingElem = function EndingElem2(text, anchor1, anchor2) {
      this.text = text;
      this.anchor1 = anchor1;
      this.anchor2 = anchor2;
      this.endingHeightAbove = 5;
      this.pitch = void 0;
    };
    EndingElem.prototype.setUpperAndLowerElements = function(positionY) {
      this.pitch = positionY.endingHeightAbove - 2;
    };
    EndingElem.prototype.draw = function(renderer, linestartx, lineendx) {
      if (this.pitch === void 0)
        window.console.error("Ending Element y-coordinate not set.");
      var y = renderer.calcY(this.pitch);
      var height = 20;
      var pathString;
      if (this.anchor1) {
        linestartx = this.anchor1.x + this.anchor1.w;
        pathString = sprintf(
          "M %f %f L %f %f",
          linestartx,
          y,
          linestartx,
          y + height
        );
        renderer.printPath({ path: pathString, stroke: "#000000", fill: "#000000", "class": renderer.addClasses("ending") });
        renderer.renderText(linestartx + 5, renderer.calcY(this.pitch - 0.5), this.text, "repeatfont", "ending", "start");
      }
      if (this.anchor2) {
        lineendx = this.anchor2.x;
        pathString = sprintf(
          "M %f %f L %f %f",
          lineendx,
          y,
          lineendx,
          y + height
        );
        renderer.printPath({ path: pathString, stroke: "#000000", fill: "#000000", "class": renderer.addClasses("ending") });
      }
      pathString = sprintf(
        "M %f %f L %f %f",
        linestartx,
        y,
        lineendx,
        y
      );
      renderer.printPath({ path: pathString, stroke: "#000000", fill: "#000000", "class": renderer.addClasses("ending") });
    };
    module.exports = EndingElem;
  }
});

// node_modules/abcjs/src/write/abc_staff_group_element.js
var require_abc_staff_group_element = __commonJS({
  "node_modules/abcjs/src/write/abc_staff_group_element.js"(exports, module) {
    var spacing = require_abc_spacing();
    var StaffGroupElement = function() {
      this.voices = [];
      this.staffs = [];
      this.brace = void 0;
    };
    StaffGroupElement.prototype.setLimit = function(member, voice) {
      if (!voice.specialY[member]) return;
      if (!voice.staff.specialY[member])
        voice.staff.specialY[member] = voice.specialY[member];
      else
        voice.staff.specialY[member] = Math.max(voice.staff.specialY[member], voice.specialY[member]);
    };
    StaffGroupElement.prototype.addVoice = function(voice, staffnumber, stafflines) {
      var voiceNum = this.voices.length;
      this.voices[voiceNum] = voice;
      if (this.staffs[staffnumber])
        this.staffs[staffnumber].voices.push(voiceNum);
      else {
        this.staffs[this.staffs.length] = {
          top: 10,
          bottom: 2,
          lines: stafflines,
          voices: [voiceNum],
          specialY: {
            tempoHeightAbove: 0,
            partHeightAbove: 0,
            volumeHeightAbove: 0,
            dynamicHeightAbove: 0,
            endingHeightAbove: 0,
            chordHeightAbove: 0,
            lyricHeightAbove: 0,
            lyricHeightBelow: 0,
            chordHeightBelow: 0,
            volumeHeightBelow: 0,
            dynamicHeightBelow: 0
          }
        };
      }
      voice.staff = this.staffs[staffnumber];
    };
    StaffGroupElement.prototype.setStaffLimits = function(voice) {
      voice.staff.top = Math.max(voice.staff.top, voice.top);
      voice.staff.bottom = Math.min(voice.staff.bottom, voice.bottom);
      this.setLimit("tempoHeightAbove", voice);
      this.setLimit("partHeightAbove", voice);
      this.setLimit("volumeHeightAbove", voice);
      this.setLimit("dynamicHeightAbove", voice);
      this.setLimit("endingHeightAbove", voice);
      this.setLimit("chordHeightAbove", voice);
      this.setLimit("lyricHeightAbove", voice);
      this.setLimit("lyricHeightBelow", voice);
      this.setLimit("chordHeightBelow", voice);
      this.setLimit("volumeHeightBelow", voice);
      this.setLimit("dynamicHeightBelow", voice);
    };
    StaffGroupElement.prototype.setUpperAndLowerElements = function(renderer) {
      var lastStaffBottom;
      for (var i = 0; i < this.staffs.length; i++) {
        var staff = this.staffs[i];
        var positionY = {
          tempoHeightAbove: 0,
          partHeightAbove: 0,
          volumeHeightAbove: 0,
          dynamicHeightAbove: 0,
          endingHeightAbove: 0,
          chordHeightAbove: 0,
          lyricHeightAbove: 0,
          lyricHeightBelow: 0,
          chordHeightBelow: 0,
          volumeHeightBelow: 0,
          dynamicHeightBelow: 0
        };
        if (
          /*ABCJS.write.debugPlacement*/
          false
        ) {
          staff.originalTop = staff.top;
          staff.originalBottom = staff.bottom;
        }
        if (staff.specialY.lyricHeightAbove) {
          staff.top += staff.specialY.lyricHeightAbove;
          positionY.lyricHeightAbove = staff.top;
        }
        if (staff.specialY.chordHeightAbove) {
          staff.top += staff.specialY.chordHeightAbove;
          positionY.chordHeightAbove = staff.top;
        }
        if (staff.specialY.endingHeightAbove) {
          if (staff.specialY.chordHeightAbove)
            staff.top += 2;
          else
            staff.top += staff.specialY.endingHeightAbove;
          positionY.endingHeightAbove = staff.top;
        }
        if (staff.specialY.dynamicHeightAbove && staff.specialY.volumeHeightAbove) {
          staff.top += Math.max(staff.specialY.dynamicHeightAbove, staff.specialY.volumeHeightAbove);
          positionY.dynamicHeightAbove = staff.top;
          positionY.volumeHeightAbove = staff.top;
        } else if (staff.specialY.dynamicHeightAbove) {
          staff.top += staff.specialY.dynamicHeightAbove;
          positionY.dynamicHeightAbove = staff.top;
        } else if (staff.specialY.volumeHeightAbove) {
          staff.top += staff.specialY.volumeHeightAbove;
          positionY.volumeHeightAbove = staff.top;
        }
        if (staff.specialY.partHeightAbove) {
          staff.top += staff.specialY.partHeightAbove;
          positionY.partHeightAbove = staff.top;
        }
        if (staff.specialY.tempoHeightAbove) {
          staff.top += staff.specialY.tempoHeightAbove;
          positionY.tempoHeightAbove = staff.top;
        }
        if (staff.specialY.lyricHeightBelow) {
          positionY.lyricHeightBelow = staff.bottom;
          staff.bottom -= staff.specialY.lyricHeightBelow;
        }
        if (staff.specialY.chordHeightBelow) {
          positionY.chordHeightBelow = staff.bottom;
          staff.bottom -= staff.specialY.chordHeightBelow;
        }
        if (staff.specialY.volumeHeightBelow && staff.specialY.dynamicHeightBelow) {
          positionY.volumeHeightBelow = staff.bottom;
          positionY.dynamicHeightBelow = staff.bottom;
          staff.bottom -= Math.max(staff.specialY.volumeHeightBelow, staff.specialY.dynamicHeightBelow);
        } else if (staff.specialY.volumeHeightBelow) {
          positionY.volumeHeightBelow = staff.bottom;
          staff.bottom -= staff.specialY.volumeHeightBelow;
        } else if (staff.specialY.dynamicHeightBelow) {
          positionY.dynamicHeightBelow = staff.bottom;
          staff.bottom -= staff.specialY.dynamicHeightBelow;
        }
        if (
          /*ABCJS.write.debugPlacement*/
          false
        )
          staff.positionY = positionY;
        for (var j = 0; j < staff.voices.length; j++) {
          var voice = this.voices[staff.voices[j]];
          voice.setUpperAndLowerElements(positionY);
        }
        if (lastStaffBottom !== void 0) {
          var thisStaffTop = staff.top - 10;
          var forcedSpacingBetween = lastStaffBottom + thisStaffTop;
          var minSpacingInPitches = renderer.spacing.systemStaffSeparation / spacing.STEP;
          var addedSpace = minSpacingInPitches - forcedSpacingBetween;
          if (addedSpace > 0)
            staff.top += addedSpace;
        }
        lastStaffBottom = 2 - staff.bottom;
      }
    };
    StaffGroupElement.prototype.finished = function() {
      for (var i = 0; i < this.voices.length; i++) {
        if (!this.voices[i].layoutEnded()) return false;
      }
      return true;
    };
    function getLeftEdgeOfStaff(renderer, voices, brace) {
      var x = renderer.padding.left;
      var voiceheaderw = 0;
      for (var i = 0; i < voices.length; i++) {
        if (voices[i].header) {
          var size = renderer.getTextSize(voices[i].header, "voicefont", "");
          voiceheaderw = Math.max(voiceheaderw, size.width);
        }
      }
      if (voiceheaderw) {
        var sizeW = renderer.getTextSize("A", "voicefont", "");
        voiceheaderw += sizeW.width;
      }
      x += voiceheaderw;
      if (brace) {
        brace.setLocation(x);
        x += brace.getWidth();
      }
      return x;
    }
    StaffGroupElement.prototype.layout = function(spacing2, renderer, debug) {
      var epsilon = 1e-7;
      var spacingunits = 0;
      var minspace = 1e3;
      var x = getLeftEdgeOfStaff(renderer, this.voices, this.brace);
      this.startx = x;
      var i;
      var currentduration = 0;
      if (debug) console.log("init layout", spacing2);
      for (i = 0; i < this.voices.length; i++) {
        this.voices[i].beginLayout(x);
      }
      var spacingunit = 0;
      while (!this.finished()) {
        currentduration = null;
        for (i = 0; i < this.voices.length; i++) {
          if (!this.voices[i].layoutEnded() && (!currentduration || this.voices[i].getDurationIndex() < currentduration))
            currentduration = this.voices[i].getDurationIndex();
        }
        var currentvoices = [];
        var othervoices = [];
        for (i = 0; i < this.voices.length; i++) {
          var durationIndex = this.voices[i].getDurationIndex();
          if (durationIndex - currentduration > epsilon) {
            othervoices.push(this.voices[i]);
          } else {
            currentvoices.push(this.voices[i]);
          }
        }
        spacingunit = 0;
        var spacingduration = 0;
        for (i = 0; i < currentvoices.length; i++) {
          if (currentvoices[i].getNextX() > x) {
            x = currentvoices[i].getNextX();
            spacingunit = currentvoices[i].getSpacingUnits();
            spacingduration = currentvoices[i].spacingduration;
          }
        }
        spacingunits += spacingunit;
        minspace = Math.min(minspace, spacingunit);
        if (debug) console.log("currentduration: ", currentduration, spacingunits, minspace);
        for (i = 0; i < currentvoices.length; i++) {
          var voicechildx = currentvoices[i].layoutOneItem(x, spacing2);
          var dx = voicechildx - x;
          if (dx > 0) {
            x = voicechildx;
            for (var j = 0; j < i; j++) {
              currentvoices[j].shiftRight(dx);
            }
          }
        }
        for (i = 0; i < othervoices.length; i++) {
          othervoices[i].spacingduration -= spacingduration;
          othervoices[i].updateNextX(x, spacing2);
        }
        for (i = 0; i < currentvoices.length; i++) {
          var voice = currentvoices[i];
          voice.updateIndices();
        }
      }
      for (i = 0; i < this.voices.length; i++) {
        if (this.voices[i].getNextX() > x) {
          x = this.voices[i].getNextX();
          spacingunit = this.voices[i].getSpacingUnits();
        }
      }
      spacingunits += spacingunit;
      this.w = x;
      for (i = 0; i < this.voices.length; i++) {
        this.voices[i].w = this.w;
      }
      return { spacingUnits: spacingunits, minSpace: minspace };
    };
    StaffGroupElement.prototype.calcHeight = function() {
      var height = 0;
      for (var i = 0; i < this.voices.length; i++) {
        var staff = this.voices[i].staff;
        if (!this.voices[i].duplicate) {
          height += staff.top;
          if (staff.bottom < 0)
            height += -staff.bottom;
        }
      }
      return height;
    };
    StaffGroupElement.prototype.draw = function(renderer) {
      var debugPrint;
      var colorIndex;
      if (
        /*ABCJS.write.debugPlacement*/
        false
      ) {
        var colors = [
          "rgb(207,27,36)",
          "rgb(168,214,80)",
          "rgb(110,161,224)",
          "rgb(191,119,218)",
          "rgb(195,30,151)",
          "rgb(31,170,177)",
          "rgb(220,166,142)"
        ];
        debugPrint = function(staff2, key) {
          if (staff2.positionY[key]) {
            var height = staff2.specialY[key] * spacing.STEP;
            renderer.printShadedBox(renderer.padding.left, renderer.calcY(staff2.positionY[key]), renderer.controller.width, height, colors[colorIndex], 0.4, key.substr(0, 4));
            colorIndex += 1;
            if (colorIndex > 6) colorIndex = 0;
          }
        };
      }
      renderer.addInvisibleMarker("abcjs-top-of-system");
      var startY = renderer.y;
      for (var j = 0; j < this.staffs.length; j++) {
        var staff1 = this.staffs[j];
        renderer.moveY(spacing.STEP, staff1.top);
        staff1.absoluteY = renderer.y;
        if (
          /*ABCJS.write.debugPlacement*/
          false
        ) {
          colorIndex = 0;
          renderer.printShadedBox(renderer.padding.left, renderer.calcY(staff1.originalTop), renderer.controller.width, renderer.calcY(staff1.originalBottom) - renderer.calcY(staff1.originalTop), "#000000", 0.1);
          debugPrint(staff1, "chordHeightAbove");
          debugPrint(staff1, "chordHeightBelow");
          debugPrint(staff1, "dynamicHeightAbove");
          debugPrint(staff1, "dynamicHeightBelow");
          debugPrint(staff1, "endingHeightAbove");
          debugPrint(staff1, "lyricHeightAbove");
          debugPrint(staff1, "lyricHeightBelow");
          debugPrint(staff1, "partHeightAbove");
          debugPrint(staff1, "tempoHeightAbove");
          debugPrint(staff1, "volumeHeightAbove");
          debugPrint(staff1, "volumeHeightBelow");
        }
        if (staff1.bottom < 0)
          renderer.moveY(spacing.STEP, -staff1.bottom);
      }
      var topLine;
      var bottomLine;
      var bartop = 0;
      renderer.measureNumber = null;
      renderer.noteNumber = null;
      for (var i = 0; i < this.voices.length; i++) {
        var staff = this.voices[i].staff;
        renderer.y = staff.absoluteY;
        renderer.voiceNumber = i;
        if (!this.voices[i].duplicate) {
          if (!topLine) topLine = renderer.calcY(10);
          bottomLine = renderer.calcY(2);
          if (staff.lines !== 0) {
            renderer.measureNumber = null;
            renderer.noteNumber = null;
            renderer.printStave(this.startx, this.w, staff.lines);
          }
        }
        this.voices[i].draw(renderer, bartop);
        renderer.measureNumber = null;
        renderer.noteNumber = null;
        if (!this.voices[i].duplicate) {
          bartop = renderer.calcY(2);
        }
        if (this.brace) {
          if (i === this.brace.length - 1) {
            if (this.brace) {
              this.brace.draw(renderer, topLine, bottomLine);
            }
          }
        }
      }
      renderer.measureNumber = null;
      renderer.noteNumber = null;
      if (this.staffs.length > 1) {
        renderer.printStem(this.startx, 0.6, topLine, bottomLine);
      }
      renderer.y = startY;
    };
    module.exports = StaffGroupElement;
  }
});

// node_modules/abcjs/src/write/abc_tempo_element.js
var require_abc_tempo_element = __commonJS({
  "node_modules/abcjs/src/write/abc_tempo_element.js"(exports, module) {
    var AbsoluteElement = require_abc_absolute_element();
    var RelativeElement = require_abc_relative_element();
    var TempoElement;
    (function() {
      "use strict";
      var totalHeightInPitches = 5;
      TempoElement = function TempoElement2(tempo, tuneNumber, createNoteHead) {
        this.tempo = tempo;
        this.tuneNumber = tuneNumber;
        this.tempoHeightAbove = totalHeightInPitches;
        this.pitch = void 0;
        if (this.tempo.duration && !this.tempo.suppressBpm) {
          this.note = this.createNote(createNoteHead, tempo, tuneNumber);
        }
      };
      TempoElement.prototype.setUpperAndLowerElements = function(positionY) {
        this.pitch = positionY.tempoHeightAbove;
        this.top = positionY.tempoHeightAbove;
        this.bottom = positionY.tempoHeightAbove;
        if (this.note) {
          var tempoPitch = this.pitch - totalHeightInPitches + 1;
          this.note.top = tempoPitch;
          this.note.bottom = tempoPitch;
          for (var i = 0; i < this.note.children.length; i++) {
            var child = this.note.children[i];
            child.top += tempoPitch;
            child.bottom += tempoPitch;
            child.pitch += tempoPitch;
            if (child.pitch2 !== void 0)
              child.pitch2 += tempoPitch;
          }
        }
      };
      TempoElement.prototype.setX = function(x) {
        this.x = x;
      };
      TempoElement.prototype.createNote = function(createNoteHead, tempo, tuneNumber) {
        var temposcale = 0.75;
        var duration = tempo.duration[0];
        var absElem = new AbsoluteElement(tempo, duration, 1, "tempo", tuneNumber);
        var dot;
        var flag;
        var note;
        if (duration <= 1 / 32) {
          note = "noteheads.quarter";
          flag = "flags.u32nd";
          dot = 0;
        } else if (duration <= 1 / 16) {
          note = "noteheads.quarter";
          flag = "flags.u16th";
          dot = 0;
        } else if (duration <= 3 / 32) {
          note = "noteheads.quarter";
          flag = "flags.u16nd";
          dot = 1;
        } else if (duration <= 1 / 8) {
          note = "noteheads.quarter";
          flag = "flags.u8th";
          dot = 0;
        } else if (duration <= 3 / 16) {
          note = "noteheads.quarter";
          flag = "flags.u8th";
          dot = 1;
        } else if (duration <= 1 / 4) {
          note = "noteheads.quarter";
          dot = 0;
        } else if (duration <= 3 / 8) {
          note = "noteheads.quarter";
          dot = 1;
        } else if (duration <= 1 / 2) {
          note = "noteheads.half";
          dot = 0;
        } else if (duration <= 3 / 4) {
          note = "noteheads.half";
          dot = 1;
        } else if (duration <= 1) {
          note = "noteheads.whole";
          dot = 0;
        } else if (duration <= 1.5) {
          note = "noteheads.whole";
          dot = 1;
        } else if (duration <= 2) {
          note = "noteheads.dbl";
          dot = 0;
        } else {
          note = "noteheads.dbl";
          dot = 1;
        }
        var ret = createNoteHead(
          absElem,
          note,
          { verticalPos: 0 },
          // This is just temporary: we'll offset the vertical positioning when we get the actual vertical spot.
          "up",
          0,
          0,
          flag,
          dot,
          0,
          temposcale,
          [],
          false
        );
        var tempoNote = ret.notehead;
        absElem.addHead(tempoNote);
        var stem;
        if (note !== "noteheads.whole" && note !== "noteheads.dbl") {
          var p1 = 1 / 3 * temposcale;
          var p2 = 7 * temposcale;
          var dx = tempoNote.dx + tempoNote.w;
          var width = -0.6;
          stem = new RelativeElement(null, dx, 0, p1, { "type": "stem", "pitch2": p2, linewidth: width });
          absElem.addExtra(stem);
        }
        return absElem;
      };
      TempoElement.prototype.draw = function(renderer) {
        var x = this.x;
        if (this.pitch === void 0)
          window.console.error("Tempo Element y-coordinate not set.");
        var y = renderer.calcY(this.pitch);
        var text;
        if (this.tempo.preString) {
          text = renderer.renderText(x, y, this.tempo.preString, "tempofont", "tempo", "start");
          var size = renderer.getTextSize(this.tempo.preString, "tempofont", "tempo", text);
          var preWidth = size.width;
          var charWidth = preWidth / this.tempo.preString.length;
          x += preWidth + charWidth;
        }
        if (this.note) {
          if (this.note)
            this.note.setX(x);
          for (var i = 0; i < this.note.children.length; i++)
            this.note.children[i].draw(renderer, x);
          x += this.note.w + 5;
          var str = "= " + this.tempo.bpm;
          text = renderer.renderText(x, y, str, "tempofont", "tempo", "start");
          size = renderer.getTextSize(str, "tempofont", "tempo", text);
          var postWidth = size.width;
          var charWidth2 = postWidth / str.length;
          x += postWidth + charWidth2;
        }
        if (this.tempo.postString) {
          renderer.renderText(x, y, this.tempo.postString, "tempofont", "tempo", "start");
        }
      };
    })();
    module.exports = TempoElement;
  }
});

// node_modules/abcjs/src/write/abc_triplet_element.js
var require_abc_triplet_element = __commonJS({
  "node_modules/abcjs/src/write/abc_triplet_element.js"(exports, module) {
    var sprintf = require_sprintf();
    var TripletElem;
    (function() {
      "use strict";
      TripletElem = function TripletElem2(number, anchor1, options) {
        this.anchor1 = anchor1;
        this.number = number;
        this.duration = ("" + anchor1.parent.durationClass).replace(/\./, "-");
        this.middleElems = [];
        this.flatBeams = options.flatBeams;
      };
      TripletElem.prototype.isClosed = function() {
        return this.anchor2;
      };
      TripletElem.prototype.middleNote = function(elem) {
        this.middleElems.push(elem);
      };
      TripletElem.prototype.setCloseAnchor = function(anchor2) {
        this.anchor2 = anchor2;
        if (this.anchor1.parent.beam)
          this.endingHeightAbove = 4;
      };
      TripletElem.prototype.setUpperAndLowerElements = function() {
      };
      TripletElem.prototype.layout = function() {
        if (this.anchor1 && this.anchor2) {
          this.hasBeam = this.anchor1.parent.beam && this.anchor1.parent.beam === this.anchor2.parent.beam;
          if (this.hasBeam) {
            var beam = this.anchor1.parent.beam;
            var left = beam.isAbove() ? this.anchor1.x + this.anchor1.w : this.anchor1.x;
            this.yTextPos = beam.heightAtMidpoint(left, this.anchor2.x);
            this.yTextPos += beam.isAbove() ? 3 : -2;
            this.top = this.yTextPos + 1;
            this.bottom = this.yTextPos - 2;
            if (beam.isAbove())
              this.endingHeightAbove = 4;
          } else {
            this.startNote = Math.max(this.anchor1.parent.top, 9) + 4;
            this.endNote = Math.max(this.anchor2.parent.top, 9) + 4;
            if (this.anchor1.parent.type === "rest" && this.anchor2.parent.type !== "rest")
              this.startNote = this.endNote;
            else if (this.anchor2.parent.type === "rest" && this.anchor1.parent.type !== "rest")
              this.endNote = this.startNote;
            var max = 0;
            for (var i = 0; i < this.middleElems.length; i++) {
              max = Math.max(max, this.middleElems[i].top);
            }
            max += 4;
            if (max > this.startNote || max > this.endNote) {
              this.startNote = max;
              this.endNote = max;
            }
            if (this.flatBeams) {
              this.startNote = Math.max(this.startNote, this.endNote);
              this.endNote = Math.max(this.startNote, this.endNote);
            }
            this.yTextPos = this.startNote + (this.endNote - this.startNote) / 2;
            this.top = this.yTextPos + 1;
          }
        }
        delete this.middleElems;
        delete this.flatBeams;
      };
      TripletElem.prototype.draw = function(renderer) {
        var xTextPos;
        if (this.hasBeam) {
          var left = this.anchor1.parent.beam.isAbove() ? this.anchor1.x + this.anchor1.w : this.anchor1.x;
          xTextPos = this.anchor1.parent.beam.xAtMidpoint(left, this.anchor2.x);
        } else {
          xTextPos = this.anchor1.x + (this.anchor2.x + this.anchor2.w - this.anchor1.x) / 2;
          drawBracket(renderer, this.anchor1.x, this.startNote, this.anchor2.x + this.anchor2.w, this.endNote, this.duration);
        }
        renderer.renderText(xTextPos, renderer.calcY(this.yTextPos), "" + this.number, "tripletfont", renderer.addClasses("triplet d" + this.duration), "middle", true);
      };
      function drawLine(renderer, l, t, r, b, duration) {
        var pathString = sprintf(
          "M %f %f L %f %f",
          l,
          t,
          r,
          b
        );
        renderer.printPath({ path: pathString, stroke: "#000000", "class": renderer.addClasses("triplet d" + duration) });
      }
      function drawBracket(renderer, x1, y1, x2, y2, duration) {
        y1 = renderer.calcY(y1);
        y2 = renderer.calcY(y2);
        var bracketHeight = 5;
        drawLine(renderer, x1, y1, x1, y1 + bracketHeight, duration);
        drawLine(renderer, x2, y2, x2, y2 + bracketHeight, duration);
        var midX = x1 + (x2 - x1) / 2;
        var gapWidth = 8;
        var slope = (y2 - y1) / (x2 - x1);
        var leftEndX = midX - gapWidth;
        var leftEndY = y1 + (leftEndX - x1) * slope;
        drawLine(renderer, x1, y1, leftEndX, leftEndY, duration);
        var rightStartX = midX + gapWidth;
        var rightStartY = y1 + (rightStartX - x1) * slope;
        drawLine(renderer, rightStartX, rightStartY, x2, y2, duration);
      }
    })();
    module.exports = TripletElem;
  }
});

// node_modules/abcjs/src/write/abc_voice_element.js
var require_abc_voice_element = __commonJS({
  "node_modules/abcjs/src/write/abc_voice_element.js"(exports, module) {
    var parseCommon = require_abc_common();
    var VoiceElement = function VoiceElement2(voicenumber, voicetotal) {
      this.children = [];
      this.beams = [];
      this.otherchildren = [];
      this.w = 0;
      this.duplicate = false;
      this.voicenumber = voicenumber;
      this.voicetotal = voicetotal;
      this.bottom = 7;
      this.top = 7;
      this.specialY = {
        tempoHeightAbove: 0,
        partHeightAbove: 0,
        volumeHeightAbove: 0,
        dynamicHeightAbove: 0,
        endingHeightAbove: 0,
        chordHeightAbove: 0,
        lyricHeightAbove: 0,
        lyricHeightBelow: 0,
        chordHeightBelow: 0,
        volumeHeightBelow: 0,
        dynamicHeightBelow: 0
      };
    };
    VoiceElement.prototype.addChild = function(child) {
      if (child.type === "bar") {
        var firstItem = true;
        for (var i = 0; firstItem && i < this.children.length; i++) {
          if (this.children[i].type !== "staff-extra" && this.children[i].type !== "tempo")
            firstItem = false;
        }
        if (!firstItem) {
          this.beams.push("bar");
          this.otherchildren.push("bar");
        }
      }
      this.children[this.children.length] = child;
      this.setRange(child);
    };
    VoiceElement.prototype.setLimit = function(member, child) {
      var specialY = child.specialY;
      if (!specialY) specialY = child;
      if (!specialY[member]) return;
      if (!this.specialY[member])
        this.specialY[member] = specialY[member];
      else
        this.specialY[member] = Math.max(this.specialY[member], specialY[member]);
    };
    VoiceElement.prototype.moveDecorations = function(beam) {
      var padding = 1.5;
      for (var ch = 0; ch < beam.elems.length; ch++) {
        var child = beam.elems[ch];
        if (child.top) {
          var top = beam.yAtNote(child);
          for (var i = 0; i < child.children.length; i++) {
            var el = child.children[i];
            if (el.klass === "ornament") {
              if (el.bottom - padding < top) {
                var distance = top - el.bottom + padding;
                el.bottom += distance;
                el.top += distance;
                el.pitch += distance;
                top = child.top = el.top;
              }
            }
          }
        }
      }
    };
    VoiceElement.prototype.adjustRange = function(child) {
      if (child.bottom !== void 0)
        this.bottom = Math.min(this.bottom, child.bottom);
      if (child.top !== void 0)
        this.top = Math.max(this.top, child.top);
    };
    VoiceElement.prototype.setRange = function(child) {
      this.adjustRange(child);
      this.setLimit("tempoHeightAbove", child);
      this.setLimit("partHeightAbove", child);
      this.setLimit("volumeHeightAbove", child);
      this.setLimit("dynamicHeightAbove", child);
      this.setLimit("endingHeightAbove", child);
      this.setLimit("chordHeightAbove", child);
      this.setLimit("lyricHeightAbove", child);
      this.setLimit("lyricHeightBelow", child);
      this.setLimit("chordHeightBelow", child);
      this.setLimit("volumeHeightBelow", child);
      this.setLimit("dynamicHeightBelow", child);
    };
    VoiceElement.prototype.setUpperAndLowerElements = function(positionY) {
      var i;
      for (i = 0; i < this.children.length; i++) {
        var abselem = this.children[i];
        abselem.setUpperAndLowerElements(positionY);
      }
      for (i = 0; i < this.otherchildren.length; i++) {
        var abselem = this.otherchildren[i];
        if (typeof abselem !== "string")
          abselem.setUpperAndLowerElements(positionY);
      }
    };
    VoiceElement.prototype.addOther = function(child) {
      this.otherchildren.push(child);
      this.setRange(child);
    };
    VoiceElement.prototype.addBeam = function(child) {
      this.beams.push(child);
    };
    VoiceElement.prototype.updateIndices = function() {
      if (!this.layoutEnded()) {
        this.durationindex += this.children[this.i].duration;
        if (this.children[this.i].type === "bar") this.durationindex = Math.round(this.durationindex * 64) / 64;
        this.i++;
      }
    };
    VoiceElement.prototype.layoutEnded = function() {
      return this.i >= this.children.length;
    };
    VoiceElement.prototype.getDurationIndex = function() {
      return this.durationindex - (this.children[this.i] && this.children[this.i].duration > 0 ? 0 : 5e-7);
    };
    VoiceElement.prototype.getSpacingUnits = function() {
      return Math.sqrt(this.spacingduration * 8);
    };
    VoiceElement.prototype.getNextX = function() {
      return Math.max(this.minx, this.nextx);
    };
    VoiceElement.prototype.beginLayout = function(startx) {
      this.i = 0;
      this.durationindex = 0;
      this.startx = startx;
      this.minx = startx;
      this.nextx = startx;
      this.spacingduration = 0;
    };
    VoiceElement.prototype.layoutOneItem = function(x, spacing) {
      var child = this.children[this.i];
      if (!child) return 0;
      var er = x - this.minx;
      var extraWidth = child.getExtraWidth();
      if (er < extraWidth) {
        if (this.i === 0 || child.type !== "bar" || this.children[this.i - 1].type !== "part" && this.children[this.i - 1].type !== "tempo")
          x += extraWidth - er;
      }
      child.setX(x);
      this.spacingduration = child.duration;
      this.minx = x + child.getMinWidth();
      if (this.i !== this.children.length - 1) this.minx += child.minspacing;
      this.updateNextX(x, spacing);
      return x;
    };
    VoiceElement.prototype.updateNextX = function(x, spacing) {
      this.nextx = x + spacing * Math.sqrt(this.spacingduration * 8);
    };
    VoiceElement.prototype.shiftRight = function(dx) {
      var child = this.children[this.i];
      if (!child) return;
      child.setX(child.x + dx);
      this.minx += dx;
      this.nextx += dx;
    };
    function isNonSpacerRest(elem) {
      if (elem.type !== "rest")
        return false;
      if (elem.abcelem && elem.abcelem.rest && elem.abcelem.rest.type !== "spacer")
        return true;
      return false;
    }
    VoiceElement.prototype.draw = function(renderer, bartop) {
      var width = this.w - 1;
      renderer.staffbottom = this.staff.bottom;
      renderer.measureNumber = null;
      renderer.noteNumber = null;
      if (this.header) {
        var textpitch = 14 - (this.voicenumber + 1) * (12 / (this.voicetotal + 1));
        renderer.renderText(renderer.padding.left, renderer.calcY(textpitch), this.header, "voicefont", "staff-extra voice-name", "start");
      }
      for (var i = 0, ii = this.children.length; i < ii; i++) {
        var child = this.children[i];
        var justInitializedMeasureNumber = false;
        if (child.type !== "staff-extra" && renderer.measureNumber === null) {
          renderer.measureNumber = 0;
          renderer.noteNumber = 0;
          justInitializedMeasureNumber = true;
        }
        child.draw(renderer, this.barto || i === ii - 1 ? bartop : 0);
        if (child.type === "note" || isNonSpacerRest(child))
          renderer.noteNumber++;
        if (child.type === "bar" && !justInitializedMeasureNumber) {
          renderer.measureNumber++;
          renderer.noteNumber = 0;
        }
      }
      renderer.measureNumber = 0;
      renderer.noteNumber = 0;
      parseCommon.each(this.beams, function(beam) {
        if (beam === "bar") {
          renderer.measureNumber++;
          renderer.noteNumber = 0;
        } else
          beam.draw(renderer);
      });
      renderer.measureNumber = 0;
      renderer.noteNumber = 0;
      var self = this;
      parseCommon.each(this.otherchildren, function(child2) {
        if (child2 === "bar") {
          renderer.measureNumber++;
          renderer.noteNumber = 0;
        } else
          child2.draw(renderer, self.startx + 10, width);
      });
    };
    VoiceElement.prototype.layoutBeams = function() {
      for (var i = 0; i < this.beams.length; i++) {
        if (this.beams[i].layout) {
          this.beams[i].layout();
          this.moveDecorations(this.beams[i]);
          for (var j = 0; j < this.beams[i].elems.length; j++) {
            this.adjustRange(this.beams[i].elems[j]);
          }
        }
      }
      for (i = 0; i < this.otherchildren.length; i++) {
        var child = this.otherchildren[i];
        if (child.layout) {
          child.layout();
          this.adjustRange(child);
        }
      }
      this.staff.top = Math.max(this.staff.top, this.top);
      this.staff.bottom = Math.min(this.staff.bottom, this.bottom);
    };
    module.exports = VoiceElement;
  }
});

// node_modules/abcjs/src/write/abc_abstract_engraver.js
var require_abc_abstract_engraver = __commonJS({
  "node_modules/abcjs/src/write/abc_abstract_engraver.js"(exports, module) {
    var AbsoluteElement = require_abc_absolute_element();
    var BeamElem = require_abc_beam_element();
    var BraceElem = require_abc_brace_element();
    var createClef = require_abc_create_clef();
    var createKeySignature = require_abc_create_key_signature();
    var createTimeSignature = require_abc_create_time_signature();
    var Decoration = require_abc_decoration();
    var EndingElem = require_abc_ending_element();
    var glyphs = require_abc_glyphs();
    var RelativeElement = require_abc_relative_element();
    var spacing = require_abc_spacing();
    var StaffGroupElement = require_abc_staff_group_element();
    var TempoElement = require_abc_tempo_element();
    var TieElem = require_abc_tie_element();
    var TripletElem = require_abc_triplet_element();
    var VoiceElement = require_abc_voice_element();
    var parseCommon = require_abc_common();
    var AbstractEngraver;
    (function() {
      "use strict";
      var getDuration = function(elem) {
        var d = 0;
        if (elem.duration) {
          d = elem.duration;
        }
        return d;
      };
      var hint = false;
      var chartable = {
        rest: { 0: "rests.whole", 1: "rests.half", 2: "rests.quarter", 3: "rests.8th", 4: "rests.16th", 5: "rests.32nd", 6: "rests.64th", 7: "rests.128th", "multi": "rests.multimeasure" },
        note: { "-1": "noteheads.dbl", 0: "noteheads.whole", 1: "noteheads.half", 2: "noteheads.quarter", 3: "noteheads.quarter", 4: "noteheads.quarter", 5: "noteheads.quarter", 6: "noteheads.quarter", 7: "noteheads.quarter", "nostem": "noteheads.quarter" },
        rhythm: { "-1": "noteheads.slash.whole", 0: "noteheads.slash.whole", 1: "noteheads.slash.whole", 2: "noteheads.slash.quarter", 3: "noteheads.slash.quarter", 4: "noteheads.slash.quarter", 5: "noteheads.slash.quarter", 6: "noteheads.slash.quarter", 7: "noteheads.slash.quarter", nostem: "noteheads.slash.nostem" },
        x: { "-1": "noteheads.indeterminate", 0: "noteheads.indeterminate", 1: "noteheads.indeterminate", 2: "noteheads.indeterminate", 3: "noteheads.indeterminate", 4: "noteheads.indeterminate", 5: "noteheads.indeterminate", 6: "noteheads.indeterminate", 7: "noteheads.indeterminate", nostem: "noteheads.indeterminate" },
        harmonic: { "-1": "noteheads.harmonic.quarter", 0: "noteheads.harmonic.quarter", 1: "noteheads.harmonic.quarter", 2: "noteheads.harmonic.quarter", 3: "noteheads.harmonic.quarter", 4: "noteheads.harmonic.quarter", 5: "noteheads.harmonic.quarter", 6: "noteheads.harmonic.quarter", 7: "noteheads.harmonic.quarter", nostem: "noteheads.harmonic.quarter" },
        uflags: { 3: "flags.u8th", 4: "flags.u16th", 5: "flags.u32nd", 6: "flags.u64th" },
        dflags: { 3: "flags.d8th", 4: "flags.d16th", 5: "flags.d32nd", 6: "flags.d64th" }
      };
      AbstractEngraver = function(renderer, tuneNumber, options) {
        this.decoration = new Decoration();
        this.renderer = renderer;
        this.tuneNumber = tuneNumber;
        this.isBagpipes = options.bagpipes;
        this.flatBeams = options.flatbeams;
        this.reset();
      };
      AbstractEngraver.prototype.reset = function() {
        this.slurs = {};
        this.ties = [];
        this.voiceScale = 1;
        this.slursbyvoice = {};
        this.tiesbyvoice = {};
        this.endingsbyvoice = {};
        this.scaleByVoice = {};
        this.tripletmultiplier = 1;
        this.abcline = void 0;
        this.accidentalSlot = void 0;
        this.accidentalshiftx = void 0;
        this.dotshiftx = void 0;
        this.hasVocals = false;
        this.minY = void 0;
        this.partstartelem = void 0;
        this.startlimitelem = void 0;
        this.stemdir = void 0;
      };
      AbstractEngraver.prototype.setStemHeight = function(heightInPixels) {
        this.stemHeight = heightInPixels / spacing.STEP;
      };
      AbstractEngraver.prototype.getCurrentVoiceId = function(s, v) {
        return "s" + s + "v" + v;
      };
      AbstractEngraver.prototype.pushCrossLineElems = function(s, v) {
        this.slursbyvoice[this.getCurrentVoiceId(s, v)] = this.slurs;
        this.tiesbyvoice[this.getCurrentVoiceId(s, v)] = this.ties;
        this.endingsbyvoice[this.getCurrentVoiceId(s, v)] = this.partstartelem;
        this.scaleByVoice[this.getCurrentVoiceId(s, v)] = this.voiceScale;
      };
      AbstractEngraver.prototype.popCrossLineElems = function(s, v) {
        this.slurs = this.slursbyvoice[this.getCurrentVoiceId(s, v)] || {};
        this.ties = this.tiesbyvoice[this.getCurrentVoiceId(s, v)] || [];
        this.partstartelem = this.endingsbyvoice[this.getCurrentVoiceId(s, v)];
        this.voiceScale = this.scaleByVoice[this.getCurrentVoiceId(s, v)];
        if (this.voiceScale === void 0) this.voiceScale = 1;
      };
      AbstractEngraver.prototype.containsLyrics = function(staves) {
        for (var i = 0; i < staves.length; i++) {
          for (var j = 0; j < staves[i].voices.length; j++) {
            for (var k = 0; k < staves[i].voices[j].length; k++) {
              var el = staves[i].voices[j][k];
              if (el.lyric) {
                if (!el.positioning || el.positioning.vocalPosition === "below")
                  this.hasVocals = true;
                return;
              }
            }
          }
        }
      };
      AbstractEngraver.prototype.createABCLine = function(staffs, tempo) {
        this.minY = 2;
        this.containsLyrics(staffs);
        var staffgroup = new StaffGroupElement();
        this.tempoSet = false;
        for (var s = 0; s < staffs.length; s++) {
          if (hint)
            this.restoreState();
          hint = false;
          this.createABCStaff(staffgroup, staffs[s], tempo, s);
        }
        return staffgroup;
      };
      AbstractEngraver.prototype.createABCStaff = function(staffgroup, abcstaff, tempo, s) {
        for (var v = 0; v < abcstaff.voices.length; v++) {
          var voice = new VoiceElement(v, abcstaff.voices.length);
          if (v === 0) {
            voice.barfrom = abcstaff.connectBarLines === "start" || abcstaff.connectBarLines === "continue";
            voice.barto = abcstaff.connectBarLines === "continue" || abcstaff.connectBarLines === "end";
          } else {
            voice.duplicate = true;
          }
          if (abcstaff.title && abcstaff.title[v]) voice.header = abcstaff.title[v];
          var clef = createClef(abcstaff.clef, this.tuneNumber);
          if (clef) {
            if (v === 0 && abcstaff.barNumber) {
              this.addMeasureNumber(abcstaff.barNumber, clef);
            }
            voice.addChild(clef);
          }
          var keySig = createKeySignature(abcstaff.key, this.tuneNumber);
          if (keySig) {
            voice.addChild(keySig);
            this.startlimitelem = keySig;
          }
          if (abcstaff.meter) {
            if (abcstaff.meter.type === "specified") {
              this.measureLength = abcstaff.meter.value[0].num / abcstaff.meter.value[0].den;
            } else
              this.measureLength = 1;
            var ts = createTimeSignature(abcstaff.meter, this.tuneNumber);
            voice.addChild(ts);
            this.startlimitelem = ts;
          }
          if (voice.duplicate)
            voice.children = [];
          var staffLines = abcstaff.clef.stafflines || abcstaff.clef.stafflines === 0 ? abcstaff.clef.stafflines : 5;
          staffgroup.addVoice(voice, s, staffLines);
          var isSingleLineStaff = staffLines === 1;
          this.createABCVoice(abcstaff.voices[v], tempo, s, v, isSingleLineStaff, voice);
          staffgroup.setStaffLimits(voice);
          if (abcstaff.brace === "start") {
            staffgroup.brace = new BraceElem(1, true);
          } else if (abcstaff.brace === "end" && staffgroup.brace) {
            staffgroup.brace.increaseStavesIncluded();
          } else if (abcstaff.brace === "continue" && staffgroup.brace) {
            staffgroup.brace.increaseStavesIncluded();
          }
        }
      };
      function getBeamGroup(abcline, pos) {
        var elem = abcline[pos];
        if (elem.el_type !== "note" || !elem.startBeam || elem.endBeam)
          return { count: 1, elem };
        var group = [];
        while (pos < abcline.length && abcline[pos].el_type === "note") {
          group.push(abcline[pos]);
          if (abcline[pos].endBeam)
            break;
          pos++;
        }
        return { count: group.length, elem: group };
      }
      AbstractEngraver.prototype.createABCVoice = function(abcline, tempo, s, v, isSingleLineStaff, voice) {
        this.popCrossLineElems(s, v);
        this.stemdir = this.isBagpipes ? "down" : null;
        this.abcline = abcline;
        if (this.partstartelem) {
          this.partstartelem = new EndingElem("", null, null);
          voice.addOther(this.partstartelem);
        }
        var voiceNumber = voice.voicetotal < 2 ? -1 : voice.voicenumber;
        for (var slur in this.slurs) {
          if (this.slurs.hasOwnProperty(slur)) {
            this.slurs[slur] = new TieElem({ force: this.slurs[slur].force, voiceNumber, stemDir: this.slurs[slur].stemDir });
            if (hint) this.slurs[slur].setHint();
            voice.addOther(this.slurs[slur]);
          }
        }
        for (var i = 0; i < this.ties.length; i++) {
          this.ties[i] = new TieElem({ force: this.ties[i].force, stemDir: this.ties[i].stemDir, voiceNumber });
          if (hint) this.ties[i].setHint();
          voice.addOther(this.ties[i]);
        }
        for (var j = 0; j < this.abcline.length; j++) {
          setAveragePitch(this.abcline[j]);
          this.minY = Math.min(this.abcline[j].minpitch, this.minY);
        }
        var isFirstStaff = s === 0;
        var pos = 0;
        while (pos < this.abcline.length) {
          var ret = getBeamGroup(this.abcline, pos);
          var abselems = this.createABCElement(isFirstStaff, isSingleLineStaff, voice, ret.elem);
          if (abselems) {
            for (i = 0; i < abselems.length; i++) {
              if (!this.tempoSet && tempo && !tempo.suppress) {
                this.tempoSet = true;
                var tempoElement = new AbsoluteElement(ret.elem, 0, 0, "tempo", this.tuneNumber, {});
                tempoElement.addChild(new TempoElement(tempo, this.tuneNumber, createNoteHead));
                voice.addChild(tempoElement);
              }
              voice.addChild(abselems[i]);
            }
          }
          pos += ret.count;
        }
        this.pushCrossLineElems(s, v);
      };
      AbstractEngraver.prototype.saveState = function() {
        this.tiesSave = parseCommon.cloneArray(this.ties);
        this.slursSave = parseCommon.cloneHashOfHash(this.slurs);
        this.slursbyvoiceSave = parseCommon.cloneHashOfHash(this.slursbyvoice);
        this.tiesbyvoiceSave = parseCommon.cloneHashOfArrayOfHash(this.tiesbyvoice);
      };
      AbstractEngraver.prototype.restoreState = function() {
        this.ties = parseCommon.cloneArray(this.tiesSave);
        this.slurs = parseCommon.cloneHashOfHash(this.slursSave);
        this.slursbyvoice = parseCommon.cloneHashOfHash(this.slursbyvoiceSave);
        this.tiesbyvoice = parseCommon.cloneHashOfArrayOfHash(this.tiesbyvoiceSave);
      };
      AbstractEngraver.prototype.createABCElement = function(isFirstStaff, isSingleLineStaff, voice, elem) {
        var elemset = [];
        switch (elem.el_type) {
          case void 0:
            elemset = this.createBeam(isSingleLineStaff, voice, elem);
            break;
          case "note":
            elemset[0] = this.createNote(elem, false, isSingleLineStaff, voice);
            if (this.triplet && this.triplet.isClosed()) {
              voice.addOther(this.triplet);
              this.triplet = null;
              this.tripletmultiplier = 1;
            }
            break;
          case "bar":
            elemset[0] = this.createBarLine(voice, elem, isFirstStaff);
            if (voice.duplicate && elemset.length > 0) elemset[0].invisible = true;
            break;
          case "meter":
            elemset[0] = createTimeSignature(elem, this.tuneNumber);
            this.startlimitelem = elemset[0];
            if (voice.duplicate && elemset.length > 0) elemset[0].invisible = true;
            break;
          case "clef":
            elemset[0] = createClef(elem, this.tuneNumber);
            if (!elemset[0]) return null;
            if (voice.duplicate && elemset.length > 0) elemset[0].invisible = true;
            break;
          case "key":
            var absKey = createKeySignature(elem, this.tuneNumber);
            if (absKey) {
              elemset[0] = absKey;
              this.startlimitelem = elemset[0];
            }
            if (voice.duplicate && elemset.length > 0) elemset[0].invisible = true;
            break;
          case "stem":
            this.stemdir = elem.direction;
            break;
          case "part":
            var abselem = new AbsoluteElement(elem, 0, 0, "part", this.tuneNumber);
            var dim = this.renderer.getTextSize(elem.title, "partsfont", "part");
            abselem.addChild(new RelativeElement(elem.title, 0, 0, void 0, { type: "part", height: dim.height / spacing.STEP }));
            elemset[0] = abselem;
            break;
          case "tempo":
            var abselem3 = new AbsoluteElement(elem, 0, 0, "tempo", this.tuneNumber);
            abselem3.addChild(new TempoElement(elem, this.tuneNumber, createNoteHead));
            elemset[0] = abselem3;
            break;
          case "style":
            if (elem.head === "normal")
              delete this.style;
            else
              this.style = elem.head;
            break;
          case "hint":
            hint = true;
            this.saveState();
            break;
          case "midi":
            break;
          case "scale":
            this.voiceScale = elem.size;
            break;
          default:
            var abselem2 = new AbsoluteElement(elem, 0, 0, "unsupported", this.tuneNumber);
            abselem2.addChild(new RelativeElement("element type " + elem.el_type, 0, 0, void 0, { type: "debug" }));
            elemset[0] = abselem2;
        }
        return elemset;
      };
      function setAveragePitch(elem) {
        if (elem.pitches) {
          sortPitch(elem);
          var sum = 0;
          for (var p = 0; p < elem.pitches.length; p++) {
            sum += elem.pitches[p].verticalPos;
          }
          elem.averagepitch = sum / elem.pitches.length;
          elem.minpitch = elem.pitches[0].verticalPos;
          elem.maxpitch = elem.pitches[elem.pitches.length - 1].verticalPos;
        }
      }
      AbstractEngraver.prototype.calcBeamDir = function(isSingleLineStaff, voice, elems) {
        if (this.stemdir)
          return this.stemdir;
        var beamelem = new BeamElem(this.stemHeight * this.voiceScale, this.stemdir, this.flatBeams);
        for (var i = 0; i < elems.length; i++) {
          beamelem.add({ abcelem: elems[i] });
        }
        var dir = beamelem.calcDir();
        return dir ? "up" : "down";
      };
      AbstractEngraver.prototype.createBeam = function(isSingleLineStaff, voice, elems) {
        var abselemset = [];
        var dir = this.calcBeamDir(isSingleLineStaff, voice, elems);
        var beamelem = new BeamElem(this.stemHeight * this.voiceScale, dir, this.flatBeams);
        if (hint) beamelem.setHint();
        var oldDir = this.stemdir;
        this.stemdir = dir;
        for (var i = 0; i < elems.length; i++) {
          var elem = elems[i];
          var abselem = this.createNote(elem, true, isSingleLineStaff, voice);
          abselemset.push(abselem);
          beamelem.add(abselem);
          if (this.triplet && this.triplet.isClosed()) {
            voice.addOther(this.triplet);
            this.triplet = null;
            this.tripletmultiplier = 1;
          }
        }
        this.stemdir = oldDir;
        voice.addBeam(beamelem);
        return abselemset;
      };
      var sortPitch = function(elem) {
        var sorted;
        do {
          sorted = true;
          for (var p = 0; p < elem.pitches.length - 1; p++) {
            if (elem.pitches[p].pitch > elem.pitches[p + 1].pitch) {
              sorted = false;
              var tmp = elem.pitches[p];
              elem.pitches[p] = elem.pitches[p + 1];
              elem.pitches[p + 1] = tmp;
            }
          }
        } while (!sorted);
      };
      var ledgerLines = function(abselem, minPitch, maxPitch, isRest, symbolWidth, additionalLedgers, dir, dx, scale) {
        for (var i = maxPitch; i > 11; i--) {
          if (i % 2 === 0 && !isRest) {
            abselem.addChild(new RelativeElement(null, dx, (symbolWidth + 4) * scale, i, { type: "ledger" }));
          }
        }
        for (i = minPitch; i < 1; i++) {
          if (i % 2 === 0 && !isRest) {
            abselem.addChild(new RelativeElement(null, dx, (symbolWidth + 4) * scale, i, { type: "ledger" }));
          }
        }
        for (i = 0; i < additionalLedgers.length; i++) {
          var ofs = symbolWidth;
          if (dir === "down") ofs = -ofs;
          abselem.addChild(new RelativeElement(null, ofs + dx, (symbolWidth + 4) * scale, additionalLedgers[i], { type: "ledger" }));
        }
      };
      AbstractEngraver.prototype.addGraceNotes = function(elem, voice, abselem, notehead, stemHeight, isBagpipes, roomtaken) {
        var gracescale = 3 / 5;
        var graceScaleStem = 3.5 / 5;
        var gracebeam = null;
        var flag;
        if (elem.gracenotes.length > 1) {
          gracebeam = new BeamElem(stemHeight * graceScaleStem, "grace", isBagpipes);
          if (hint) gracebeam.setHint();
          gracebeam.mainNote = abselem;
        }
        var graceoffsets = [];
        for (i = elem.gracenotes.length - 1; i >= 0; i--) {
          roomtaken += 10;
          graceoffsets[i] = roomtaken;
          if (elem.gracenotes[i].accidental) {
            roomtaken += 7;
          }
        }
        var i;
        for (i = 0; i < elem.gracenotes.length; i++) {
          var gracepitch = elem.gracenotes[i].verticalPos;
          flag = gracebeam ? null : chartable.uflags[isBagpipes ? 5 : 3];
          var accidentalSlot = [];
          var ret = createNoteHead(abselem, "noteheads.quarter", elem.gracenotes[i], "up", -graceoffsets[i], -graceoffsets[i], flag, 0, 0, gracescale * this.voiceScale, accidentalSlot, false);
          ret.notehead.highestVert = ret.notehead.pitch + stemHeight * graceScaleStem;
          var grace = ret.notehead;
          this.addSlursAndTies(abselem, elem.gracenotes[i], grace, voice, "up", true);
          abselem.addExtra(grace);
          if (elem.gracenotes[i].acciaccatura) {
            var pos = elem.gracenotes[i].verticalPos + 7 * gracescale;
            var dAcciaccatura = gracebeam ? 5 : 6;
            abselem.addRight(new RelativeElement("flags.ugrace", -graceoffsets[i] + dAcciaccatura, 0, pos, { scalex: gracescale, scaley: gracescale }));
          }
          if (gracebeam) {
            var graceDuration = elem.gracenotes[i].duration / 2;
            if (isBagpipes) graceDuration /= 2;
            var pseudoabselem = {
              heads: [grace],
              abcelem: { averagepitch: gracepitch, minpitch: gracepitch, maxpitch: gracepitch, duration: graceDuration }
            };
            gracebeam.add(pseudoabselem);
          } else {
            var p1 = gracepitch + 1 / 3 * gracescale;
            var p2 = gracepitch + 7 * gracescale;
            var dx = grace.dx + grace.w;
            var width = -0.6;
            abselem.addExtra(new RelativeElement(null, dx, 0, p1, { "type": "stem", "pitch2": p2, linewidth: width }));
          }
          ledgerLines(abselem, gracepitch, gracepitch, false, glyphs.getSymbolWidth("noteheads.quarter"), [], true, grace.dx - 1, 0.6);
          if (i === 0 && !isBagpipes && !(elem.rest && (elem.rest.type === "spacer" || elem.rest.type === "invisible"))) {
            var isTie = elem.gracenotes.length === 1 && grace.pitch === notehead.pitch;
            voice.addOther(new TieElem({ anchor1: grace, anchor2: notehead, isGrace: true }));
          }
        }
        if (gracebeam) {
          voice.addBeam(gracebeam);
        }
        return roomtaken;
      };
      function addRestToAbsElement(abselem, elem, duration, dot, isMultiVoice, stemdir, isSingleLineStaff, durlog, voiceScale) {
        var c;
        var restpitch = 7;
        var noteHead;
        var roomTaken;
        var roomTakenRight;
        if (isMultiVoice) {
          if (stemdir === "down") restpitch = 3;
          if (stemdir === "up") restpitch = 11;
        }
        if (isSingleLineStaff) {
          if (duration < 0.5)
            restpitch = 7;
          else if (duration < 1)
            restpitch = 7;
          else
            restpitch = 5;
        }
        switch (elem.rest.type) {
          case "whole":
            c = chartable.rest[0];
            elem.averagepitch = restpitch;
            elem.minpitch = restpitch;
            elem.maxpitch = restpitch;
            dot = 0;
            break;
          case "rest":
            if (elem.style === "rhythm")
              c = chartable.rhythm[-durlog];
            else
              c = chartable.rest[-durlog];
            elem.averagepitch = restpitch;
            elem.minpitch = restpitch;
            elem.maxpitch = restpitch;
            break;
          case "invisible":
          case "spacer":
            c = "";
            elem.averagepitch = restpitch;
            elem.minpitch = restpitch;
            elem.maxpitch = restpitch;
            break;
          case "multimeasure":
            c = chartable.rest["multi"];
            elem.averagepitch = restpitch;
            elem.minpitch = restpitch;
            elem.maxpitch = restpitch;
            dot = 0;
            var mmWidth = glyphs.getSymbolWidth(c);
            abselem.addHead(new RelativeElement(c, -mmWidth, mmWidth * 2, 7));
            var numMeasures = new RelativeElement("" + elem.duration, 0, mmWidth, 16, { type: "multimeasure-text" });
            abselem.addExtra(numMeasures);
        }
        if (elem.rest.type !== "multimeasure") {
          var ret = createNoteHead(abselem, c, { verticalPos: restpitch }, null, 0, 0, null, dot, 0, voiceScale, [], false);
          noteHead = ret.notehead;
          if (noteHead) {
            abselem.addHead(noteHead);
            roomTaken = ret.accidentalshiftx;
            roomTakenRight = ret.dotshiftx;
          }
        }
        return { noteHead, roomTaken, roomTakenRight };
      }
      function addIfNotExist(arr, item) {
        for (var i = 0; i < arr.length; i++) {
          if (JSON.stringify(arr[i]) === JSON.stringify(item))
            return;
        }
        arr.push(item);
      }
      AbstractEngraver.prototype.addNoteToAbcElement = function(abselem, elem, dot, stemdir, style, zeroDuration, durlog, nostem, voice) {
        var dotshiftx = 0;
        var noteHead;
        var roomTaken = 0;
        var roomTakenRight = 0;
        var min;
        var i;
        var additionalLedgers = [];
        var accidentalSlot = [];
        var symbolWidth = 0;
        var dir = elem.averagepitch >= 6 ? "down" : "up";
        if (stemdir) dir = stemdir;
        style = elem.style ? elem.style : style;
        if (!style || style === "normal") style = "note";
        var noteSymbol;
        if (zeroDuration)
          noteSymbol = chartable[style].nostem;
        else
          noteSymbol = chartable[style][-durlog];
        if (!noteSymbol)
          console.log("noteSymbol:", style, durlog, zeroDuration);
        var p;
        for (p = dir === "down" ? elem.pitches.length - 2 : 1; dir === "down" ? p >= 0 : p < elem.pitches.length; p = dir === "down" ? p - 1 : p + 1) {
          var prev = elem.pitches[dir === "down" ? p + 1 : p - 1];
          var curr = elem.pitches[p];
          var delta = dir === "down" ? prev.pitch - curr.pitch : curr.pitch - prev.pitch;
          if (delta <= 1 && !prev.printer_shift) {
            curr.printer_shift = delta ? "different" : "same";
            if (curr.verticalPos > 11 || curr.verticalPos < 1) {
              additionalLedgers.push(curr.verticalPos - curr.verticalPos % 2);
            }
            if (dir === "down") {
              roomTaken = glyphs.getSymbolWidth(noteSymbol) + 2;
            } else {
              dotshiftx = glyphs.getSymbolWidth(noteSymbol) + 2;
            }
          }
        }
        var pp = elem.pitches.length;
        for (p = 0; p < elem.pitches.length; p++) {
          if (!nostem) {
            var flag;
            if (dir === "down" && p !== 0 || dir === "up" && p !== pp - 1) {
              flag = null;
            } else {
              flag = chartable[dir === "down" ? "dflags" : "uflags"][-durlog];
            }
          }
          var c;
          if (elem.pitches[p].style) {
            c = chartable[elem.pitches[p].style][-durlog];
          } else
            c = noteSymbol;
          elem.pitches[p].highestVert = elem.pitches[p].verticalPos;
          var isTopWhenStemIsDown = (stemdir === "up" || dir === "up") && p === 0;
          var isBottomWhenStemIsUp = (stemdir === "down" || dir === "down") && p === pp - 1;
          if (isTopWhenStemIsDown || isBottomWhenStemIsUp) {
            if (elem.startSlur || pp === 1) {
              elem.pitches[p].highestVert = elem.pitches[pp - 1].verticalPos;
              if (getDuration(elem) < 1 && (stemdir === "up" || dir === "up"))
                elem.pitches[p].highestVert += 6;
            }
            if (elem.startSlur) {
              if (!elem.pitches[p].startSlur) elem.pitches[p].startSlur = [];
              for (i = 0; i < elem.startSlur.length; i++) {
                addIfNotExist(elem.pitches[p].startSlur, elem.startSlur[i]);
              }
            }
            if (elem.endSlur) {
              elem.pitches[p].highestVert = elem.pitches[pp - 1].verticalPos;
              if (getDuration(elem) < 1 && (stemdir === "up" || dir === "up"))
                elem.pitches[p].highestVert += 6;
              if (!elem.pitches[p].endSlur) elem.pitches[p].endSlur = [];
              for (i = 0; i < elem.endSlur.length; i++) {
                addIfNotExist(elem.pitches[p].endSlur, elem.endSlur[i]);
              }
            }
          }
          var hasStem = !nostem && durlog <= -1;
          var ret = createNoteHead(abselem, c, elem.pitches[p], dir, 0, -roomTaken, flag, dot, dotshiftx, this.voiceScale, accidentalSlot, !stemdir);
          symbolWidth = Math.max(glyphs.getSymbolWidth(c), symbolWidth);
          abselem.extraw -= ret.extraLeft;
          noteHead = ret.notehead;
          if (noteHead) {
            this.addSlursAndTies(abselem, elem.pitches[p], noteHead, voice, hasStem ? dir : null, false);
            if (elem.gracenotes && elem.gracenotes.length > 0)
              noteHead.bottom = noteHead.bottom - 1;
            abselem.addHead(noteHead);
          }
          roomTaken += ret.accidentalshiftx;
          roomTakenRight = Math.max(roomTakenRight, ret.dotshiftx);
        }
        if (hasStem) {
          var stemHeight = 7 * this.voiceScale;
          var p1 = dir === "down" ? elem.minpitch - stemHeight : elem.minpitch + 1 / 3;
          if (p1 > 6 && !stemdir) p1 = 6;
          var p2 = dir === "down" ? elem.maxpitch - 1 / 3 : elem.maxpitch + stemHeight;
          if (p2 < 6 && !stemdir) p2 = 6;
          var dx = dir === "down" || abselem.heads.length === 0 ? 0 : abselem.heads[0].w;
          var width = dir === "down" ? 1 : -1;
          if (noteHead.c === "noteheads.slash.quarter") {
            if (dir === "down")
              p2 -= 1;
            else
              p1 += 1;
          }
          abselem.addExtra(new RelativeElement(null, dx, 0, p1, { "type": "stem", "pitch2": p2, linewidth: width }));
          min = Math.min(p1, p2);
        }
        return { noteHead, roomTaken, roomTakenRight, min, additionalLedgers, dir, symbolWidth };
      };
      AbstractEngraver.prototype.addLyric = function(abselem, elem) {
        var lyricStr = "";
        parseCommon.each(elem.lyric, function(ly) {
          var div = ly.divider === " " ? "" : ly.divider;
          lyricStr += ly.syllable + div + "\n";
        });
        var lyricDim = this.renderer.getTextSize(lyricStr, "vocalfont", "lyric");
        var position = elem.positioning ? elem.positioning.vocalPosition : "below";
        abselem.addCentered(new RelativeElement(lyricStr, 0, lyricDim.width, void 0, { type: "lyric", position, height: lyricDim.height / spacing.STEP }));
      };
      AbstractEngraver.prototype.addChord = function(abselem, elem, roomTaken, roomTakenRight) {
        var chordMargin = 8;
        for (var i = 0; i < elem.chord.length; i++) {
          var x = 0;
          var y;
          var dim = this.renderer.getTextSize(elem.chord[i].name, "annotationfont", "annotation");
          var chordWidth = dim.width;
          var chordHeight = dim.height / spacing.STEP;
          switch (elem.chord[i].position) {
            case "left":
              roomTaken += chordWidth + 7;
              x = -roomTaken;
              y = elem.averagepitch;
              abselem.addExtra(new RelativeElement(elem.chord[i].name, x, chordWidth + 4, y, { type: "text", height: chordHeight }));
              break;
            case "right":
              roomTakenRight += 4;
              x = roomTakenRight;
              y = elem.averagepitch;
              abselem.addRight(new RelativeElement(elem.chord[i].name, x, chordWidth + 4, y, { type: "text", height: chordHeight }));
              break;
            case "below":
              abselem.addRight(new RelativeElement(elem.chord[i].name, 0, chordWidth + chordMargin, void 0, { type: "text", position: "below", height: chordHeight }));
              break;
            case "above":
              abselem.addRight(new RelativeElement(elem.chord[i].name, 0, chordWidth + chordMargin, void 0, { type: "text", height: chordHeight }));
              break;
            default:
              if (elem.chord[i].rel_position) {
                var relPositionY = elem.chord[i].rel_position.y + 3 * spacing.STEP;
                abselem.addChild(new RelativeElement(elem.chord[i].name, x + elem.chord[i].rel_position.x, 0, elem.minpitch + relPositionY / spacing.STEP, { type: "text", height: chordHeight }));
              } else {
                var pos2 = "above";
                if (elem.positioning && elem.positioning.chordPosition)
                  pos2 = elem.positioning.chordPosition;
                dim = this.renderer.getTextSize(elem.chord[i].name, "gchordfont", "chord");
                chordHeight = dim.height / spacing.STEP;
                chordWidth = dim.width;
                abselem.addCentered(new RelativeElement(elem.chord[i].name, x, chordWidth, void 0, { type: "chord", position: pos2, height: chordHeight }));
              }
          }
        }
        return { roomTaken, roomTakenRight };
      };
      AbstractEngraver.prototype.createNote = function(elem, nostem, isSingleLineStaff, voice) {
        var notehead = null;
        var roomtaken = 0;
        var roomtakenright = 0;
        var symbolWidth = 0;
        var additionalLedgers = [];
        var i;
        var dir;
        var duration = getDuration(elem);
        var zeroDuration = false;
        if (duration === 0) {
          zeroDuration = true;
          duration = 0.25;
          nostem = true;
        }
        var durlog = Math.floor(Math.log(duration) / Math.log(2));
        var dot = 0;
        for (var tot = Math.pow(2, durlog), inc = tot / 2; tot < duration; dot++, tot += inc, inc /= 2) ;
        if (elem.startTriplet) {
          this.tripletmultiplier = elem.tripletMultiplier;
        }
        var durationForSpacing = duration * this.tripletmultiplier;
        if (elem.rest && elem.rest.type === "multimeasure")
          durationForSpacing = 1;
        var absType = elem.rest ? "rest" : "note";
        var abselem = new AbsoluteElement(elem, durationForSpacing, 1, absType, this.tuneNumber, { durationClassOveride: elem.duration * this.tripletmultiplier });
        if (hint) abselem.setHint();
        if (elem.rest) {
          if (this.measureLength === duration && elem.rest.type !== "invisible" && elem.rest.type !== "spacer")
            elem.rest.type = "whole";
          var ret1 = addRestToAbsElement(abselem, elem, duration, dot, voice.voicetotal > 1, this.stemdir, isSingleLineStaff, durlog, this.voiceScale);
          notehead = ret1.noteHead;
          roomtaken = ret1.roomTaken;
          roomtakenright = ret1.roomTakenRight;
        } else {
          var ret2 = this.addNoteToAbcElement(abselem, elem, dot, this.stemdir, this.style, zeroDuration, durlog, nostem, voice);
          if (ret2.min !== void 0)
            this.minY = Math.min(ret2.min, this.minY);
          notehead = ret2.noteHead;
          roomtaken = ret2.roomTaken;
          roomtakenright = ret2.roomTakenRight;
          additionalLedgers = ret2.additionalLedgers;
          dir = ret2.dir;
          symbolWidth = ret2.symbolWidth;
        }
        if (elem.lyric !== void 0) {
          this.addLyric(abselem, elem);
        }
        if (elem.gracenotes !== void 0) {
          roomtaken += this.addGraceNotes(elem, voice, abselem, notehead, this.stemHeight * this.voiceScale, this.isBagpipes, roomtaken);
        }
        if (elem.decoration) {
          this.decoration.createDecoration(voice, elem.decoration, abselem.top, notehead ? notehead.w : 0, abselem, roomtaken, dir, abselem.bottom, elem.positioning, this.hasVocals);
        }
        if (elem.barNumber) {
          abselem.addChild(new RelativeElement(elem.barNumber, -10, 0, 0, { type: "barNumber" }));
        }
        ledgerLines(abselem, elem.minpitch, elem.maxpitch, elem.rest, symbolWidth, additionalLedgers, dir, -2, 1);
        if (elem.chord !== void 0) {
          var ret3 = this.addChord(abselem, elem, roomtaken, roomtakenright);
          roomtaken = ret3.roomTaken;
          roomtakenright = ret3.roomTakenRight;
        }
        if (elem.startTriplet) {
          this.triplet = new TripletElem(elem.startTriplet, notehead, { flatBeams: this.flatBeams });
        }
        if (elem.endTriplet && this.triplet) {
          this.triplet.setCloseAnchor(notehead);
        }
        if (this.triplet && !elem.startTriplet && !elem.endTriplet) {
          this.triplet.middleNote(notehead);
        }
        return abselem;
      };
      var createNoteHead = function(abselem, c, pitchelem, dir, headx, extrax, flag, dot, dotshiftx, scale, accidentalSlot, shouldExtendStem) {
        var pitch = pitchelem.verticalPos;
        var notehead;
        var i;
        var accidentalshiftx = 0;
        var newDotShiftX = 0;
        var extraLeft = 0;
        if (c === void 0)
          abselem.addChild(new RelativeElement("pitch is undefined", 0, 0, 0, { type: "debug" }));
        else if (c === "") {
          notehead = new RelativeElement(null, 0, 0, pitch);
        } else {
          var shiftheadx = headx;
          if (pitchelem.printer_shift) {
            var adjust = pitchelem.printer_shift === "same" ? 1 : 0;
            shiftheadx = dir === "down" ? -glyphs.getSymbolWidth(c) * scale + adjust : glyphs.getSymbolWidth(c) * scale - adjust;
          }
          var opts = { scalex: scale, scaley: scale, thickness: glyphs.symbolHeightInPitches(c) * scale };
          notehead = new RelativeElement(c, shiftheadx, glyphs.getSymbolWidth(c) * scale, pitch, opts);
          notehead.stemDir = dir;
          if (flag) {
            var pos = pitch + (dir === "down" ? -7 : 7) * scale;
            if (shouldExtendStem) {
              if (dir === "down" && pos > 6)
                pos = 6;
              if (dir === "up" && pos < 6)
                pos = 6;
            }
            var xdelta = dir === "down" ? headx : headx + notehead.w - 0.6;
            abselem.addRight(new RelativeElement(flag, xdelta, glyphs.getSymbolWidth(flag) * scale, pos, { scalex: scale, scaley: scale }));
          }
          newDotShiftX = notehead.w + dotshiftx - 2 + 5 * dot;
          for (; dot > 0; dot--) {
            var dotadjusty = 1 - Math.abs(pitch) % 2;
            abselem.addRight(new RelativeElement("dots.dot", notehead.w + dotshiftx - 2 + 5 * dot, glyphs.getSymbolWidth("dots.dot"), pitch + dotadjusty));
          }
        }
        if (notehead)
          notehead.highestVert = pitchelem.highestVert;
        if (pitchelem.accidental) {
          var symb;
          switch (pitchelem.accidental) {
            case "quartersharp":
              symb = "accidentals.halfsharp";
              break;
            case "dblsharp":
              symb = "accidentals.dblsharp";
              break;
            case "sharp":
              symb = "accidentals.sharp";
              break;
            case "quarterflat":
              symb = "accidentals.halfflat";
              break;
            case "flat":
              symb = "accidentals.flat";
              break;
            case "dblflat":
              symb = "accidentals.dblflat";
              break;
            case "natural":
              symb = "accidentals.nat";
          }
          var accSlotFound = false;
          var accPlace = extrax;
          for (var j = 0; j < accidentalSlot.length; j++) {
            if (pitch - accidentalSlot[j][0] >= 6) {
              accidentalSlot[j][0] = pitch;
              accPlace = accidentalSlot[j][1];
              accSlotFound = true;
              break;
            }
          }
          if (accSlotFound === false) {
            accPlace -= glyphs.getSymbolWidth(symb) * scale + 2;
            accidentalSlot.push([pitch, accPlace]);
            accidentalshiftx = glyphs.getSymbolWidth(symb) * scale + 2;
          }
          abselem.addExtra(new RelativeElement(symb, accPlace, glyphs.getSymbolWidth(symb), pitch, { scalex: scale, scaley: scale }));
          extraLeft = glyphs.getSymbolWidth(symb) / 2;
        }
        return { notehead, accidentalshiftx, dotshiftx: newDotShiftX, extraLeft };
      };
      AbstractEngraver.prototype.addSlursAndTies = function(abselem, pitchelem, notehead, voice, dir, isGrace) {
        if (pitchelem.endTie) {
          if (this.ties.length > 0) {
            var found = false;
            for (var j = 0; j < this.ties.length; j++) {
              if (this.ties[j].anchor1 && this.ties[j].anchor1.pitch === notehead.pitch) {
                this.ties[j].setEndAnchor(notehead);
                this.ties.splice(j, 1);
                found = true;
                break;
              }
            }
            if (!found) {
              this.ties[0].setEndAnchor(notehead);
              this.ties.splice(0, 1);
            }
          }
        }
        var voiceNumber = voice.voicetotal < 2 ? -1 : voice.voicenumber;
        if (pitchelem.startTie) {
          var tie = new TieElem({ anchor1: notehead, force: this.stemdir === "down" || this.stemdir === "up", stemDir: this.stemdir, isGrace, voiceNumber });
          if (hint) tie.setHint();
          this.ties[this.ties.length] = tie;
          voice.addOther(tie);
          abselem.startTie = true;
        }
        if (pitchelem.endSlur) {
          for (var i = 0; i < pitchelem.endSlur.length; i++) {
            var slurid = pitchelem.endSlur[i];
            var slur;
            if (this.slurs[slurid]) {
              slur = this.slurs[slurid];
              slur.setEndAnchor(notehead);
              delete this.slurs[slurid];
            } else {
              slur = new TieElem({ anchor2: notehead, stemDir: this.stemdir, voiceNumber });
              if (hint) slur.setHint();
              voice.addOther(slur);
            }
            if (this.startlimitelem) {
              slur.setStartX(this.startlimitelem);
            }
          }
        } else if (!isGrace) {
          for (var s in this.slurs) {
            if (this.slurs.hasOwnProperty(s)) {
              this.slurs[s].addInternalNote(notehead);
            }
          }
        }
        if (pitchelem.startSlur) {
          for (i = 0; i < pitchelem.startSlur.length; i++) {
            var slurid = pitchelem.startSlur[i].label;
            var slur = new TieElem({ anchor1: notehead, stemDir: this.stemdir, voiceNumber });
            if (hint) slur.setHint();
            this.slurs[slurid] = slur;
            voice.addOther(slur);
          }
        }
      };
      AbstractEngraver.prototype.addMeasureNumber = function(number, abselem) {
        var measureNumHeight = this.renderer.getTextSize(number, "measurefont", "bar-number");
        abselem.addChild(new RelativeElement(number, 0, 0, 11 + measureNumHeight.height / spacing.STEP, { type: "barNumber" }));
      };
      AbstractEngraver.prototype.createBarLine = function(voice, elem, isFirstStaff) {
        var abselem = new AbsoluteElement(elem, 0, 10, "bar", this.tuneNumber);
        var anchor = null;
        var dx = 0;
        if (elem.barNumber) {
          this.addMeasureNumber(elem.barNumber, abselem);
        }
        var firstdots = elem.type === "bar_right_repeat" || elem.type === "bar_dbl_repeat";
        var firstthin = elem.type !== "bar_left_repeat" && elem.type !== "bar_thick_thin" && elem.type !== "bar_invisible";
        var thick = elem.type === "bar_right_repeat" || elem.type === "bar_dbl_repeat" || elem.type === "bar_left_repeat" || elem.type === "bar_thin_thick" || elem.type === "bar_thick_thin";
        var secondthin = elem.type === "bar_left_repeat" || elem.type === "bar_thick_thin" || elem.type === "bar_thin_thin" || elem.type === "bar_dbl_repeat";
        var seconddots = elem.type === "bar_left_repeat" || elem.type === "bar_dbl_repeat";
        if (firstdots || seconddots) {
          for (var slur in this.slurs) {
            if (this.slurs.hasOwnProperty(slur)) {
              this.slurs[slur].setEndX(abselem);
            }
          }
          this.startlimitelem = abselem;
        }
        if (firstdots) {
          abselem.addRight(new RelativeElement("dots.dot", dx, 1, 7));
          abselem.addRight(new RelativeElement("dots.dot", dx, 1, 5));
          dx += 6;
        }
        if (firstthin) {
          anchor = new RelativeElement(null, dx, 1, 2, { "type": "bar", "pitch2": 10, linewidth: 0.6 });
          abselem.addRight(anchor);
        }
        if (elem.type === "bar_invisible") {
          anchor = new RelativeElement(null, dx, 1, 2, { "type": "none", "pitch2": 10, linewidth: 0.6 });
          abselem.addRight(anchor);
        }
        if (elem.decoration) {
          this.decoration.createDecoration(voice, elem.decoration, 12, thick ? 3 : 1, abselem, 0, "down", 2, elem.positioning, this.hasVocals);
        }
        if (thick) {
          dx += 4;
          anchor = new RelativeElement(null, dx, 4, 2, { "type": "bar", "pitch2": 10, linewidth: 4 });
          abselem.addRight(anchor);
          dx += 5;
        }
        if (this.partstartelem && elem.endEnding) {
          this.partstartelem.anchor2 = anchor;
          this.partstartelem = null;
        }
        if (secondthin) {
          dx += 3;
          anchor = new RelativeElement(null, dx, 1, 2, { "type": "bar", "pitch2": 10, linewidth: 0.6 });
          abselem.addRight(anchor);
        }
        if (seconddots) {
          dx += 3;
          abselem.addRight(new RelativeElement("dots.dot", dx, 1, 7));
          abselem.addRight(new RelativeElement("dots.dot", dx, 1, 5));
        }
        if (elem.startEnding && isFirstStaff) {
          var textWidth = this.renderer.getTextSize(elem.startEnding, "repeatfont", "").width;
          abselem.minspacing += textWidth + 10;
          this.partstartelem = new EndingElem(elem.startEnding, anchor, null);
          voice.addOther(this.partstartelem);
        }
        abselem.extraw -= 5;
        return abselem;
      };
    })();
    module.exports = AbstractEngraver;
  }
});

// node_modules/abcjs/src/write/svg.js
var require_svg = __commonJS({
  "node_modules/abcjs/src/write/svg.js"(exports, module) {
    var svgNS = "http://www.w3.org/2000/svg";
    function Svg(wrapper) {
      this.svg = createSvg();
      wrapper.appendChild(this.svg);
    }
    Svg.prototype.clear = function() {
      if (this.svg) {
        var wrapper = this.svg.parentNode;
        this.svg = createSvg();
        if (wrapper) {
          wrapper.innerHTML = "";
          wrapper.appendChild(this.svg);
        }
      }
    };
    Svg.prototype.setTitle = function(title) {
      var titleEl = document.createElement("title");
      var titleNode = document.createTextNode(title);
      titleEl.appendChild(titleNode);
      this.svg.insertBefore(titleEl, this.svg.firstChild);
    };
    Svg.prototype.setResponsiveWidth = function(w, h) {
      this.svg.setAttribute("viewBox", "0 0 " + w + " " + h);
      this.svg.setAttribute("preserveAspectRatio", "xMinYMin meet");
      this.svg.removeAttribute("height");
      this.svg.removeAttribute("width");
      this.svg.style["display"] = "inline-block";
      this.svg.style["position"] = "absolute";
      this.svg.style["top"] = "0";
      this.svg.style["left"] = "0";
      if (this.svg.parentNode) {
        var cls = this.svg.parentNode.getAttribute("class");
        if (!cls)
          this.svg.parentNode.setAttribute("class", "abcjs-container");
        else if (cls.indexOf("abcjs-container") < 0)
          this.svg.parentNode.setAttribute("class", cls + " abcjs-container");
        this.svg.parentNode.style["display"] = "inline-block";
        this.svg.parentNode.style["position"] = "relative";
        this.svg.parentNode.style["width"] = "100%";
        var padding = h / w * 100;
        this.svg.parentNode.style["padding-bottom"] = padding + "%";
        this.svg.parentNode.style["vertical-align"] = "middle";
        this.svg.parentNode.style["overflow"] = "hidden";
      }
    };
    Svg.prototype.setSize = function(w, h) {
      this.svg.setAttribute("width", w);
      this.svg.setAttribute("height", h);
    };
    Svg.prototype.setScale = function(scale) {
      if (scale !== 1) {
        this.svg.style.transform = "scale(" + scale + "," + scale + ")";
        this.svg.style["-ms-transform"] = "scale(" + scale + "," + scale + ")";
        this.svg.style["-webkit-transform"] = "scale(" + scale + "," + scale + ")";
        this.svg.style["transform-origin"] = "0 0";
        this.svg.style["-ms-transform-origin-x"] = "0";
        this.svg.style["-ms-transform-origin-y"] = "0";
        this.svg.style["-webkit-transform-origin-x"] = "0";
        this.svg.style["-webkit-transform-origin-y"] = "0";
      } else {
        this.svg.style.transform = "";
        this.svg.style["-ms-transform"] = "";
        this.svg.style["-webkit-transform"] = "";
      }
    };
    Svg.prototype.setParentStyles = function(attr) {
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          if (this.svg.parentNode)
            this.svg.parentNode.style[key] = attr[key];
        }
      }
      if (this.dummySvg) {
        var body = document.querySelector("body");
        body.removeChild(this.dummySvg);
        this.dummySvg = null;
      }
    };
    Svg.prototype.rect = function(attr) {
      var el = document.createElementNS(svgNS, "rect");
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          var tmp = "" + attr[key];
          if (tmp.indexOf("NaN") >= 0)
            debugger;
          el.setAttributeNS(null, key, attr[key]);
        }
      }
      this.append(el);
      return el;
    };
    Svg.prototype.text = function(text, attr, target) {
      var el = document.createElementNS(svgNS, "text");
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          el.setAttribute(key, attr[key]);
        }
      }
      var lines = ("" + text).split("\n");
      for (var i = 0; i < lines.length; i++) {
        var line = document.createElementNS(svgNS, "tspan");
        line.textContent = lines[i];
        line.setAttribute("x", attr.x ? attr.x : 0);
        if (i !== 0)
          line.setAttribute("dy", "1.2em");
        el.appendChild(line);
      }
      if (target)
        target.appendChild(el);
      else
        this.append(el);
      return el;
    };
    Svg.prototype.guessWidth = function(text, attr) {
      var svg = this.createDummySvg();
      var el = this.text(text, attr, svg);
      var size;
      try {
        size = el.getBBox();
        if (isNaN(size.height) || !size.height)
          size = { width: attr["font-size"] / 2, height: attr["font-size"] + 2 };
        else
          size = { width: size.width, height: size.height };
      } catch (ex) {
        size = { width: attr["font-size"] / 2, height: attr["font-size"] + 2 };
      }
      svg.removeChild(el);
      return size;
    };
    Svg.prototype.createDummySvg = function() {
      if (!this.dummySvg) {
        this.dummySvg = createSvg();
        var styles = [
          "display: block !important;",
          "height: 1px;",
          "width: 1px;",
          "position: absolute;"
        ];
        this.dummySvg.setAttribute("style", styles.join(""));
        var body = document.querySelector("body");
        body.appendChild(this.dummySvg);
      }
      return this.dummySvg;
    };
    Svg.prototype.getTextSize = function(text, attr, el) {
      if (typeof text === "number")
        text = "" + text;
      if (!text || text.match(/^\s+$/))
        return { width: 0, height: 0 };
      var removeLater = !el;
      if (!el)
        el = this.text(text, attr);
      var size;
      try {
        size = el.getBBox();
        if (isNaN(size.height) || !size.height)
          size = this.guessWidth(text, attr);
        else
          size = { width: size.width, height: size.height };
      } catch (ex) {
        size = this.guessWidth(text, attr);
      }
      if (removeLater) {
        if (this.currentGroup)
          this.currentGroup.removeChild(el);
        else
          this.svg.removeChild(el);
      }
      return size;
    };
    Svg.prototype.openGroup = function(options) {
      options = options ? options : {};
      var el = document.createElementNS(svgNS, "g");
      if (options.prepend)
        this.svg.insertBefore(el, this.svg.firstChild);
      else
        this.svg.appendChild(el);
      this.currentGroup = el;
      return el;
    };
    Svg.prototype.closeGroup = function() {
      var g = this.currentGroup;
      this.currentGroup = null;
      return g;
    };
    Svg.prototype.path = function(attr) {
      var el = document.createElementNS(svgNS, "path");
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          if (key === "path")
            el.setAttributeNS(null, "d", attr.path);
          else
            el.setAttributeNS(null, key, attr[key]);
        }
      }
      this.append(el);
      return el;
    };
    Svg.prototype.pathToBack = function(attr) {
      var el = document.createElementNS(svgNS, "path");
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          if (key === "path")
            el.setAttributeNS(null, "d", attr.path);
          else
            el.setAttributeNS(null, key, attr[key]);
        }
      }
      this.prepend(el);
      return el;
    };
    Svg.prototype.append = function(el) {
      if (this.currentGroup)
        this.currentGroup.appendChild(el);
      else
        this.svg.appendChild(el);
    };
    Svg.prototype.prepend = function(el) {
      if (this.currentGroup)
        this.currentGroup.appendChild(el);
      else
        this.svg.insertBefore(el, this.svg.firstChild);
    };
    Svg.prototype.setAttributeOnElement = function(el, attr) {
      for (var key in attr) {
        if (attr.hasOwnProperty(key)) {
          el.setAttributeNS(null, key, attr[key]);
        }
      }
    };
    function createSvg() {
      var svg = document.createElementNS(svgNS, "svg");
      svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
      svg.setAttribute("role", "img");
      return svg;
    }
    module.exports = Svg;
  }
});

// node_modules/abcjs/src/write/abc_renderer.js
var require_abc_renderer = __commonJS({
  "node_modules/abcjs/src/write/abc_renderer.js"(exports, module) {
    var glyphs = require_abc_glyphs();
    var spacing = require_abc_spacing();
    var sprintf = require_sprintf();
    var Svg = require_svg();
    var Renderer = function(paper, doRegression, shouldAddClasses) {
      this.paper = new Svg(paper);
      this.controller = null;
      this.space = 3 * spacing.SPACE;
      this.padding = {};
      this.doRegression = doRegression;
      this.shouldAddClasses = shouldAddClasses;
      if (this.doRegression)
        this.regressionLines = [];
      this.reset();
    };
    Renderer.prototype.reset = function() {
      this.paper.clear();
      this.y = 0;
      this.abctune = null;
      this.lastM = null;
      this.ingroup = false;
      this.path = null;
      this.isPrint = false;
      this.initVerticalSpace();
      if (this.doRegression)
        this.regressionLines = [];
    };
    Renderer.prototype.newTune = function(abcTune) {
      this.abctune = abcTune;
      this.setVerticalSpace(abcTune.formatting);
      this.measureNumber = null;
      this.noteNumber = null;
      this.setPrintMode(abcTune.media === "print");
      this.setPadding(abcTune);
    };
    Renderer.prototype.createElemSet = function() {
      return this.paper.openGroup();
    };
    Renderer.prototype.closeElemSet = function() {
      return this.paper.closeGroup();
    };
    Renderer.prototype.setPrintMode = function(isPrint) {
      this.isPrint = isPrint;
    };
    Renderer.prototype.setPaperSize = function(maxwidth, scale, responsive) {
      var w = (maxwidth + this.padding.right) * scale;
      var h = (this.y + this.padding.bottom) * scale;
      if (this.isPrint)
        h = Math.max(h, 1056);
      if (this.doRegression)
        this.regressionLines.push("PAPER SIZE: (" + w + "," + h + ")");
      var text = "Sheet Music";
      if (this.abctune && this.abctune.metaText && this.abctune.metaText.title)
        text += ' for "' + this.abctune.metaText.title + '"';
      this.paper.setTitle(text);
      var parentStyles = { overflow: "hidden" };
      if (responsive === "resize") {
        this.paper.setResponsiveWidth(w, h);
      } else {
        parentStyles.width = "";
        parentStyles.height = h + "px";
        if (scale < 1) {
          parentStyles.width = w + "px";
          this.paper.setSize(w / scale, h / scale);
        } else
          this.paper.setSize(w, h);
      }
      this.paper.setScale(scale);
      this.paper.setParentStyles(parentStyles);
    };
    Renderer.prototype.setPaddingOverride = function(params) {
      this.paddingOverride = {
        top: params.paddingtop,
        bottom: params.paddingbottom,
        right: params.paddingright,
        left: params.paddingleft
      };
    };
    Renderer.prototype.setPadding = function(abctune) {
      function setPaddingVariable(self, paddingKey, formattingKey, printDefault, screenDefault) {
        if (abctune.formatting[formattingKey] !== void 0)
          self.padding[paddingKey] = abctune.formatting[formattingKey];
        else if (self.paddingOverride[paddingKey] !== void 0)
          self.padding[paddingKey] = self.paddingOverride[paddingKey];
        else if (self.isPrint)
          self.padding[paddingKey] = printDefault;
        else
          self.padding[paddingKey] = screenDefault;
      }
      setPaddingVariable(this, "top", "topmargin", 38, 15);
      setPaddingVariable(this, "bottom", "botmargin", 38, 15);
      setPaddingVariable(this, "left", "leftmargin", 68, 15);
      setPaddingVariable(this, "right", "rightmargin", 68, 15);
    };
    Renderer.prototype.adjustNonScaledItems = function(scale) {
      this.padding.top /= scale;
      this.padding.bottom /= scale;
      this.padding.left /= scale;
      this.padding.right /= scale;
      this.abctune.formatting.headerfont.size /= scale;
      this.abctune.formatting.footerfont.size /= scale;
    };
    Renderer.prototype.initVerticalSpace = function() {
      this.spacing = {
        composer: 7.56,
        // Set the vertical space above the composer.
        graceBefore: 8.67,
        // Define the space before, inside and after the grace notes.
        graceInside: 10.67,
        graceAfter: 16,
        info: 0,
        // Set the vertical space above the infoline.
        lineSkipFactor: 1.1,
        // Set the factor for spacing between lines of text. (multiply this by the font size)
        music: 7.56,
        // Set the vertical space above the first staff.
        paragraphSkipFactor: 0.4,
        // Set the factor for spacing between text paragraphs. (multiply this by the font size)
        parts: 11.33,
        // Set the vertical space above a new part.
        slurHeight: 1,
        // Set the slur height factor.
        staffSeparation: 61.33,
        // Do not put a staff system closer than <unit> from the previous system.
        stemHeight: 26.67 + 10,
        // Set the stem height.
        subtitle: 3.78,
        // Set the vertical space above the subtitle.
        systemStaffSeparation: 48,
        // Do not place the staves closer than <unit> inside a system. * This values applies to all staves when in the tune header. Otherwise, it applies to the next staff
        text: 18.9,
        // Set the vertical space above the history.
        title: 7.56,
        // Set the vertical space above the title.
        top: 30.24,
        //Set the vertical space above the tunes and on the top of the continuation pages.
        vocal: 30.67,
        // Set the vertical space above the lyrics under the staves.
        words: 0
        // Set the vertical space above the lyrics at the end of the tune.
      };
    };
    Renderer.prototype.setVerticalSpace = function(formatting) {
      if (formatting.staffsep !== void 0)
        this.spacing.staffSeparation = formatting.staffsep * 4 / 3;
      if (formatting.composerspace !== void 0)
        this.spacing.composer = formatting.composerspace * 4 / 3;
      if (formatting.partsspace !== void 0)
        this.spacing.parts = formatting.partsspace * 4 / 3;
      if (formatting.textspace !== void 0)
        this.spacing.text = formatting.textspace * 4 / 3;
      if (formatting.musicspace !== void 0)
        this.spacing.music = formatting.musicspace * 4 / 3;
      if (formatting.titlespace !== void 0)
        this.spacing.title = formatting.titlespace * 4 / 3;
      if (formatting.sysstaffsep !== void 0)
        this.spacing.systemStaffSeparation = formatting.sysstaffsep * 4 / 3;
      if (formatting.subtitlespace !== void 0)
        this.spacing.subtitle = formatting.subtitlespace * 4 / 3;
      if (formatting.topspace !== void 0)
        this.spacing.top = formatting.topspace * 4 / 3;
      if (formatting.vocalspace !== void 0)
        this.spacing.vocal = formatting.vocalspace * 4 / 3;
      if (formatting.wordsspace !== void 0)
        this.spacing.words = formatting.wordsspace * 4 / 3;
    };
    Renderer.prototype.topMargin = function(abctune) {
      this.moveY(this.padding.top);
    };
    Renderer.prototype.addMusicPadding = function() {
      this.moveY(this.spacing.music);
    };
    Renderer.prototype.addStaffPadding = function(lastStaffGroup, thisStaffGroup) {
      var lastStaff = lastStaffGroup.staffs[lastStaffGroup.staffs.length - 1];
      var lastBottomLine = -(lastStaff.bottom - 2);
      var nextTopLine = thisStaffGroup.staffs[0].top - 10;
      var naturalSeparation = nextTopLine + lastBottomLine;
      var separationInPixels = naturalSeparation * spacing.STEP;
      if (separationInPixels < this.spacing.staffSeparation)
        this.moveY(this.spacing.staffSeparation - separationInPixels);
    };
    Renderer.prototype.engraveTopText = function(width, abctune) {
      if (abctune.metaText.header && this.isPrint) {
        var headerTextHeight = this.getTextSize("XXXX", "headerfont", "abcjs-header abcjs-meta-top").height;
        this.y -= headerTextHeight;
        this.outputTextIf(this.padding.left, abctune.metaText.header.left, "headerfont", "header meta-top", 0, null, "start");
        this.outputTextIf(this.padding.left + width / 2, abctune.metaText.header.center, "headerfont", "header meta-top", 0, null, "middle");
        this.outputTextIf(this.padding.left + width, abctune.metaText.header.right, "headerfont", "header meta-top", 0, null, "end");
        this.y += headerTextHeight;
      }
      if (this.isPrint)
        this.moveY(this.spacing.top);
      this.outputTextIf(this.padding.left + width / 2, abctune.metaText.title, "titlefont", "title meta-top", this.spacing.title, 0, "middle");
      if (abctune.lines[0])
        this.outputTextIf(this.padding.left + width / 2, abctune.lines[0].subtitle, "subtitlefont", "text meta-top", this.spacing.subtitle, 0, "middle");
      if (abctune.metaText.rhythm || abctune.metaText.origin || abctune.metaText.composer) {
        this.moveY(this.spacing.composer);
        var rSpace = this.outputTextIf(this.padding.left, abctune.metaText.rhythm, "infofont", "meta-top", 0, null, "start");
        var composerLine = "";
        if (abctune.metaText.composer) composerLine += abctune.metaText.composer;
        if (abctune.metaText.origin) composerLine += " (" + abctune.metaText.origin + ")";
        if (composerLine.length > 0) {
          var space = this.outputTextIf(this.padding.left + width, composerLine, "composerfont", "meta-top", 0, null, "end");
          this.moveY(space[1]);
        } else {
          this.moveY(rSpace[1]);
        }
        this.moveY(-6);
      }
      this.outputTextIf(this.padding.left + width, abctune.metaText.author, "composerfont", "meta-top", 0, 0, "end");
      this.outputTextIf(this.padding.left, abctune.metaText.partOrder, "partsfont", "meta-bottom", 0, 0, "start");
    };
    Renderer.prototype.engraveExtraText = function(width, abctune) {
      this.lineNumber = null;
      this.measureNumber = null;
      this.noteNumber = null;
      this.voiceNumber = null;
      if (abctune.metaText.unalignedWords) {
        var hash = this.getFontAndAttr("wordsfont", "meta-bottom");
        var space = this.getTextSize("i", "wordsfont", "meta-bottom");
        if (abctune.metaText.unalignedWords.length > 0)
          this.moveY(this.spacing.words, 1);
        for (var j = 0; j < abctune.metaText.unalignedWords.length; j++) {
          if (abctune.metaText.unalignedWords[j] === "")
            this.moveY(hash.font.size, 1);
          else if (typeof abctune.metaText.unalignedWords[j] === "string") {
            this.outputTextIf(this.padding.left + spacing.INDENT, abctune.metaText.unalignedWords[j], "wordsfont", "meta-bottom", 0, 0, "start");
          } else {
            var largestY = 0;
            var offsetX = 0;
            for (var k = 0; k < abctune.metaText.unalignedWords[j].length; k++) {
              var thisWord = abctune.metaText.unalignedWords[j][k];
              var type = thisWord.font ? thisWord.font : "wordsfont";
              var el = this.renderText(this.padding.left + spacing.INDENT + offsetX, this.y, thisWord.text, type, "meta-bottom", false);
              var size = this.getTextSize(thisWord.text, type, "meta-bottom");
              largestY = Math.max(largestY, size.height);
              offsetX += size.width;
              if (thisWord.text[thisWord.text.length - 1] === " ") {
                offsetX += space.width;
              }
            }
            this.moveY(largestY, 1);
          }
        }
        if (abctune.metaText.unalignedWords.length > 0)
          this.moveY(hash.font.size, 2);
      }
      var extraText = "";
      if (abctune.metaText.book) extraText += "Book: " + abctune.metaText.book + "\n";
      if (abctune.metaText.source) extraText += "Source: " + abctune.metaText.source + "\n";
      if (abctune.metaText.discography) extraText += "Discography: " + abctune.metaText.discography + "\n";
      if (abctune.metaText.notes) extraText += "Notes: " + abctune.metaText.notes + "\n";
      if (abctune.metaText.transcription) extraText += "Transcription: " + abctune.metaText.transcription + "\n";
      if (abctune.metaText.history) extraText += "History: " + abctune.metaText.history + "\n";
      if (abctune.metaText["abc-copyright"]) extraText += "Copyright: " + abctune.metaText["abc-copyright"] + "\n";
      if (abctune.metaText["abc-creator"]) extraText += "Creator: " + abctune.metaText["abc-creator"] + "\n";
      if (abctune.metaText["abc-edited-by"]) extraText += "Edited By: " + abctune.metaText["abc-edited-by"] + "\n";
      this.outputTextIf(this.padding.left, extraText, "historyfont", "meta-bottom", this.spacing.info, 0, "start");
      if (abctune.metaText.footer && this.isPrint) {
        this.outputTextIf(this.padding.left, abctune.metaText.footer.left, "footerfont", "header meta-bottom", 0, null, "start");
        this.outputTextIf(this.padding.left + width / 2, abctune.metaText.footer.center, "footerfont", "header meta-bottom", 0, null, "middle");
        this.outputTextIf(this.padding.left + width, abctune.metaText.footer.right, "footerfont", "header meta-bottom", 0, null, "end");
      }
    };
    Renderer.prototype.outputFreeText = function(text, vskip) {
      if (vskip)
        this.moveY(vskip);
      var hash = this.getFontAndAttr("textfont", "defined-text");
      if (text === "") {
        this.moveY(hash.attr["font-size"] * 2);
      } else if (typeof text === "string") {
        this.moveY(hash.attr["font-size"] / 2);
        this.outputTextIf(this.padding.left, text, "textfont", "defined-text", 0, 0, "start");
      } else {
        var str = "";
        var isCentered = false;
        for (var i = 0; i < text.length; i++) {
          if (text[i].font)
            str += "FONT(" + text[i].font + ")";
          str += text[i].text;
          if (text[i].center)
            isCentered = true;
        }
        var alignment = isCentered ? "middle" : "start";
        var x = isCentered ? this.controller.width / 2 : this.padding.left;
        this.outputTextIf(x, str, "textfont", "defined-text", 0, 1, alignment);
      }
    };
    Renderer.prototype.outputSeparator = function(separator) {
      if (!separator.lineLength)
        return;
      this.moveY(separator.spaceAbove);
      this.printSeparator(separator.lineLength);
      this.moveY(separator.spaceBelow);
    };
    Renderer.prototype.outputSubtitle = function(width, subtitle) {
      this.outputTextIf(this.padding.left + width / 2, subtitle, "subtitlefont", "text meta-top", this.spacing.subtitle, 0, "middle");
    };
    Renderer.prototype.beginGroup = function() {
      this.path = [];
      this.lastM = [0, 0];
      this.ingroup = true;
    };
    Renderer.prototype.addPath = function(path) {
      path = path || [];
      if (path.length === 0) return;
      path[0][0] = "m";
      path[0][1] -= this.lastM[0];
      path[0][2] -= this.lastM[1];
      this.lastM[0] += path[0][1];
      this.lastM[1] += path[0][2];
      this.path.push(path[0]);
      for (var i = 1, ii = path.length; i < ii; i++) {
        if (path[i][0] === "m") {
          this.lastM[0] += path[i][1];
          this.lastM[1] += path[i][2];
        }
        this.path.push(path[i]);
      }
    };
    Renderer.prototype.endGroup = function(klass) {
      this.ingroup = false;
      if (this.path.length === 0) return null;
      var path = "";
      for (var i = 0; i < this.path.length; i++)
        path += this.path[i].join(" ");
      var ret = this.paper.path({ path, stroke: "none", fill: "#000000", "class": this.addClasses(klass) });
      this.path = [];
      if (this.doRegression) this.addToRegression(ret);
      return ret;
    };
    Renderer.prototype.printStaveLine = function(x1, x2, pitch, klass) {
      var extraClass = "staff";
      if (klass !== void 0)
        extraClass += " " + klass;
      var isIE = (
        /*@cc_on!@*/
        false
      );
      var dy = 0.35;
      var fill = "#000000";
      if (isIE) {
        dy = 1;
        fill = "#666666";
      }
      var y = this.calcY(pitch);
      var pathString = sprintf(
        "M %f %f L %f %f L %f %f L %f %f z",
        x1,
        y - dy,
        x2,
        y - dy,
        x2,
        y + dy,
        x1,
        y + dy
      );
      var ret = this.paper.pathToBack({ path: pathString, stroke: "none", fill, "class": this.addClasses(extraClass) });
      if (this.doRegression) this.addToRegression(ret);
      return ret;
    };
    Renderer.prototype.printStem = function(x, dx, y1, y2) {
      if (dx < 0) {
        var tmp = y2;
        y2 = y1;
        y1 = tmp;
      }
      var isIE = (
        /*@cc_on!@*/
        false
      );
      var fill = "#000000";
      if (isIE && dx < 1) {
        dx = 1;
        fill = "#666666";
      }
      if (~~x === x) x += 0.05;
      var pathArray = [["M", x, y1], ["L", x, y2], ["L", x + dx, y2], ["L", x + dx, y1], ["z"]];
      if (!isIE && this.ingroup) {
        this.addPath(pathArray);
      } else {
        var path = "";
        for (var i = 0; i < pathArray.length; i++)
          path += pathArray[i].join(" ");
        var ret = this.paper.pathToBack({ path, stroke: "none", fill, "class": this.addClasses("stem") });
        if (this.doRegression) this.addToRegression(ret);
        return ret;
      }
    };
    function kernSymbols(lastSymbol, thisSymbol, lastSymbolWidth) {
      var width = lastSymbolWidth;
      if (lastSymbol === "f" && thisSymbol === "f")
        width = width * 2 / 3;
      if (lastSymbol === "p" && thisSymbol === "p")
        width = width * 5 / 6;
      if (lastSymbol === "f" && thisSymbol === "z")
        width = width * 5 / 8;
      return width;
    }
    Renderer.prototype.printSymbol = function(x, offset, symbol, scalex, scaley, klass) {
      var el;
      var ycorr;
      if (!symbol) return null;
      if (symbol.length > 1 && symbol.indexOf(".") < 0) {
        this.paper.openGroup();
        var dx = 0;
        for (var i = 0; i < symbol.length; i++) {
          var s = symbol.charAt(i);
          ycorr = glyphs.getYCorr(s);
          el = glyphs.printSymbol(x + dx, this.calcY(offset + ycorr), s, this.paper, klass);
          if (el) {
            if (this.doRegression) this.addToRegression(el);
            if (i < symbol.length - 1)
              dx += kernSymbols(s, symbol.charAt(i + 1), glyphs.getSymbolWidth(s));
          } else {
            this.renderText(x, this.y, "no symbol:" + symbol, "debugfont", "debug-msg", "start");
          }
        }
        return this.paper.closeGroup();
      } else {
        ycorr = glyphs.getYCorr(symbol);
        if (this.ingroup) {
          this.addPath(glyphs.getPathForSymbol(x, this.calcY(offset + ycorr), symbol, scalex, scaley));
        } else {
          el = glyphs.printSymbol(x, this.calcY(offset + ycorr), symbol, this.paper, klass);
          if (el) {
            if (this.doRegression) this.addToRegression(el);
            return el;
          } else
            this.renderText(x, this.y, "no symbol:" + symbol, "debugfont", "debug-msg", "start");
        }
        return null;
      }
    };
    Renderer.prototype.scaleExistingElem = function(elem, scaleX, scaleY, x, y) {
      this.paper.setAttributeOnElement(elem, { style: "transform:scale(" + scaleX + "," + scaleY + ");transform-origin:" + x + "px " + y + "px;" });
    };
    Renderer.prototype.printPath = function(attrs) {
      var ret = this.paper.path(attrs);
      if (this.doRegression) this.addToRegression(ret);
      return ret;
    };
    Renderer.prototype.drawBrace = function(xLeft, yTop, yBottom) {
      var yHeight = yBottom - yTop;
      var xCurve = [7.5, -8, 21, 0, 18.5, -10.5, 7.5];
      var yCurve = [0, yHeight / 5.5, yHeight / 3.14, yHeight / 2, yHeight / 2.93, yHeight / 4.88, 0];
      var pathString = sprintf(
        "M %f %f C %f %f %f %f %f %f C %f %f %f %f %f %f z",
        xLeft + xCurve[0],
        yTop + yCurve[0],
        xLeft + xCurve[1],
        yTop + yCurve[1],
        xLeft + xCurve[2],
        yTop + yCurve[2],
        xLeft + xCurve[3],
        yTop + yCurve[3],
        xLeft + xCurve[4],
        yTop + yCurve[4],
        xLeft + xCurve[5],
        yTop + yCurve[5],
        xLeft + xCurve[6],
        yTop + yCurve[6]
      );
      var ret1 = this.paper.path({ path: pathString, stroke: "#000000", fill: "#000000", "class": this.addClasses("brace") });
      xCurve = [0, 17.5, -7.5, 6.6, -5, 20, 0];
      yCurve = [yHeight / 2, yHeight / 1.46, yHeight / 1.22, yHeight, yHeight / 1.19, yHeight / 1.42, yHeight / 2];
      pathString = sprintf(
        "M %f %f C %f %f %f %f %f %f C %f %f %f %f %f %f z",
        xLeft + xCurve[0],
        yTop + yCurve[0],
        xLeft + xCurve[1],
        yTop + yCurve[1],
        xLeft + xCurve[2],
        yTop + yCurve[2],
        xLeft + xCurve[3],
        yTop + yCurve[3],
        xLeft + xCurve[4],
        yTop + yCurve[4],
        xLeft + xCurve[5],
        yTop + yCurve[5],
        xLeft + xCurve[6],
        yTop + yCurve[6]
      );
      var ret2 = this.paper.path({ path: pathString, stroke: "#000000", fill: "#000000", "class": this.addClasses("brace") });
      if (this.doRegression) {
        this.addToRegression(ret1);
        this.addToRegression(ret2);
      }
      return ret1 + ret2;
    };
    Renderer.prototype.drawArc = function(x1, x2, pitch1, pitch2, above, klass, isTie) {
      var spacing2 = isTie ? 1.2 : 1.5;
      x1 = x1 + 6;
      x2 = x2 + 4;
      pitch1 = pitch1 + (above ? spacing2 : -spacing2);
      pitch2 = pitch2 + (above ? spacing2 : -spacing2);
      var y1 = this.calcY(pitch1);
      var y2 = this.calcY(pitch2);
      var dx = x2 - x1;
      var dy = y2 - y1;
      var norm = Math.sqrt(dx * dx + dy * dy);
      var ux = dx / norm;
      var uy = dy / norm;
      var flatten = norm / 3.5;
      var maxFlatten = isTie ? 10 : 25;
      var curve = (above ? -1 : 1) * Math.min(maxFlatten, Math.max(4, flatten));
      var controlx1 = x1 + flatten * ux - curve * uy;
      var controly1 = y1 + flatten * uy + curve * ux;
      var controlx2 = x2 - flatten * ux - curve * uy;
      var controly2 = y2 - flatten * uy + curve * ux;
      var thickness = 2;
      var pathString = sprintf(
        "M %f %f C %f %f %f %f %f %f C %f %f %f %f %f %f z",
        x1,
        y1,
        controlx1,
        controly1,
        controlx2,
        controly2,
        x2,
        y2,
        controlx2 - thickness * uy,
        controly2 + thickness * ux,
        controlx1 - thickness * uy,
        controly1 + thickness * ux,
        x1,
        y1
      );
      if (klass)
        klass += " slur";
      else
        klass = "slur";
      var ret = this.paper.path({ path: pathString, stroke: "none", fill: "#000000", "class": this.addClasses(klass) });
      if (this.doRegression) this.addToRegression(ret);
      return ret;
    };
    Renderer.prototype.calcY = function(ofs) {
      return this.y - ofs * spacing.STEP;
    };
    Renderer.prototype.printStave = function(startx, endx, numLines) {
      var klass = "top-line";
      this.paper.openGroup({ prepend: true });
      if (numLines === 1) {
        this.printStaveLine(startx, endx, 6, klass);
        return;
      }
      for (var i = numLines - 1; i >= 0; i--) {
        this.printStaveLine(startx, endx, (i + 1) * 2, klass);
        klass = void 0;
      }
      this.paper.closeGroup();
    };
    Renderer.prototype.addClasses = function(c, isNote) {
      if (!this.shouldAddClasses)
        return "";
      var ret = [];
      if (c.length > 0) ret.push(c);
      if (this.lineNumber !== null && this.lineNumber !== void 0) ret.push("l" + this.lineNumber);
      if (this.measureNumber !== null && this.measureNumber !== void 0) ret.push("m" + this.measureNumber);
      if (this.voiceNumber !== null && this.voiceNumber !== void 0) ret.push("v" + this.voiceNumber);
      if ((c.indexOf("note") >= 0 || c.indexOf("rest") >= 0 || c.indexOf("lyric") >= 0) && this.noteNumber !== null && this.noteNumber !== void 0) ret.push("n" + this.noteNumber);
      if (ret.length > 0) {
        ret = ret.join(" ");
        ret = ret.split(" ");
        for (var i = 0; i < ret.length; i++) {
          if (ret[i].indexOf("abcjs-") !== 0 && ret[i].length > 0)
            ret[i] = "abcjs-" + ret[i];
        }
      }
      return ret.join(" ");
    };
    Renderer.prototype.getFontAndAttr = function(type, klass) {
      var font;
      if (typeof type === "string") {
        font = this.abctune.formatting[type];
        if (font)
          font = { face: font.face, size: font.size * 4 / 3, decoration: font.decoration, style: font.style, weight: font.weight, box: font.box };
        else
          font = { face: "Arial", size: 12 * 4 / 3, decoration: "underline", style: "normal", weight: "normal" };
      } else
        font = { face: type.face, size: type.size * 4 / 3, decoration: type.decoration, style: type.style, weight: type.weight, box: type.box };
      var attr = {
        "font-size": font.size,
        "font-style": font.style,
        "font-family": font.face,
        "font-weight": font.weight,
        "text-decoration": font.decoration,
        "class": this.addClasses(klass)
      };
      attr.font = "";
      return { font, attr };
    };
    Renderer.prototype.getTextSize = function(text, type, klass, el) {
      var hash = this.getFontAndAttr(type, klass);
      var size = this.paper.getTextSize(text, hash.attr, el);
      if (hash.font.box) {
        size.height += 8;
        size.width += 8;
      }
      return size;
    };
    Renderer.prototype.renderText = function(x, y, text, type, klass, anchor, centerVertically) {
      var hash = this.getFontAndAttr(type, klass);
      if (anchor)
        hash.attr["text-anchor"] = anchor;
      hash.attr.x = x;
      hash.attr.y = y + 7;
      if (!centerVertically)
        hash.attr.dy = "0.5em";
      if (type === "debugfont") {
        console.log("Debug msg: " + text);
        hash.attr.stroke = "#ff0000";
      }
      text = text.replace(/\n\n/g, "\n \n");
      text = text.replace(/^\n/, "\n");
      if (hash.font.box) {
        hash.attr.x += 2;
        hash.attr.y += 4;
      }
      var el = this.paper.text(text, hash.attr);
      if (hash.font.box) {
        var size = this.getTextSize(text, type, klass);
        var padding = 2;
        var margin = 2;
        this.paper.rect({ x: x - padding, y, width: size.width + padding * 2, height: size.height + padding * 2 - margin, stroke: "#888888", fill: "transparent" });
      }
      if (this.doRegression) this.addToRegression(el);
      return el;
    };
    Renderer.prototype.moveY = function(em, numLines) {
      if (numLines === void 0) numLines = 1;
      this.y += em * numLines;
    };
    Renderer.prototype.skipSpaceY = function() {
      this.y += this.space;
    };
    Renderer.prototype.outputTextIf = function(x, str, kind, klass, marginTop, marginBottom, alignment) {
      if (str) {
        if (marginTop)
          this.moveY(marginTop);
        var el = this.renderText(x, this.y, str, kind, klass, alignment);
        var bb = this.getTextSize(str, kind, klass);
        var width = isNaN(bb.width) ? 0 : bb.width;
        var height = isNaN(bb.height) ? 0 : bb.height;
        var hash = this.getFontAndAttr(kind, klass);
        if (hash.font.box) {
          width += 8;
          height += 8;
        }
        if (marginBottom !== null) {
          var numLines = str.split("\n").length;
          if (!isNaN(bb.height))
            this.moveY(height / numLines, numLines + marginBottom);
        }
        return [width, height];
      }
      return [0, 0];
    };
    Renderer.prototype.addInvisibleMarker = function(className) {
      var dy = 0.35;
      var fill = "rgba(0,0,0,0)";
      var y = this.y;
      y = Math.round(y);
      var x1 = 0;
      var x2 = 100;
      var pathString = sprintf(
        "M %f %f L %f %f L %f %f L %f %f z",
        x1,
        y - dy,
        x1 + x2,
        y - dy,
        x2,
        y + dy,
        x1,
        y + dy
      );
      this.paper.pathToBack({ path: pathString, stroke: "none", fill, "fill-opacity": 0, "class": this.addClasses(className), "data-vertical": y });
    };
    Renderer.prototype.printSeparator = function(width) {
      var fill = "rgba(0,0,0,255)";
      var stroke = "rgba(0,0,0,0)";
      var y = Math.round(this.y);
      var staffWidth = this.controller.width;
      var x1 = (staffWidth - width) / 2;
      var x2 = x1 + width;
      var pathString = "M " + x1 + " " + y + " L " + x2 + " " + y + " L " + x2 + " " + (y + 1) + " L " + x1 + " " + (y + 1) + " L " + x1 + " " + y + " z";
      this.paper.pathToBack({ path: pathString, stroke, fill, "class": this.addClasses("defined-text") });
    };
    Renderer.prototype.printHorizontalLine = function(width, vertical, comment) {
      var dy = 0.35;
      var fill = "rgba(0,0,255,.4)";
      var y = this.y;
      if (vertical) y = vertical;
      y = Math.round(y);
      this.paper.text("" + Math.round(y), { x: 10, y, "text-anchor": "start", "font-size": "18px", fill, stroke: fill });
      var x1 = 50;
      var x2 = width;
      var pathString = sprintf(
        "M %f %f L %f %f L %f %f L %f %f z",
        x1,
        y - dy,
        x1 + x2,
        y - dy,
        x2,
        y + dy,
        x1,
        y + dy
      );
      this.paper.pathToBack({ path: pathString, stroke: "none", fill, "class": this.addClasses("staff") });
      for (var i = 1; i < width / 100; i++) {
        pathString = sprintf(
          "M %f %f L %f %f L %f %f L %f %f z",
          i * 100 - dy,
          y - 5,
          i * 100 - dy,
          y + 5,
          i * 100 + dy,
          y - 5,
          i * 100 + dy,
          y + 5
        );
        this.paper.pathToBack({ path: pathString, stroke: "none", fill, "class": this.addClasses("staff") });
      }
      if (comment)
        this.paper.text(comment, { x: width + 70, y, "text-anchor": "start", "font-size": "18px", fill, stroke: fill });
    };
    Renderer.prototype.printShadedBox = function(x, y, width, height, color, opacity, comment) {
      var box = this.paper.rect({ x, y, width, height, fill: color, stroke: color, "fill-opacity": opacity, "stroke-opacity": opacity });
      if (comment)
        this.paper.text(comment, { x: 0, y: y + 7, "text-anchor": "start", "font-size": "14px", fill: "rgba(0,0,255,.4)", stroke: "rgba(0,0,255,.4)" });
      return box;
    };
    Renderer.prototype.printVerticalLine = function(x, y1, y2) {
      var dy = 0.35;
      var fill = "#00aaaa";
      var pathString = sprintf(
        "M %f %f L %f %f L %f %f L %f %f z",
        x - dy,
        y1,
        x - dy,
        y2,
        x + dy,
        y1,
        x + dy,
        y2
      );
      this.paper.pathToBack({ path: pathString, stroke: "none", fill, "class": this.addClasses("staff") });
      pathString = sprintf(
        "M %f %f L %f %f L %f %f L %f %f z",
        x - 20,
        y1,
        x - 20,
        y1 + 3,
        x,
        y1,
        x,
        y1 + 3
      );
      this.paper.pathToBack({ path: pathString, stroke: "none", fill, "class": this.addClasses("staff") });
      pathString = sprintf(
        "M %f %f L %f %f L %f %f L %f %f z",
        x + 20,
        y2,
        x + 20,
        y2 + 3,
        x,
        y2,
        x,
        y2 + 3
      );
      this.paper.pathToBack({ path: pathString, stroke: "none", fill, "class": this.addClasses("staff") });
    };
    Renderer.prototype.addToRegression = function(el) {
      var box;
      try {
        box = el.getBBox();
      } catch (e) {
        box = { width: 0, height: 0 };
      }
      var str = el.type + " " + box.toString() + " ";
      var attrs = [];
      for (var key in el.attrs) {
        if (el.attrs.hasOwnProperty(key)) {
          if (key === "class")
            str = el.attrs[key] + " " + str;
          else
            attrs.push(key + ": " + el.attrs[key]);
        }
      }
      attrs.sort();
      str += "{ " + attrs.join(" ") + " }";
      this.regressionLines.push(str);
    };
    module.exports = Renderer;
  }
});

// node_modules/abcjs/src/write/abc_engraver_controller.js
var require_abc_engraver_controller = __commonJS({
  "node_modules/abcjs/src/write/abc_engraver_controller.js"(exports, module) {
    var spacing = require_abc_spacing();
    var AbstractEngraver = require_abc_abstract_engraver();
    var Renderer = require_abc_renderer();
    var EngraverController = function(paper, params) {
      params = params || {};
      this.responsive = params.responsive;
      this.space = 3 * spacing.SPACE;
      this.scale = params.scale ? parseFloat(params.scale) : 0;
      if (!(this.scale > 0.1))
        this.scale = void 0;
      if (params.staffwidth) {
        this.staffwidthScreen = params.staffwidth;
        this.staffwidthPrint = params.staffwidth;
      } else {
        this.staffwidthScreen = 740;
        this.staffwidthPrint = 680;
      }
      this.editable = params.editable || false;
      this.listeners = [];
      if (params.clickListener)
        this.addSelectListener(params.clickListener);
      this.renderer = new Renderer(paper, params.regression, params.add_classes);
      this.renderer.setPaddingOverride(params);
      this.renderer.controller = this;
      this.reset();
    };
    EngraverController.prototype.reset = function() {
      this.selected = [];
      this.ingroup = false;
      this.staffgroups = [];
      this.lastStaffGroupIndex = -1;
      if (this.engraver)
        this.engraver.reset();
      this.engraver = null;
      this.renderer.reset();
    };
    EngraverController.prototype.engraveABC = function(abctunes, tuneNumber) {
      if (abctunes[0] === void 0) {
        abctunes = [abctunes];
      }
      this.reset();
      for (var i = 0; i < abctunes.length; i++) {
        if (tuneNumber === void 0)
          tuneNumber = i;
        this.engraveTune(abctunes[i], tuneNumber);
      }
      if (this.renderer.doRegression)
        return this.renderer.regressionLines.join("\n");
    };
    EngraverController.prototype.adjustNonScaledItems = function(scale) {
      this.width /= scale;
      this.renderer.adjustNonScaledItems(scale);
    };
    EngraverController.prototype.getMeasureWidths = function(abcTune) {
      this.reset();
      this.renderer.lineNumber = null;
      this.renderer.newTune(abcTune);
      this.engraver = new AbstractEngraver(this.renderer, 0, { bagpipes: abcTune.formatting.bagpipes, flatbeams: abcTune.formatting.flatbeams });
      this.engraver.setStemHeight(this.renderer.spacing.stemHeight);
      if (abcTune.formatting.staffwidth) {
        this.width = abcTune.formatting.staffwidth * 1.33;
      } else {
        this.width = this.renderer.isPrint ? this.staffwidthPrint : this.staffwidthScreen;
      }
      var scale = abcTune.formatting.scale ? abcTune.formatting.scale : this.scale;
      if (this.responsive === "resize")
        scale = void 0;
      if (scale === void 0) scale = this.renderer.isPrint ? 0.75 : 1;
      this.adjustNonScaledItems(scale);
      var ret = { left: 0, measureWidths: [], height: 0, total: 0 };
      ret.height = this.renderer.padding.top + this.renderer.spacing.music + this.renderer.padding.bottom + 24;
      var debug = false;
      var hasPrintedTempo = false;
      for (var i = 0; i < abcTune.lines.length; i++) {
        var abcLine = abcTune.lines[i];
        if (abcLine.staff) {
          abcLine.staffGroup = this.engraver.createABCLine(abcLine.staff, !hasPrintedTempo ? abcTune.metaText.tempo : null);
          abcLine.staffGroup.layout(0, this.renderer, debug);
          if (abcLine.staffGroup.voices.length > 0) {
            var voice = abcLine.staffGroup.voices[0];
            var foundNotStaffExtra = false;
            var lastXPosition = 0;
            for (var k = 0; k < voice.children.length; k++) {
              var child = voice.children[k];
              if (!foundNotStaffExtra && !child.isClef && !child.isKeySig) {
                foundNotStaffExtra = true;
                ret.left = child.x;
                lastXPosition = child.x;
              }
              if (child.type === "bar") {
                ret.measureWidths.push(child.x - lastXPosition);
                ret.total += child.x - lastXPosition;
                lastXPosition = child.x;
              }
            }
          }
          hasPrintedTempo = true;
          ret.height += abcLine.staffGroup.calcHeight() * spacing.STEP;
        }
      }
      return ret;
    };
    EngraverController.prototype.engraveTune = function(abctune, tuneNumber) {
      this.renderer.lineNumber = null;
      this.renderer.newTune(abctune);
      this.engraver = new AbstractEngraver(this.renderer, tuneNumber, { bagpipes: abctune.formatting.bagpipes, flatbeams: abctune.formatting.flatbeams });
      this.engraver.setStemHeight(this.renderer.spacing.stemHeight);
      this.engraver.measureLength = abctune.getMeterFraction().num / abctune.getMeterFraction().den;
      if (abctune.formatting.staffwidth) {
        this.width = abctune.formatting.staffwidth * 1.33;
      } else {
        this.width = this.renderer.isPrint ? this.staffwidthPrint : this.staffwidthScreen;
      }
      var scale = abctune.formatting.scale ? abctune.formatting.scale : this.scale;
      if (this.responsive === "resize")
        scale = void 0;
      if (scale === void 0) scale = this.renderer.isPrint ? 0.75 : 1;
      this.adjustNonScaledItems(scale);
      var i;
      var abcLine;
      var hasPrintedTempo = false;
      for (i = 0; i < abctune.lines.length; i++) {
        abcLine = abctune.lines[i];
        if (abcLine.staff) {
          abcLine.staffGroup = this.engraver.createABCLine(abcLine.staff, !hasPrintedTempo ? abctune.metaText.tempo : null);
          hasPrintedTempo = true;
        }
      }
      var maxWidth = this.width;
      for (i = 0; i < abctune.lines.length; i++) {
        abcLine = abctune.lines[i];
        if (abcLine.staff) {
          this.setXSpacing(abcLine.staffGroup, abctune.formatting, i === abctune.lines.length - 1, false);
          if (abcLine.staffGroup.w > maxWidth) maxWidth = abcLine.staffGroup.w;
        }
      }
      for (i = 0; i < abctune.lines.length; i++) {
        abcLine = abctune.lines[i];
        if (abcLine.staffGroup && abcLine.staffGroup.voices) {
          for (var j = 0; j < abcLine.staffGroup.voices.length; j++)
            abcLine.staffGroup.voices[j].layoutBeams();
          abcLine.staffGroup.setUpperAndLowerElements(this.renderer);
        }
      }
      for (i = 0; i < abctune.lines.length; i++) {
        abcLine = abctune.lines[i];
        if (abcLine.staffGroup) {
          abcLine.staffGroup.height = abcLine.staffGroup.calcHeight();
        }
      }
      this.renderer.topMargin(abctune);
      this.renderer.engraveTopText(this.width, abctune);
      this.renderer.addMusicPadding();
      this.staffgroups = [];
      this.lastStaffGroupIndex = -1;
      for (var line = 0; line < abctune.lines.length; line++) {
        this.renderer.lineNumber = line;
        abcLine = abctune.lines[line];
        if (abcLine.staff) {
          this.engraveStaffLine(abcLine.staffGroup);
        } else if (abcLine.subtitle && line !== 0) {
          this.renderer.outputSubtitle(this.width, abcLine.subtitle);
        } else if (abcLine.text !== void 0) {
          this.renderer.outputFreeText(abcLine.text, abcLine.vskip);
        } else if (abcLine.separator !== void 0) {
          this.renderer.outputSeparator(abcLine.separator);
        }
      }
      this.renderer.moveY(24);
      this.renderer.engraveExtraText(this.width, abctune);
      this.renderer.setPaperSize(maxWidth, scale, this.responsive);
    };
    function calcHorizontalSpacing(isLastLine, stretchLast, targetWidth, lineWidth, spacing2, spacingUnits, minSpace) {
      if (isLastLine && lineWidth / targetWidth < 0.66 && !stretchLast) return null;
      if (Math.abs(targetWidth - lineWidth) < 2) return null;
      var relSpace = spacingUnits * spacing2;
      var constSpace = lineWidth - relSpace;
      if (spacingUnits > 0) {
        spacing2 = (targetWidth - constSpace) / spacingUnits;
        if (spacing2 * minSpace > 50) {
          spacing2 = 50 / minSpace;
        }
        return spacing2;
      }
      return null;
    }
    EngraverController.prototype.setXSpacing = function(staffGroup, formatting, isLastLine, debug) {
      var newspace = this.space;
      for (var it = 0; it < 8; it++) {
        var ret = staffGroup.layout(newspace, this.renderer, debug);
        var stretchLast = formatting.stretchlast ? formatting.stretchlast : false;
        newspace = calcHorizontalSpacing(isLastLine, stretchLast, this.width + this.renderer.padding.left, staffGroup.w, newspace, ret.spacingUnits, ret.minSpace);
        if (debug)
          console.log("setXSpace", it, staffGroup.w, newspace, staffGroup.minspace);
        if (newspace === null) break;
      }
      centerWholeRests(staffGroup.voices);
    };
    EngraverController.prototype.engraveStaffLine = function(staffGroup) {
      if (this.lastStaffGroupIndex > -1)
        this.renderer.addStaffPadding(this.staffgroups[this.lastStaffGroupIndex], staffGroup);
      this.renderer.voiceNumber = null;
      staffGroup.draw(this.renderer);
      var height = staffGroup.height * spacing.STEP;
      this.staffgroups[this.staffgroups.length] = staffGroup;
      this.lastStaffGroupIndex = this.staffgroups.length - 1;
      this.renderer.y += height;
    };
    EngraverController.prototype.notifySelect = function(abselem, tuneNumber, classes) {
      this.clearSelection();
      if (abselem.highlight) {
        this.selected = [abselem];
        abselem.highlight();
      }
      var abcelem = abselem.abcelem || {};
      for (var i = 0; i < this.listeners.length; i++) {
        this.listeners[i](abcelem, tuneNumber, classes);
      }
    };
    EngraverController.prototype.clearSelection = function() {
      for (var i = 0; i < this.selected.length; i++) {
        this.selected[i].unhighlight();
      }
      this.selected = [];
    };
    EngraverController.prototype.addSelectListener = function(clickListener) {
      this.listeners[this.listeners.length] = clickListener;
    };
    EngraverController.prototype.rangeHighlight = function(start, end) {
      this.clearSelection();
      for (var line = 0; line < this.staffgroups.length; line++) {
        var voices = this.staffgroups[line].voices;
        for (var voice = 0; voice < voices.length; voice++) {
          var elems = voices[voice].children;
          for (var elem = 0; elem < elems.length; elem++) {
            var elStart = elems[elem].abcelem.startChar;
            var elEnd = elems[elem].abcelem.endChar;
            if (end > elStart && start < elEnd || end === start && end === elEnd) {
              this.selected[this.selected.length] = elems[elem];
              elems[elem].highlight();
            }
          }
        }
      }
    };
    function centerWholeRests(voices) {
      for (var i = 0; i < voices.length; i++) {
        var voice = voices[i];
        for (var j = 1; j < voice.children.length - 1; j++) {
          var absElem = voice.children[j];
          if (absElem.abcelem.rest && (absElem.abcelem.rest.type === "whole" || absElem.abcelem.rest.type === "multimeasure")) {
            var before = voice.children[j - 1];
            var after = voice.children[j + 1];
            var midpoint = (after.x - before.x) / 2 + before.x;
            absElem.x = midpoint - absElem.w / 2;
            for (var k = 0; k < absElem.children.length; k++)
              absElem.children[k].x = absElem.x;
          }
        }
      }
    }
    module.exports = EngraverController;
  }
});

// node_modules/abcjs/src/api/abc_tunebook_svg.js
var require_abc_tunebook_svg = __commonJS({
  "node_modules/abcjs/src/api/abc_tunebook_svg.js"(exports, module) {
    var tunebook = require_abc_tunebook();
    var Tune = require_abc_tune();
    var EngraverController = require_abc_engraver_controller();
    var Parse = require_abc_parse();
    var wrap = require_wrap_lines();
    var resizeDivs = {};
    function resizeOuter() {
      var width = window.innerWidth;
      for (var id in resizeDivs) {
        if (resizeDivs.hasOwnProperty(id)) {
          var outer = resizeDivs[id];
          var ofs = outer.offsetLeft;
          width -= ofs * 2;
          outer.style.width = width + "px";
        }
      }
    }
    window.addEventListener("resize", resizeOuter);
    window.addEventListener("orientationChange", resizeOuter);
    function renderOne(div, tune, params, tuneNumber) {
      if (params.viewportHorizontal) {
        div.innerHTML = '<div class="abcjs-inner"></div>';
        if (params.scrollHorizontal) {
          div.style.overflowX = "auto";
          div.style.overflowY = "hidden";
        } else
          div.style.overflow = "hidden";
        resizeDivs[div.id] = div;
        div = div.children[0];
      } else if (params.viewportVertical) {
        div.innerHTML = '<div class="abcjs-inner scroll-amount"></div>';
        div.style.overflowX = "hidden";
        div.style.overflowY = "auto";
        div = div.children[0];
      } else
        div.innerHTML = "";
      var engraver_controller = new EngraverController(div, params);
      engraver_controller.engraveABC(tune, tuneNumber);
      tune.engraver = engraver_controller;
      if (params.viewportVertical || params.viewportHorizontal) {
        var parent = div.parentNode;
        parent.style.width = div.style.width;
      }
    }
    function renderEachLineSeparately(div, tune, params, tuneNumber) {
      function initializeTuneLine(tune2) {
        var obj = new Tune();
        obj.formatting = tune2.formatting;
        obj.media = tune2.media;
        obj.version = tune2.version;
        obj.metaText = {};
        obj.lines = [];
        return obj;
      }
      var tunes = [];
      var tuneLine;
      for (var i = 0; i < tune.lines.length; i++) {
        var line = tune.lines[i];
        if (!tuneLine)
          tuneLine = initializeTuneLine(tune);
        if (i === 0) {
          tuneLine.metaText.tempo = tune.metaText.tempo;
          tuneLine.metaText.title = tune.metaText.title;
          tuneLine.metaText.header = tune.metaText.header;
          tuneLine.metaText.rhythm = tune.metaText.rhythm;
          tuneLine.metaText.origin = tune.metaText.origin;
          tuneLine.metaText.composer = tune.metaText.composer;
          tuneLine.metaText.author = tune.metaText.author;
          tuneLine.metaText.partOrder = tune.metaText.partOrder;
        }
        tuneLine.lines.push(line);
        if (line.staff) {
          tunes.push(tuneLine);
          tuneLine = void 0;
        }
      }
      if (tuneLine) {
        var lastLine = tunes[tunes.length - 1];
        for (var j = 0; j < tuneLine.lines.length; j++)
          lastLine.lines.push(tuneLine.lines[j]);
      }
      tuneLine = tunes[tunes.length - 1];
      tuneLine.metaText.unalignedWords = tune.metaText.unalignedWords;
      tuneLine.metaText.book = tune.metaText.book;
      tuneLine.metaText.source = tune.metaText.source;
      tuneLine.metaText.discography = tune.metaText.discography;
      tuneLine.metaText.notes = tune.metaText.notes;
      tuneLine.metaText.transcription = tune.metaText.transcription;
      tuneLine.metaText.history = tune.metaText.history;
      tuneLine.metaText["abc-copyright"] = tune.metaText["abc-copyright"];
      tuneLine.metaText["abc-creator"] = tune.metaText["abc-creator"];
      tuneLine.metaText["abc-edited-by"] = tune.metaText["abc-edited-by"];
      tuneLine.metaText.footer = tune.metaText.footer;
      var ep = {};
      for (var key in params) {
        if (params.hasOwnProperty(key)) {
          ep[key] = params[key];
        }
      }
      var origPaddingTop = ep.paddingtop;
      var origPaddingBottom = ep.paddingbottom;
      div.innerHTML = "";
      for (var k = 0; k < tunes.length; k++) {
        var lineEl = document.createElement("div");
        div.appendChild(lineEl);
        if (k === 0) {
          ep.paddingtop = origPaddingTop;
          ep.paddingbottom = -20;
        } else if (k === tunes.length - 1) {
          ep.paddingtop = 10;
          ep.paddingbottom = origPaddingBottom;
        } else {
          ep.paddingtop = 10;
          ep.paddingbottom = -20;
        }
        renderOne(lineEl, tunes[k], ep, tuneNumber);
        if (k === 0)
          tune.engraver = tunes[k].engraver;
        else {
          if (!tune.engraver.staffgroups)
            tune.engraver.staffgroups = tunes[k].engraver.staffgroups;
          else if (tunes[k].engraver.staffgroups.length > 0)
            tune.engraver.staffgroups.push(tunes[k].engraver.staffgroups[0]);
        }
      }
    }
    var renderAbc = function(output, abc, parserParams, engraverParams, renderParams) {
      var params = {};
      var key;
      if (parserParams) {
        for (key in parserParams) {
          if (parserParams.hasOwnProperty(key)) {
            params[key] = parserParams[key];
          }
        }
      }
      if (engraverParams) {
        for (key in engraverParams) {
          if (engraverParams.hasOwnProperty(key)) {
            if (key === "listener") {
              if (engraverParams[key].highlight)
                params.clickListener = engraverParams[key].highlight;
            } else
              params[key] = engraverParams[key];
          }
        }
      }
      if (renderParams) {
        for (key in renderParams) {
          if (renderParams.hasOwnProperty(key)) {
            params[key] = renderParams[key];
          }
        }
      }
      function callback(div, tune, tuneNumber, abcString) {
        var removeDiv = false;
        if (div === "*") {
          removeDiv = true;
          div = document.createElement("div");
          div.setAttribute("style", "display:none;");
          document.body.appendChild(div);
        }
        if (params.afterParsing)
          params.afterParsing(tune, tuneNumber, abcString);
        if (!removeDiv && params.wrap && params.staffwidth) {
          tune = doLineWrapping(div, tune, tuneNumber, abcString, params);
          return tune;
        } else if (removeDiv || !params.oneSvgPerLine || tune.lines.length < 2)
          renderOne(div, tune, params, tuneNumber);
        else
          renderEachLineSeparately(div, tune, params, tuneNumber);
        if (removeDiv)
          div.parentNode.removeChild(div);
        return null;
      }
      return tunebook.renderEngine(callback, output, abc, params);
    };
    function doLineWrapping(div, tune, tuneNumber, abcString, params) {
      var engraver_controller = new EngraverController(div, params);
      var widths = engraver_controller.getMeasureWidths(tune);
      var ret = wrap.calcLineWraps(tune, widths, abcString, params, Parse, engraver_controller);
      if (!params.oneSvgPerLine || ret.tune.lines.length < 2)
        renderOne(div, ret.tune, ret.revisedParams, tuneNumber);
      else
        renderEachLineSeparately(div, ret.tune, ret.revisedParams, tuneNumber);
      ret.tune.explanation = ret.explanation;
      return ret.tune;
    }
    module.exports = renderAbc;
  }
});

// node_modules/abcjs/src/synth/sounds-cache.js
var require_sounds_cache = __commonJS({
  "node_modules/abcjs/src/synth/sounds-cache.js"(exports, module) {
    var soundsCache = {};
    module.exports = soundsCache;
  }
});

// node_modules/abcjs/src/synth/load-note.js
var require_load_note = __commonJS({
  "node_modules/abcjs/src/synth/load-note.js"(exports, module) {
    var soundsCache = require_sounds_cache();
    var getNote = function(url, instrument, name, audioContext) {
      return new Promise(function(resolve, reject) {
        if (!soundsCache[instrument])
          soundsCache[instrument] = {};
        var instrumentCache = soundsCache[instrument];
        if (instrumentCache[name] === "error") {
          return reject(new Error("Unable to load sound font " + url + " " + instrument + " " + name));
        }
        if (instrumentCache[name]) {
          return resolve({ instrument, name });
        }
        instrumentCache[name] = "pending";
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url + instrument + "-mp3/" + name + ".mp3", true);
        xhr.responseType = "arraybuffer";
        var self = this;
        function onSuccess(audioBuffer) {
          instrumentCache[name] = audioBuffer;
          resolve({ instrument, name });
        }
        function onFailure(error) {
          if (self.debugCallback)
            self.debugCallback(error);
          console.log(error);
          reject(error);
        }
        xhr.onload = function(e) {
          if (this.status === 200) {
            audioContext.decodeAudioData(this.response, onSuccess, onFailure);
          } else {
            instrumentCache[name] = "error";
            var cantLoadMp3 = "Onload error loading sound: " + name + " " + url + " " + e.currentTarget.status + " " + e.currentTarget.statusText;
            if (self.debugCallback)
              self.debugCallback(cantLoadMp3);
            return reject(new Error(cantLoadMp3));
          }
        };
        xhr.addEventListener("error", function() {
          instrumentCache[name] = "error";
          var cantLoadMp3 = "Error in loading sound:  " + url;
          if (self.debugCallback)
            self.debugCallback(cantLoadMp3);
          return reject(new Error(cantLoadMp3));
        }, false);
        xhr.send();
      });
    };
    module.exports = getNote;
  }
});

// node_modules/abcjs/src/synth/instrument-index-to-name.js
var require_instrument_index_to_name = __commonJS({
  "node_modules/abcjs/src/synth/instrument-index-to-name.js"(exports, module) {
    var instrumentIndexToName = [
      "acoustic_grand_piano",
      "bright_acoustic_piano",
      "electric_grand_piano",
      "honkytonk_piano",
      "electric_piano_1",
      "electric_piano_2",
      "harpsichord",
      "clavinet",
      "celesta",
      "glockenspiel",
      "music_box",
      "vibraphone",
      "marimba",
      "xylophone",
      "tubular_bells",
      "dulcimer",
      "drawbar_organ",
      "percussive_organ",
      "rock_organ",
      "church_organ",
      "reed_organ",
      "accordion",
      "harmonica",
      "tango_accordion",
      "acoustic_guitar_nylon",
      "acoustic_guitar_steel",
      "electric_guitar_jazz",
      "electric_guitar_clean",
      "electric_guitar_muted",
      "overdriven_guitar",
      "distortion_guitar",
      "guitar_harmonics",
      "acoustic_bass",
      "electric_bass_finger",
      "electric_bass_pick",
      "fretless_bass",
      "slap_bass_1",
      "slap_bass_2",
      "synth_bass_1",
      "synth_bass_2",
      "violin",
      "viola",
      "cello",
      "contrabass",
      "tremolo_strings",
      "pizzicato_strings",
      "orchestral_harp",
      "timpani",
      "string_ensemble_1",
      "string_ensemble_2",
      "synth_strings_1",
      "synth_strings_2",
      "choir_aahs",
      "voice_oohs",
      "synth_choir",
      "orchestra_hit",
      "trumpet",
      "trombone",
      "tuba",
      "muted_trumpet",
      "french_horn",
      "brass_section",
      "synth_brass_1",
      "synth_brass_2",
      "soprano_sax",
      "alto_sax",
      "tenor_sax",
      "baritone_sax",
      "oboe",
      "english_horn",
      "bassoon",
      "clarinet",
      "piccolo",
      "flute",
      "recorder",
      "pan_flute",
      "blown_bottle",
      "shakuhachi",
      "whistle",
      "ocarina",
      "lead_1_square",
      "lead_2_sawtooth",
      "lead_3_calliope",
      "lead_4_chiff",
      "lead_5_charang",
      "lead_6_voice",
      "lead_7_fifths",
      "lead_8_bass__lead",
      "pad_1_new_age",
      "pad_2_warm",
      "pad_3_polysynth",
      "pad_4_choir",
      "pad_5_bowed",
      "pad_6_metallic",
      "pad_7_halo",
      "pad_8_sweep",
      "fx_1_rain",
      "fx_2_soundtrack",
      "fx_3_crystal",
      "fx_4_atmosphere",
      "fx_5_brightness",
      "fx_6_goblins",
      "fx_7_echoes",
      "fx_8_scifi",
      "sitar",
      "banjo",
      "shamisen",
      "koto",
      "kalimba",
      "bagpipe",
      "fiddle",
      "shanai",
      "tinkle_bell",
      "agogo",
      "steel_drums",
      "woodblock",
      "taiko_drum",
      "melodic_tom",
      "synth_drum",
      "reverse_cymbal",
      "guitar_fret_noise",
      "breath_noise",
      "seashore",
      "bird_tweet",
      "telephone_ring",
      "helicopter",
      "applause",
      "gunshot",
      "percussion"
    ];
    module.exports = instrumentIndexToName;
  }
});

// node_modules/abcjs/src/synth/create-note-map.js
var require_create_note_map = __commonJS({
  "node_modules/abcjs/src/synth/create-note-map.js"(exports, module) {
    var instrumentIndexToName = require_instrument_index_to_name();
    var createNoteMap = function(sequence) {
      var map = [];
      for (var i = 0; i < sequence.tracks.length; i++)
        map.push([]);
      var nextNote = {};
      var currentInstrument = instrumentIndexToName[0];
      sequence.tracks.forEach(function(track, i2) {
        var currentTime = 0;
        track.forEach(function(ev) {
          switch (ev.cmd) {
            case "start":
              nextNote[ev.pitch] = { time: currentTime, instrument: currentInstrument, volume: ev.volume };
              break;
            case "move":
              currentTime += ev.duration;
              break;
            case "stop":
              map[i2].push({ pitch: ev.pitch, instrument: nextNote[ev.pitch].instrument, start: nextNote[ev.pitch].time, end: currentTime, volume: nextNote[ev.pitch].volume });
              delete nextNote[ev.pitch];
              break;
            case "program":
              currentInstrument = instrumentIndexToName[ev.instrument];
              break;
            default:
              console.log("Unhanded midi event", ev);
          }
        });
      });
      return map;
    };
    module.exports = createNoteMap;
  }
});

// node_modules/abcjs/src/synth/register-audio-context.js
var require_register_audio_context = __commonJS({
  "node_modules/abcjs/src/synth/register-audio-context.js"(exports, module) {
    function registerAudioContext(ac) {
      if (!window.abcjsAudioContext) {
        if (!ac) {
          ac = window.AudioContext || window.webkitAudioContext || navigator.mozAudioContext || navigator.msAudioContext;
          ac = new ac();
        }
        window.abcjsAudioContext = ac;
      }
      return window.abcjsAudioContext.state !== "suspended";
    }
    module.exports = registerAudioContext;
  }
});

// node_modules/abcjs/src/synth/active-audio-context.js
var require_active_audio_context = __commonJS({
  "node_modules/abcjs/src/synth/active-audio-context.js"(exports, module) {
    function activeAudioContext() {
      return window.abcjsAudioContext;
    }
    module.exports = activeAudioContext;
  }
});

// node_modules/abcjs/src/synth/supports-audio.js
var require_supports_audio = __commonJS({
  "node_modules/abcjs/src/synth/supports-audio.js"(exports, module) {
    var activeAudioContext = require_active_audio_context();
    function supportsAudio() {
      var aac = activeAudioContext();
      if (aac)
        return aac.resume !== void 0;
      if (!window.Promise)
        return false;
      return window.AudioContext || window.webkitAudioContext || navigator.mozAudioContext || navigator.msAudioContext;
    }
    module.exports = supportsAudio;
  }
});

// node_modules/abcjs/src/synth/pitch-to-note-name.js
var require_pitch_to_note_name = __commonJS({
  "node_modules/abcjs/src/synth/pitch-to-note-name.js"(exports, module) {
    var pitchToNoteName = {
      21: "A0",
      22: "Bb0",
      23: "B0",
      24: "C1",
      25: "Db1",
      26: "D1",
      27: "Eb1",
      28: "E1",
      29: "F1",
      30: "Gb1",
      31: "G1",
      32: "Ab1",
      33: "A1",
      34: "Bb1",
      35: "B1",
      36: "C2",
      37: "Db2",
      38: "D2",
      39: "Eb2",
      40: "E2",
      41: "F2",
      42: "Gb2",
      43: "G2",
      44: "Ab2",
      45: "A2",
      46: "Bb2",
      47: "B2",
      48: "C3",
      49: "Db3",
      50: "D3",
      51: "Eb3",
      52: "E3",
      53: "F3",
      54: "Gb3",
      55: "G3",
      56: "Ab3",
      57: "A3",
      58: "Bb3",
      59: "B3",
      60: "C4",
      61: "Db4",
      62: "D4",
      63: "Eb4",
      64: "E4",
      65: "F4",
      66: "Gb4",
      67: "G4",
      68: "Ab4",
      69: "A4",
      70: "Bb4",
      71: "B4",
      72: "C5",
      73: "Db5",
      74: "D5",
      75: "Eb5",
      76: "E5",
      77: "F5",
      78: "Gb5",
      79: "G5",
      80: "Ab5",
      81: "A5",
      82: "Bb5",
      83: "B5",
      84: "C6",
      85: "Db6",
      86: "D6",
      87: "Eb6",
      88: "E6",
      89: "F6",
      90: "Gb6",
      91: "G6",
      92: "Ab6",
      93: "A6",
      94: "Bb6",
      95: "B6",
      96: "C7",
      97: "Db7",
      98: "D7",
      99: "Eb7",
      100: "E7",
      101: "F7",
      102: "Gb7",
      103: "G7",
      104: "Ab7",
      105: "A7",
      106: "Bb7",
      107: "B7",
      108: "C8",
      109: "Db8",
      110: "D8",
      111: "Eb8",
      112: "E8",
      113: "F8",
      114: "Gb8",
      115: "G8",
      116: "Ab8",
      117: "A8",
      118: "Bb8",
      119: "B8",
      120: "C9",
      121: "Db9"
    };
    module.exports = pitchToNoteName;
  }
});

// node_modules/abcjs/src/synth/download-buffer.js
var require_download_buffer = __commonJS({
  "node_modules/abcjs/src/synth/download-buffer.js"(exports, module) {
    var downloadBuffer = function(buffer) {
      return window.URL.createObjectURL(bufferToWave(buffer.audioBuffers));
    };
    function bufferToWave(audioBuffers) {
      var numOfChan = audioBuffers.length;
      var length = audioBuffers[0].length * numOfChan * 2 + 44;
      var buffer = new ArrayBuffer(length);
      var view = new DataView(buffer);
      var channels = [];
      var i;
      var sample;
      var offset = 0;
      var pos = 0;
      setUint32(1179011410);
      setUint32(length - 8);
      setUint32(1163280727);
      setUint32(544501094);
      setUint32(16);
      setUint16(1);
      setUint16(numOfChan);
      setUint32(audioBuffers[0].sampleRate);
      setUint32(audioBuffers[0].sampleRate * 2 * numOfChan);
      setUint16(numOfChan * 2);
      setUint16(16);
      setUint32(1635017060);
      setUint32(length - pos - 4);
      for (i = 0; i < audioBuffers.length; i++)
        channels.push(audioBuffers[i].getChannelData(0));
      while (pos < length) {
        for (i = 0; i < channels.length; i++) {
          sample = Math.max(-1, Math.min(1, channels[i][offset]));
          sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
          view.setInt16(pos, sample, true);
          pos += 2;
        }
        offset++;
      }
      return new Blob([buffer], { type: "audio/wav" });
      function setUint16(data) {
        view.setUint16(pos, data, true);
        pos += 2;
      }
      function setUint32(data) {
        view.setUint32(pos, data, true);
        pos += 4;
      }
    }
    module.exports = downloadBuffer;
  }
});

// node_modules/abcjs/src/midi/abc_midi_sequencer.js
var require_abc_midi_sequencer = __commonJS({
  "node_modules/abcjs/src/midi/abc_midi_sequencer.js"(exports, module) {
    var sequence;
    (function() {
      "use strict";
      var measureLength;
      var PERCUSSION_PROGRAM = 128;
      sequence = function(abctune, options) {
        options = options || {};
        var qpm = void 0;
        var program = options.program || 0;
        var transpose = options.midiTranspose || 0;
        var channel = options.channel || 0;
        var drumPattern = options.drum || "";
        var drumBars = options.drumBars || 1;
        var drumIntro = options.drumIntro || 0;
        var drumOn = drumPattern !== "";
        program = parseInt(program, 10);
        transpose = parseInt(transpose, 10);
        channel = parseInt(channel, 10);
        if (channel === 10)
          program = PERCUSSION_PROGRAM;
        drumPattern = drumPattern.split(" ");
        drumBars = parseInt(drumBars, 10);
        drumIntro = parseInt(drumIntro, 10);
        var bagpipes = abctune.formatting.bagpipes;
        if (bagpipes)
          program = 71;
        var startingMidi = [];
        if (abctune.formatting.midi) {
          var globals = abctune.formatting.midi;
          if (globals.program && globals.program.length > 0) {
            program = globals.program[0];
            if (globals.program.length > 1) {
              program = globals.program[1];
              channel = globals.program[0];
            }
          }
          if (globals.transpose)
            transpose = globals.transpose[0];
          if (globals.channel)
            channel = globals.channel[0];
          if (globals.drum)
            drumPattern = globals.drum;
          if (globals.drumbars)
            drumBars = globals.drumbars[0];
          if (globals.drumon)
            drumOn = true;
          if (channel === 10)
            program = PERCUSSION_PROGRAM;
          if (globals.beat)
            startingMidi.push({ el_type: "beat", beats: globals.beat });
          if (globals.nobeataccents)
            startingMidi.push({ el_type: "beataccents", value: false });
        }
        if (options.qpm)
          qpm = parseInt(options.qpm, 10);
        else if (abctune.metaText.tempo)
          qpm = interpretTempo(abctune.metaText.tempo);
        else if (options.defaultQpm)
          qpm = options.defaultQpm;
        else
          qpm = 180;
        var startVoice = [];
        if (bagpipes)
          startVoice.push({ el_type: "bagpipes" });
        startVoice.push({ el_type: "instrument", program });
        if (channel)
          startVoice.push({ el_type: "channel", channel });
        if (transpose)
          startVoice.push({ el_type: "transpose", transpose });
        startVoice.push({ el_type: "tempo", qpm });
        for (var ss = 0; ss < startingMidi.length; ss++)
          startVoice.push(startingMidi[ss]);
        var voices = [];
        var startRepeatPlaceholder = [];
        var skipEndingPlaceholder = [];
        var startingDrumSet = false;
        for (var i = 0; i < abctune.lines.length; i++) {
          var line = abctune.lines[i];
          if (line.staff) {
            var staves = line.staff;
            var voiceNumber = 0;
            for (var j = 0; j < staves.length; j++) {
              var staff = staves[j];
              for (var k = 0; k < staff.voices.length; k++) {
                var voice = staff.voices[k];
                if (!voices[voiceNumber]) {
                  voices[voiceNumber] = [].concat(JSON.parse(JSON.stringify(startVoice)));
                }
                if (staff.clef && staff.clef.type === "perc") {
                  for (var cl = 0; cl < voices[voiceNumber].length; cl++) {
                    if (voices[voiceNumber][cl].el_type === "instrument")
                      voices[voiceNumber][cl].program = PERCUSSION_PROGRAM;
                  }
                } else if (staff.key) {
                  if (staff.key.root === "HP")
                    voices[voiceNumber].push({ el_type: "key", accidentals: [{ acc: "natural", note: "g" }, { acc: "sharp", note: "f" }, { acc: "sharp", note: "c" }] });
                  else
                    voices[voiceNumber].push({ el_type: "key", accidentals: staff.key.accidentals });
                }
                if (staff.meter) {
                  voices[voiceNumber].push(interpretMeter(staff.meter));
                }
                if (!startingDrumSet && drumOn) {
                  voices[voiceNumber].push({ el_type: "drum", params: { pattern: drumPattern, bars: drumBars, on: drumOn, intro: drumIntro } });
                  startingDrumSet = true;
                }
                if (staff.clef && staff.clef.transpose) {
                  staff.clef.el_type = "clef";
                  voices[voiceNumber].push({ el_type: "transpose", transpose: staff.clef.transpose });
                }
                if (abctune.formatting.midi && abctune.formatting.midi.drumoff) {
                  voices[voiceNumber].push({ el_type: "bar" });
                  voices[voiceNumber].push({ el_type: "drum", params: { pattern: "", on: false } });
                }
                var noteEventsInBar = 0;
                for (var v = 0; v < voice.length; v++) {
                  var elem = voice[v];
                  switch (elem.el_type) {
                    case "note":
                      if (!elem.rest || elem.rest.type !== "spacer") {
                        if (elem.decoration) {
                          if (elem.decoration.indexOf("ppp") >= 0)
                            voices[voiceNumber].push({ el_type: "beat", beats: [30, 20, 10, 1] });
                          else if (elem.decoration.indexOf("pp") >= 0)
                            voices[voiceNumber].push({ el_type: "beat", beats: [45, 35, 20, 1] });
                          else if (elem.decoration.indexOf("p") >= 0)
                            voices[voiceNumber].push({ el_type: "beat", beats: [60, 50, 35, 1] });
                          else if (elem.decoration.indexOf("mp") >= 0)
                            voices[voiceNumber].push({ el_type: "beat", beats: [75, 65, 50, 1] });
                          else if (elem.decoration.indexOf("mf") >= 0)
                            voices[voiceNumber].push({ el_type: "beat", beats: [90, 80, 65, 1] });
                          else if (elem.decoration.indexOf("f") >= 0)
                            voices[voiceNumber].push({ el_type: "beat", beats: [105, 95, 80, 1] });
                          else if (elem.decoration.indexOf("ff") >= 0)
                            voices[voiceNumber].push({ el_type: "beat", beats: [120, 110, 95, 1] });
                          else if (elem.decoration.indexOf("fff") >= 0)
                            voices[voiceNumber].push({ el_type: "beat", beats: [127, 125, 110, 1] });
                        }
                        voices[voiceNumber].push(elem);
                        noteEventsInBar++;
                      }
                      break;
                    case "key":
                      if (elem.root === "HP")
                        voices[voiceNumber].push({ el_type: "key", accidentals: [{ acc: "natural", note: "g" }, { acc: "sharp", note: "f" }, { acc: "sharp", note: "c" }] });
                      else
                        voices[voiceNumber].push({ el_type: "key", accidentals: elem.accidentals });
                      break;
                    case "meter":
                      voices[voiceNumber].push(interpretMeter(elem));
                      break;
                    case "clef":
                      if (elem.transpose)
                        voices[voiceNumber].push({ el_type: "transpose", transpose: elem.transpose });
                      break;
                    case "tempo":
                      qpm = interpretTempo(elem);
                      voices[voiceNumber].push({ el_type: "tempo", qpm });
                      break;
                    case "bar":
                      if (noteEventsInBar > 0)
                        voices[voiceNumber].push({ el_type: "bar" });
                      noteEventsInBar = 0;
                      var endRepeat = elem.type === "bar_right_repeat" || elem.type === "bar_dbl_repeat";
                      var startEnding = elem.startEnding === "1";
                      var startRepeat = elem.type === "bar_left_repeat" || elem.type === "bar_dbl_repeat" || elem.type === "bar_right_repeat";
                      if (endRepeat) {
                        var s = startRepeatPlaceholder[voiceNumber];
                        if (!s) s = 0;
                        var e = skipEndingPlaceholder[voiceNumber];
                        if (!e) e = voices[voiceNumber].length;
                        voices[voiceNumber] = voices[voiceNumber].concat(voices[voiceNumber].slice(s, e));
                        skipEndingPlaceholder[voiceNumber] = void 0;
                        startRepeatPlaceholder[voiceNumber] = void 0;
                      }
                      if (startEnding)
                        skipEndingPlaceholder[voiceNumber] = voices[voiceNumber].length;
                      if (startRepeat)
                        startRepeatPlaceholder[voiceNumber] = voices[voiceNumber].length;
                      break;
                    case "style":
                      break;
                    case "part":
                      break;
                    case "stem":
                    case "scale":
                      break;
                    case "midi":
                      var drumChange = false;
                      switch (elem.cmd) {
                        case "drumon":
                          drumOn = true;
                          drumChange = true;
                          break;
                        case "drumoff":
                          drumOn = false;
                          drumChange = true;
                          break;
                        case "drum":
                          drumPattern = elem.params;
                          drumChange = true;
                          break;
                        case "drumbars":
                          drumBars = elem.params[0];
                          drumChange = true;
                          break;
                        case "drummap":
                          break;
                        case "program":
                          voices[voiceNumber].push({ el_type: "instrument", program: elem.params[0] });
                          break;
                        case "transpose":
                          voices[voiceNumber].push({ el_type: "transpose", transpose: elem.params[0] });
                          break;
                        case "gchordoff":
                          voices[voiceNumber].push({ el_type: "gchord", tacet: true });
                          break;
                        case "gchordon":
                          voices[voiceNumber].push({ el_type: "gchord", tacet: false });
                          break;
                        case "beat":
                          voices[voiceNumber].push({ el_type: "beat", beats: elem.params });
                          break;
                        case "nobeataccents":
                          voices[voiceNumber].push({ el_type: "beataccents", value: false });
                          break;
                        case "beataccents":
                          voices[voiceNumber].push({ el_type: "beataccents", value: true });
                          break;
                        case "vol":
                          voices[voiceNumber].push({ el_type: "vol", volume: elem.params[0] });
                          break;
                        case "volinc":
                          voices[voiceNumber].push({ el_type: "volinc", volume: elem.params[0] });
                          break;
                        default:
                          console.log("MIDI seq: midi cmd not handled: ", elem.cmd, elem);
                      }
                      if (drumChange) {
                        voices[0].push({ el_type: "drum", params: { pattern: drumPattern, bars: drumBars, intro: drumIntro, on: drumOn } });
                        startingDrumSet = true;
                      }
                      break;
                    default:
                      console.log("MIDI: element type " + elem.el_type + " not handled.");
                  }
                }
                voiceNumber++;
              }
            }
          }
        }
        if (drumIntro) {
          var pickups = abctune.getPickupLength();
          for (var vv = 0; vv < voices.length; vv++) {
            var insertPoint = 0;
            while (voices[vv][insertPoint].el_type !== "note" && voices[vv].length > insertPoint)
              insertPoint++;
            if (voices[vv].length > insertPoint) {
              for (var w = 0; w < drumIntro; w++) {
                if (pickups === 0 || w < drumIntro - 1)
                  voices[vv].splice(
                    insertPoint,
                    0,
                    { el_type: "note", rest: { type: "rest" }, duration: measureLength },
                    { el_type: "bar" }
                  );
                else {
                  voices[vv].splice(insertPoint, 0, { el_type: "note", rest: { type: "rest" }, duration: measureLength - pickups });
                }
              }
            }
          }
        }
        return voices;
      };
      function interpretTempo(element) {
        var duration = 1 / 4;
        if (element.duration) {
          duration = element.duration[0];
        }
        var bpm = 60;
        if (element.bpm) {
          bpm = element.bpm;
        }
        return duration * bpm / 0.25;
      }
      function interpretMeter(element) {
        var meter;
        switch (element.type) {
          case "common_time":
            meter = { el_type: "meter", num: 4, den: 4 };
            break;
          case "cut_time":
            meter = { el_type: "meter", num: 2, den: 2 };
            break;
          case "specified":
            meter = { el_type: "meter", num: element.value[0].num, den: element.value[0].den };
            break;
          default:
            meter = { el_type: "meter" };
        }
        measureLength = meter.num / meter.den;
        return meter;
      }
    })();
    module.exports = sequence;
  }
});

// node_modules/abcjs/src/midi/abc_midi_flattener.js
var require_abc_midi_flattener = __commonJS({
  "node_modules/abcjs/src/midi/abc_midi_flattener.js"(exports, module) {
    var flatten;
    (function() {
      "use strict";
      var barAccidentals;
      var accidentals;
      var transpose;
      var bagpipes;
      var multiplier;
      var tracks;
      var startingTempo;
      var startingMeter;
      var tempoChangeFactor = 1;
      var instrument;
      var currentInstrument;
      var currentTrack;
      var pitchesTied;
      var lastNoteDurationPosition;
      var currentTrackCounter;
      var meter = { num: 4, den: 4 };
      var chordTrack;
      var chordTrackFinished;
      var chordChannel;
      var chordInstrument = 0;
      var drumInstrument = 128;
      var currentChords;
      var lastChord;
      var barBeat;
      var gChordTacet = false;
      var doBeatAccents = true;
      var stressBeat1 = 105;
      var stressBeatDown = 95;
      var stressBeatUp = 85;
      var beatFraction = 0.25;
      var nextVolume;
      var nextVolumeDelta;
      var drumTrack;
      var drumTrackFinished;
      var drumDefinition = {};
      var normalBreakBetweenNotes = 1 / 128;
      flatten = function(voices, options) {
        if (!options) options = {};
        barAccidentals = [];
        accidentals = [0, 0, 0, 0, 0, 0, 0];
        bagpipes = false;
        multiplier = 1;
        tracks = [];
        startingTempo = void 0;
        startingMeter = void 0;
        tempoChangeFactor = 1;
        instrument = void 0;
        currentInstrument = void 0;
        currentTrack = void 0;
        currentTrackCounter = void 0;
        pitchesTied = {};
        meter = { num: 4, den: 4 };
        chordTrack = [];
        chordChannel = voices.length;
        chordTrackFinished = false;
        currentChords = [];
        lastChord = void 0;
        barBeat = 0;
        gChordTacet = options.chordsOff ? true : false;
        doBeatAccents = true;
        stressBeat1 = 105;
        stressBeatDown = 95;
        stressBeatUp = 85;
        beatFraction = 0.25;
        nextVolume = void 0;
        nextVolumeDelta = void 0;
        drumTrack = [];
        drumTrackFinished = false;
        drumDefinition = {};
        zeroOutMilliseconds(voices);
        for (var i = 0; i < voices.length; i++) {
          transpose = 0;
          lastNoteDurationPosition = -1;
          var voice = voices[i];
          currentTrack = [{ cmd: "program", channel: i, instrument }];
          currentTrackCounter = 0;
          pitchesTied = {};
          for (var j = 0; j < voice.length; j++) {
            var element = voice[j];
            switch (element.el_type) {
              case "note":
                writeNote(element, options.voicesOff);
                break;
              case "key":
                accidentals = setKeySignature(element);
                break;
              case "meter":
                if (!startingMeter)
                  startingMeter = element;
                meter = element;
                beatFraction = getBeatFraction(meter);
                break;
              case "tempo":
                if (!startingTempo)
                  startingTempo = element.qpm;
                else
                  tempoChangeFactor = element.qpm ? startingTempo / element.qpm : 1;
                break;
              case "transpose":
                transpose = element.transpose;
                break;
              case "bar":
                if (chordTrack.length > 0 && i === 0) {
                  resolveChords();
                  currentChords = [];
                }
                barBeat = 0;
                barAccidentals = [];
                if (i === 0)
                  writeDrum(voices.length + 1);
                break;
              case "bagpipes":
                bagpipes = true;
                break;
              case "instrument":
                if (instrument === void 0)
                  instrument = element.program;
                currentInstrument = element.program;
                if (currentTrack.length > 0 && currentTrack[currentTrack.length - 1].cmd === "program")
                  currentTrack[currentTrack.length - 1].instrument = element.program;
                else {
                  var ii;
                  for (ii = currentTrack.length - 1; ii >= 0 && currentTrack[ii].cmd !== "program"; ii--)
                    ;
                  if (ii < 0 || currentTrack[ii].instrument !== element.program)
                    currentTrack.push({ cmd: "program", channel: i, instrument: element.program });
                }
                break;
              case "channel":
                break;
              case "drum":
                drumDefinition = normalizeDrumDefinition(element.params);
                break;
              case "gchord":
                if (!options.chordsOff)
                  gChordTacet = element.tacet;
                break;
              case "beat":
                stressBeat1 = element.beats[0];
                stressBeatDown = element.beats[1];
                stressBeatUp = element.beats[2];
                break;
              case "vol":
                nextVolume = element.volume;
                break;
              case "volinc":
                nextVolumeDelta = element.volume;
                break;
              case "beataccents":
                doBeatAccents = element.value;
                break;
              default:
                console.log("MIDI creation. Unknown el_type: " + element.el_type + "\n");
                break;
            }
          }
          if (currentTrack[0].instrument === void 0)
            currentTrack[0].instrument = instrument ? instrument : 0;
          tracks.push(currentTrack);
          if (chordTrack.length > 0)
            chordTrackFinished = true;
          if (drumTrack.length > 0)
            drumTrackFinished = true;
        }
        if (chordTrack.length > 0)
          tracks.push(chordTrack);
        if (drumTrack.length > 0)
          tracks.push(drumTrack);
        return { tempo: startingTempo, instrument, tracks, totalDuration: totalDuration(tracks) };
      };
      function zeroOutMilliseconds(voices) {
        for (var i = 0; i < voices.length; i++) {
          var voice = voices[i];
          for (var j = 0; j < voice.length; j++) {
            var element = voice[j];
            delete element.currentTrackMilliseconds;
          }
        }
      }
      function totalDuration(tracks2) {
        var total = 0;
        for (var i = 0; i < tracks2.length; i++) {
          var track = tracks2[i];
          var trackTotal = 0;
          for (var j = 0; j < track.length; j++) {
            var event = track[j];
            if (event.duration)
              trackTotal += event.duration;
          }
          total = Math.max(total, trackTotal);
        }
        return total;
      }
      function getBeatFraction(meter2) {
        switch (meter2.den) {
          case 2:
            return 0.5;
          case 4:
            return 0.25;
          case 8:
            return 0.375;
          case 16:
            return 0.125;
        }
        return 0.25;
      }
      var breakSynonyms = ["break", "(break)", "no chord", "n.c.", "tacet"];
      function findChord(elem) {
        if (gChordTacet)
          return "break";
        if (chordTrackFinished || !elem.chord || elem.chord.length === 0)
          return null;
        for (var i = 0; i < elem.chord.length; i++) {
          var ch = elem.chord[i];
          if (ch.position === "default")
            return ch.name;
          if (breakSynonyms.indexOf(ch.name.toLowerCase()) >= 0)
            return "break";
        }
        return null;
      }
      function timeFromStart() {
        var distance = 0;
        for (var ct = 0; ct < currentTrack.length; ct++) {
          if (currentTrack[ct].cmd === "move")
            distance += currentTrack[ct].duration;
        }
        return distance;
      }
      function writeNote(elem, voiceOff) {
        var volume;
        if (nextVolume) {
          volume = nextVolume;
          nextVolume = void 0;
        } else if (!doBeatAccents) {
          volume = stressBeatDown;
        } else {
          if (barBeat === 0)
            volume = stressBeat1;
          else if (barBeat % beatFraction < 1e-3)
            volume = stressBeatDown;
          else
            volume = stressBeatUp;
        }
        if (nextVolumeDelta) {
          volume += nextVolumeDelta;
          nextVolumeDelta = void 0;
        }
        if (volume < 0)
          volume = 0;
        if (volume > 127)
          volume = 127;
        var velocity = voiceOff ? 0 : volume;
        var chord = findChord(elem);
        if (chord) {
          var c = interpretChord(chord);
          if (c) {
            if (chordTrack.length === 0) {
              chordTrack.push({ cmd: "program", channel: chordChannel, instrument: chordInstrument });
              var distance = timeFromStart();
              if (distance > 0)
                chordTrack.push({ cmd: "move", duration: distance * tempoChangeFactor });
            }
            lastChord = c;
            currentChords.push({ chord: lastChord, beat: barBeat });
          }
        }
        if (elem.startTriplet) {
          multiplier = elem.tripletMultiplier;
        }
        var duration = (elem.durationClass ? elem.durationClass : elem.duration) * multiplier;
        barBeat += duration;
        var graces;
        if (elem.gracenotes) {
          var stealFromCurrent = bagpipes || lastNoteDurationPosition < 0 || currentTrack.length === 0;
          var stealFromDuration = stealFromCurrent ? duration : currentTrack[lastNoteDurationPosition].duration;
          graces = processGraceNotes(elem.gracenotes, stealFromDuration);
          if (!bagpipes) {
            duration = writeGraceNotes(graces, stealFromCurrent, duration, null, velocity);
          }
        }
        if (!elem.currentTrackMilliseconds)
          elem.currentTrackMilliseconds = [];
        elem.currentTrackMilliseconds.push(currentTrackCounter / beatFraction / startingTempo * 60 * 1e3);
        if (elem.pitches) {
          if (graces && bagpipes) {
            duration = writeGraceNotes(graces, true, duration, null, velocity);
          }
          var pitches = [];
          elem.midiPitches = [];
          for (var i = 0; i < elem.pitches.length; i++) {
            var note = elem.pitches[i];
            var actualPitch = adjustPitch(note);
            pitches.push({ pitch: actualPitch, startTie: note.startTie });
            elem.midiPitches.push({ pitch: actualPitch + 60, durationInMeasures: duration * tempoChangeFactor, volume, instrument: currentInstrument });
            if (!pitchesTied["" + actualPitch])
              currentTrack.push({ cmd: "start", pitch: actualPitch, volume: velocity });
            else {
              for (var last = currentTrack.length - 1; last >= 0; last--) {
                if (currentTrack[last].cmd === "start" && currentTrack[last].pitch === actualPitch && currentTrack[last].elem) {
                  var pitchArray = currentTrack[last].elem.midiPitches;
                  for (var last2 = 0; last2 < pitchArray.length; last2++) {
                    if (pitchArray[last2].pitch - 60 === actualPitch) {
                      pitchArray[last2].durationInMeasures += duration * tempoChangeFactor;
                    }
                  }
                  break;
                }
              }
            }
            if (note.startTie) {
              pitchesTied["" + actualPitch] = true;
              currentTrack[currentTrack.length - 1].elem = elem;
            } else if (note.endTie)
              pitchesTied["" + actualPitch] = false;
          }
          if (elem.gracenotes) {
            for (var j = 0; j < elem.gracenotes.length; j++) {
              elem.midiGraceNotePitches = [];
              var grace = elem.gracenotes[j];
              elem.midiGraceNotePitches.push({ pitch: adjustPitch(grace) + 60, durationInMeasures: 0, volume, instrument: currentInstrument });
            }
          }
          var thisBreakBetweenNotes = normalBreakBetweenNotes;
          var soundDuration = duration - normalBreakBetweenNotes;
          if (soundDuration < 0) {
            soundDuration = 0;
            thisBreakBetweenNotes = 0;
          }
          currentTrack.push({ cmd: "move", duration: soundDuration * tempoChangeFactor });
          lastNoteDurationPosition = currentTrack.length - 1;
          currentTrackCounter += soundDuration * tempoChangeFactor;
          for (var ii = 0; ii < pitches.length; ii++) {
            if (!pitchesTied["" + pitches[ii].pitch])
              currentTrack.push({ cmd: "stop", pitch: pitches[ii].pitch });
          }
          currentTrack.push({ cmd: "move", duration: thisBreakBetweenNotes * tempoChangeFactor });
          currentTrackCounter += thisBreakBetweenNotes * tempoChangeFactor;
        } else if (elem.rest) {
          currentTrack.push({ cmd: "move", duration: duration * tempoChangeFactor });
          currentTrackCounter += duration * tempoChangeFactor;
        }
        if (elem.endTriplet) {
          multiplier = 1;
        }
      }
      var scale = [0, 2, 4, 5, 7, 9, 11];
      function adjustPitch(note) {
        if (note.midipitch)
          return note.midipitch - 60;
        var pitch = note.pitch;
        if (note.accidental) {
          switch (note.accidental) {
            // change that pitch (not other octaves) for the rest of the bar
            case "sharp":
              barAccidentals[pitch] = 1;
              break;
            case "flat":
              barAccidentals[pitch] = -1;
              break;
            case "natural":
              barAccidentals[pitch] = 0;
              break;
            case "dblsharp":
              barAccidentals[pitch] = 2;
              break;
            case "dblflat":
              barAccidentals[pitch] = -2;
              break;
          }
        }
        var actualPitch = extractOctave(pitch) * 12 + scale[extractNote(pitch)];
        if (barAccidentals[pitch] !== void 0) {
          actualPitch += barAccidentals[pitch];
        } else {
          actualPitch += accidentals[extractNote(pitch)];
        }
        actualPitch += transpose;
        return actualPitch;
      }
      function setKeySignature(elem) {
        var accidentals2 = [0, 0, 0, 0, 0, 0, 0];
        if (!elem.accidentals) return accidentals2;
        for (var i = 0; i < elem.accidentals.length; i++) {
          var acc = elem.accidentals[i];
          var d = acc.acc === "sharp" ? 1 : acc.acc === "natural" ? 0 : -1;
          var lowercase = acc.note.toLowerCase();
          var note = extractNote(lowercase.charCodeAt(0) - "c".charCodeAt(0));
          accidentals2[note] += d;
        }
        return accidentals2;
      }
      var graceDivider = 8;
      function processGraceNotes(graces, companionDuration) {
        var graceDuration = 0;
        var ret = [];
        var grace;
        for (var g = 0; g < graces.length; g++) {
          grace = graces[g];
          graceDuration += grace.duration;
        }
        graceDuration = graceDuration / graceDivider;
        var multiplier2 = graceDuration * 2 > companionDuration ? companionDuration / (graceDuration * 2) : 1;
        for (g = 0; g < graces.length; g++) {
          grace = graces[g];
          var pitch = grace.midipitch ? grace.midipitch - 60 : grace.pitch;
          ret.push({ pitch, duration: grace.duration / graceDivider * multiplier2 });
        }
        return ret;
      }
      function writeGraceNotes(graces, stealFromCurrent, duration, skipNote, velocity) {
        for (var g = 0; g < graces.length; g++) {
          var gp = graces[g];
          if (gp !== skipNote)
            currentTrack.push({ cmd: "start", pitch: gp.pitch, volume: velocity });
          currentTrack.push({ cmd: "move", duration: graces[g].duration * tempoChangeFactor });
          if (gp !== skipNote)
            currentTrack.push({ cmd: "stop", pitch: gp.pitch });
          if (!stealFromCurrent)
            currentTrack[lastNoteDurationPosition].duration -= graces[g].duration;
          duration -= graces[g].duration;
        }
        return duration;
      }
      function extractOctave(pitch) {
        return Math.floor(pitch / 7);
      }
      function extractNote(pitch) {
        pitch = pitch % 7;
        if (pitch < 0) pitch += 7;
        return pitch;
      }
      var basses = {
        "A": -27,
        "B": -25,
        "C": -24,
        "D": -22,
        "E": -20,
        "F": -19,
        "G": -17
      };
      function interpretChord(name) {
        if (name.length === 0)
          return void 0;
        if (name === "break")
          return { chick: [] };
        var root = name.substring(0, 1);
        if (root === "(") {
          name = name.substring(1, name.length - 2);
          if (name.length === 0)
            return void 0;
          root = name.substring(0, 1);
        }
        var bass = basses[root];
        if (!bass)
          return void 0;
        bass += transpose;
        var bass2 = bass - 5;
        var chick;
        if (name.length === 1)
          chick = chordNotes(bass, "");
        var remaining = name.substring(1);
        var acc = remaining.substring(0, 1);
        if (acc === "b" || acc === "") {
          bass--;
          bass2--;
          remaining = remaining.substring(1);
        } else if (acc === "#" || acc === "") {
          bass++;
          bass2++;
          remaining = remaining.substring(1);
        }
        var arr = remaining.split("/");
        chick = chordNotes(bass, arr[0]);
        if (arr.length === 2) {
          var explicitBass = basses[arr[1].substring(0, 1)];
          if (explicitBass) {
            var bassAcc = arr[1].substring(1);
            var bassShift = { "#": 1, "": 1, "b": -1, "": -1 }[bassAcc] || 0;
            bass = basses[arr[1].substring(0, 1)] + bassShift + transpose;
            bass2 = bass;
          }
        }
        return { boom: bass, boom2: bass2, chick };
      }
      var chordIntervals = {
        // diminished (all flat 5 chords)
        "dim": [0, 3, 6],
        "": [0, 3, 6],
        "": [0, 3, 6],
        "dim7": [0, 3, 6, 9],
        "7": [0, 3, 6, 9],
        "7": [0, 3, 6, 9],
        "7": [0, 3, 6, 10],
        "m7(b5)": [0, 3, 6, 10],
        "m7b5": [0, 3, 6, 10],
        "-7(b5)": [0, 3, 6, 10],
        "-7b5": [0, 3, 6, 10],
        "7b5": [0, 4, 6, 10],
        "7(b5)": [0, 4, 6, 10],
        "75": [0, 4, 6, 10],
        "7(b9,b5)": [0, 4, 6, 10, 13],
        "7b9,b5": [0, 4, 6, 10, 13],
        "7(#9,b5)": [0, 4, 6, 10, 15],
        "7#9b5": [0, 4, 6, 10, 15],
        "maj7(b5)": [0, 3, 6, 11],
        "maj7b5": [0, 3, 6, 11],
        "13(b5)": [0, 4, 6, 10, 14, 18],
        "13b5": [0, 4, 6, 10, 14, 18],
        // minor (all normal 5, minor 3 chords)
        "m": [0, 3, 7],
        "-": [0, 3, 7],
        "m6": [0, 3, 7, 9],
        "-6": [0, 3, 7, 9],
        "m7": [0, 3, 7, 10],
        "-7": [0, 3, 7, 10],
        "-(b6)": [0, 3, 7, 8],
        "-b6": [0, 3, 7, 8],
        "-6/9": [0, 3, 7, 9, 14],
        "-7(b9)": [0, 3, 7, 10, 13],
        "-7b9": [0, 3, 7, 10, 13],
        "-maj7": [0, 3, 7, 11],
        "-9+7": [0, 3, 7, 11, 13],
        "-11": [0, 3, 7, 11, 14, 16],
        // major (all normal 5, major 3 chords)
        "M": [0, 4, 7],
        "6": [0, 4, 7, 9],
        "6/9": [0, 4, 7, 9, 14],
        "7": [0, 4, 7, 10],
        "9": [0, 4, 7, 10, 14],
        "11": [0, 4, 7, 10, 14, 16],
        "13": [0, 4, 7, 10, 14, 18],
        "7b9": [0, 4, 7, 10, 13],
        "79": [0, 4, 7, 10, 13],
        "7(b9)": [0, 4, 7, 10, 13],
        "7(#9)": [0, 4, 7, 10, 15],
        "7#9": [0, 4, 7, 10, 15],
        "(13)": [0, 4, 7, 10, 14, 18],
        "7(9,13)": [0, 4, 7, 10, 14, 18],
        "7(#9,b13)": [0, 4, 7, 10, 15, 17],
        "7(#11)": [0, 4, 7, 10, 14, 17],
        "7#11": [0, 4, 7, 10, 14, 17],
        "7(b13)": [0, 4, 7, 10, 17],
        "7b13": [0, 4, 7, 10, 17],
        "9(#11)": [0, 4, 7, 10, 14, 17],
        "9#11": [0, 4, 7, 10, 14, 17],
        "13(#11)": [0, 4, 7, 10, 15, 18],
        "13#11": [0, 4, 7, 10, 15, 18],
        "maj7": [0, 4, 7, 11],
        "7": [0, 4, 7, 11],
        "7": [0, 4, 7, 11],
        "maj9": [0, 4, 7, 11, 14],
        "maj7(9)": [0, 4, 7, 11, 14],
        "maj7(11)": [0, 4, 7, 11, 16],
        "maj7(#11)": [0, 4, 7, 11, 17],
        "maj7(13)": [0, 4, 7, 11, 18],
        "maj7(9,13)": [0, 4, 7, 11, 14, 18],
        "7sus4": [0, 5, 7, 10],
        "m7sus4": [0, 5, 7, 10],
        "sus4": [0, 5, 7],
        "sus2": [0, 2, 7],
        "7sus2": [0, 2, 7, 10],
        "9sus4": [0, 5, 7, 14],
        "13sus4": [0, 5, 7, 18],
        // augmented (all sharp 5 chords)
        "aug7": [0, 4, 8, 10],
        "+7": [0, 4, 8, 10],
        "+": [0, 4, 8],
        "7#5": [0, 4, 8, 10],
        "75": [0, 4, 8, 10],
        "7+5": [0, 4, 8, 10],
        "9#5": [0, 4, 8, 10, 14],
        "95": [0, 4, 8, 10, 14],
        "9+5": [0, 4, 8, 10, 14],
        "-7(#5)": [0, 3, 8, 10],
        "-7#5": [0, 3, 8, 10],
        "7(#5)": [0, 4, 8, 10],
        "7(b9,#5)": [0, 4, 8, 10, 13],
        "7b9#5": [0, 4, 8, 10, 13],
        "maj7(#5)": [0, 4, 8, 11],
        "maj7#5": [0, 4, 8, 11],
        "maj7(#5,#11)": [0, 4, 8, 11, 14],
        "maj7#5#11": [0, 4, 8, 11, 14],
        "9(#5)": [0, 4, 8, 10, 14],
        "13(#5)": [0, 4, 8, 10, 14, 18],
        "13#5": [0, 4, 8, 10, 14, 18]
      };
      function chordNotes(bass, modifier) {
        var intervals = chordIntervals[modifier];
        if (!intervals)
          intervals = chordIntervals.M;
        bass += 12;
        var notes = [];
        for (var i = 0; i < intervals.length; i++) {
          notes.push(bass + intervals[i]);
        }
        return notes;
      }
      function writeBoom(boom, beatLength) {
        if (boom !== void 0)
          chordTrack.push({ cmd: "start", pitch: boom, volume: 64 });
        chordTrack.push({ cmd: "move", duration: beatLength / 2 * tempoChangeFactor });
        if (boom !== void 0)
          chordTrack.push({ cmd: "stop", pitch: boom });
        chordTrack.push({ cmd: "move", duration: beatLength / 2 * tempoChangeFactor });
      }
      function writeChick(chick, beatLength) {
        for (var c = 0; c < chick.length; c++)
          chordTrack.push({ cmd: "start", pitch: chick[c], volume: 48 });
        chordTrack.push({ cmd: "move", duration: beatLength / 2 * tempoChangeFactor });
        for (c = 0; c < chick.length; c++)
          chordTrack.push({ cmd: "stop", pitch: chick[c] });
        chordTrack.push({ cmd: "move", duration: beatLength / 2 * tempoChangeFactor });
      }
      var rhythmPatterns = {
        "2/2": ["boom", "chick"],
        "2/4": ["boom", "chick"],
        "3/4": ["boom", "chick", "chick"],
        "4/4": ["boom", "chick", "boom2", "chick"],
        "5/4": ["boom", "chick", "chick", "boom2", "chick"],
        "6/8": ["boom", "", "chick", "boom2", "", "chick"],
        "9/8": ["boom", "", "chick", "boom2", "", "chick", "boom2", "", "chick"],
        "12/8": ["boom", "", "chick", "boom2", "", "chick", "boom2", "", "chick", "boom2", "", "chick"]
      };
      function resolveChords() {
        var num = meter.num;
        var den = meter.den;
        var beatLength = 1 / den;
        var pattern = rhythmPatterns[num + "/" + den];
        var thisMeasureLength = parseInt(num, 10) / parseInt(den, 10);
        var portionOfAMeasure = Math.abs(thisMeasureLength - barBeat);
        if (!pattern || portionOfAMeasure > 78125e-7) {
          pattern = [];
          var beatsPresent = barBeat / beatLength;
          for (var p = 0; p < beatsPresent; p++)
            pattern.push("chick");
        }
        if (currentChords.length === 0) {
          currentChords.push({ beat: 0, chord: lastChord });
        }
        if (currentChords[0].beat !== 0 && lastChord) {
          currentChords.unshift({ beat: 0, chord: lastChord });
        }
        if (currentChords.length === 1) {
          for (var m = 0; m < pattern.length; m++) {
            switch (pattern[m]) {
              case "boom":
                writeBoom(currentChords[0].chord.boom, beatLength);
                break;
              case "boom2":
                writeBoom(currentChords[0].chord.boom2, beatLength);
                break;
              case "chick":
                writeChick(currentChords[0].chord.chick, beatLength);
                break;
              case "":
                chordTrack.push({ cmd: "move", duration: beatLength * tempoChangeFactor });
                break;
            }
          }
          return;
        }
        var beats = {};
        for (var i = 0; i < currentChords.length; i++) {
          var cc = currentChords[i];
          var beat = Math.floor(cc.beat / beatLength);
          beats["" + beat] = cc;
        }
        for (var m2 = 0; m2 < pattern.length; m2++) {
          var thisChord;
          if (beats["" + m2])
            thisChord = beats["" + m2];
          switch (pattern[m2]) {
            case "boom":
              if (beats["" + (m2 + 1)])
                writeChick(thisChord.chord.chick, beatLength);
              else
                writeBoom(thisChord.chord.boom, beatLength);
              break;
            case "boom2":
              if (beats["" + (m2 + 1)])
                writeChick(thisChord.chord.chick, beatLength);
              else
                writeBoom(thisChord.chord.boom2, beatLength);
              break;
            case "chick":
              writeChick(thisChord.chord.chick, beatLength);
              break;
            case "":
              if (beats["" + m2])
                writeChick(thisChord.chord.chick, beatLength);
              else
                chordTrack.push({ cmd: "move", duration: beatLength * tempoChangeFactor });
              break;
          }
        }
      }
      function normalizeDrumDefinition(params) {
        if (params.pattern.length === 0 || params.on === false)
          return { on: false };
        var str = params.pattern[0];
        var events = [];
        var event = "";
        var totalPlay = 0;
        for (var i = 0; i < str.length; i++) {
          if (str[i] === "d")
            totalPlay++;
          if (str[i] === "d" || str[i] === "z") {
            if (event.length !== 0) {
              events.push(event);
              event = str[i];
            } else
              event = event + str[i];
          } else {
            if (event.length === 0) {
              return { on: false };
            }
            event = event + str[i];
          }
        }
        if (event.length !== 0)
          events.push(event);
        if (params.pattern.length !== totalPlay * 2 + 1)
          return { on: false };
        var ret = { on: true, bars: params.bars, pattern: [] };
        var beatLength = 1 / meter.den;
        var playCount = 0;
        for (var j = 0; j < events.length; j++) {
          event = events[j];
          var len = 1;
          var div = false;
          var num = 0;
          for (var k = 1; k < event.length; k++) {
            switch (event[k]) {
              case "/":
                if (num !== 0)
                  len *= num;
                num = 0;
                div = true;
                break;
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                num = num * 10 + event[k];
                break;
              default:
                return { on: false };
            }
          }
          if (div) {
            if (num === 0) num = 2;
            len /= num;
          } else if (num)
            len *= num;
          if (event[0] === "d") {
            ret.pattern.push({ len: len * beatLength, pitch: params.pattern[1 + playCount], velocity: params.pattern[1 + playCount + totalPlay] });
            playCount++;
          } else
            ret.pattern.push({ len: len * beatLength, pitch: null });
        }
        var totalTime = 0;
        var measuresPerBeat = meter.num / meter.den;
        for (var ii = 0; ii < ret.pattern.length; ii++)
          totalTime += ret.pattern[ii].len;
        var numBars = params.bars ? params.bars : 1;
        var factor = totalTime / numBars / measuresPerBeat;
        for (ii = 0; ii < ret.pattern.length; ii++)
          ret.pattern[ii].len = ret.pattern[ii].len / factor;
        return ret;
      }
      function drumBeat(pitch, soundLength, volume) {
        drumTrack.push({ cmd: "start", pitch: pitch - 60, volume });
        drumTrack.push({ cmd: "move", duration: soundLength });
        drumTrack.push({ cmd: "stop", pitch: pitch - 60 });
      }
      function writeDrum(channel) {
        if (drumTrack.length === 0 && !drumDefinition.on)
          return;
        var measureLen = meter.num / meter.den;
        if (drumTrack.length === 0) {
          drumTrack.push({ cmd: "program", channel, instrument: drumInstrument });
          var distance = timeFromStart();
          if (distance > 0 && distance < measureLen - 0.01) {
            drumTrack.push({ cmd: "move", duration: distance * tempoChangeFactor });
            return;
          }
        }
        if (!drumDefinition.on) {
          drumTrack.push({ cmd: "move", duration: measureLen * tempoChangeFactor });
          return;
        }
        for (var i = 0; i < drumDefinition.pattern.length; i++) {
          var len = drumDefinition.pattern[i].len * tempoChangeFactor;
          if (drumDefinition.pattern[i].pitch)
            drumBeat(drumDefinition.pattern[i].pitch, len, drumDefinition.pattern[i].velocity);
          else
            drumTrack.push({ cmd: "move", duration: len });
        }
      }
    })();
    module.exports = flatten;
  }
});

// node_modules/abcjs/src/synth/create-synth.js
var require_create_synth = __commonJS({
  "node_modules/abcjs/src/synth/create-synth.js"(exports, module) {
    var getNote = require_load_note();
    var soundsCache = require_sounds_cache();
    var createNoteMap = require_create_note_map();
    var registerAudioContext = require_register_audio_context();
    var activeAudioContext = require_active_audio_context();
    var supportsAudio = require_supports_audio();
    var pitchToNoteName = require_pitch_to_note_name();
    var instrumentIndexToName = require_instrument_index_to_name();
    var downloadBuffer = require_download_buffer();
    var sequence = require_abc_midi_sequencer();
    var flatten = require_abc_midi_flattener();
    var notSupportedMessage = "MIDI is not supported in this browser.";
    var defaultSoundFontUrl = "https://paulrosen.github.io/midi-js-soundfonts/FluidR3_GM/";
    function CreateSynth() {
      var self = this;
      self.audioBufferPossible = void 0;
      self.directSource = [];
      self.startTimeSec = void 0;
      self.pausedTimeSec = void 0;
      self.audioBuffers = [];
      self.duration = void 0;
      self.isRunning = false;
      self.init = function(options) {
        if (!options)
          options = {};
        registerAudioContext(options.audioContext);
        var startTime = activeAudioContext().currentTime;
        self.debugCallback = options.debugCallback;
        if (self.debugCallback)
          self.debugCallback("init called");
        self.audioBufferPossible = self._deviceCapable();
        if (!self.audioBufferPossible)
          return Promise.reject({ status: "NotSupported", message: notSupportedMessage });
        self.soundFontUrl = options.soundFontUrl ? options.soundFontUrl : defaultSoundFontUrl;
        self.millisecondsPerMeasure = options.millisecondsPerMeasure ? options.millisecondsPerMeasure : options.visualObj ? options.visualObj.millisecondsPerMeasure() : 1e3;
        var params = options.options ? options.options : {};
        self.meterSize = 1;
        if (options.visualObj) {
          var seq = sequence(options.visualObj, params);
          self.flattened = flatten(seq, params);
          self.meterSize = options.visualObj.getMeterFraction().num / options.visualObj.getMeterFraction().den;
        } else if (options.sequence)
          self.flattened = options.sequence;
        else
          return Promise.reject(new Error("Must pass in either a visualObj or a sequence"));
        self.sequenceCallback = params.sequenceCallback;
        self.callbackContext = params.callbackContext;
        self.onEnded = options.onEnded;
        var allNotes = {};
        var currentInstrument = instrumentIndexToName[0];
        self.flattened.tracks.forEach(function(track) {
          track.forEach(function(event) {
            if (event.cmd === "program" && instrumentIndexToName[event.instrument])
              currentInstrument = instrumentIndexToName[event.instrument];
            if (event.pitch !== void 0) {
              var pitchNumber = event.pitch + 60;
              var noteName = pitchToNoteName[pitchNumber];
              if (noteName) {
                if (!allNotes[currentInstrument])
                  allNotes[currentInstrument] = {};
                allNotes[currentInstrument][pitchToNoteName[pitchNumber]] = true;
              } else
                console.log("Can't find note: ", pitchNumber);
            }
          });
        });
        if (self.debugCallback)
          self.debugCallback("note gathering time = " + Math.floor((activeAudioContext().currentTime - startTime) * 1e3) + "ms");
        startTime = activeAudioContext().currentTime;
        var notes = [];
        Object.keys(allNotes).forEach(function(instrument) {
          Object.keys(allNotes[instrument]).forEach(function(note) {
            notes.push({ instrument, note });
          });
        });
        var batches = [];
        var CHUNK = 256;
        for (var i = 0; i < notes.length; i += CHUNK) {
          batches.push(notes.slice(i, i + CHUNK));
        }
        return new Promise(function(resolve, reject) {
          var results = [];
          var index = 0;
          var next = function() {
            if (index < batches.length) {
              self._loadBatch(batches[index], self.soundFontUrl, startTime).then(function(data) {
                startTime = activeAudioContext().currentTime;
                results.push(data);
                index++;
                next();
              }, reject);
            } else {
              resolve(results);
            }
          };
          next();
        });
      };
      self._loadBatch = function(batch, soundFontUrl, startTime) {
        var promises = [];
        batch.forEach(function(item) {
          promises.push(getNote(soundFontUrl, item.instrument, item.note, activeAudioContext()));
        });
        return Promise.all(promises).then(function(response) {
          if (self.debugCallback)
            self.debugCallback("mp3 load time = " + Math.floor((activeAudioContext().currentTime - startTime) * 1e3) + "ms");
          return Promise.resolve(response);
        });
      };
      self.prime = function() {
        self.isRunning = false;
        if (!self.audioBufferPossible)
          return Promise.reject(new Error(notSupportedMessage));
        if (self.debugCallback)
          self.debugCallback("prime called");
        return new Promise(function(resolve) {
          var startTime = activeAudioContext().currentTime;
          var tempoMultiplier = self.millisecondsPerMeasure / 1e3 / self.meterSize;
          self.duration = self.flattened.totalDuration * tempoMultiplier;
          var totalSamples = Math.floor(activeAudioContext().sampleRate * self.duration);
          self.stop();
          var noteMapTracks = createNoteMap(self.flattened);
          if (self.sequenceCallback)
            self.sequenceCallback(noteMapTracks, self.callbackContext);
          self.audioBuffers = [];
          noteMapTracks.forEach(function(noteMap) {
            var audioBuffer = activeAudioContext().createBuffer(1, totalSamples, activeAudioContext().sampleRate);
            var chanData = audioBuffer.getChannelData(0);
            noteMap.forEach(function(note) {
              self._placeNote(chanData, note, tempoMultiplier, soundsCache);
            });
            self.audioBuffers.push(audioBuffer);
          });
          if (self.debugCallback) {
            self.debugCallback("sampleRate = " + activeAudioContext().sampleRate);
            self.debugCallback("totalSamples = " + totalSamples);
            self.debugCallback("creationTime = " + Math.floor((activeAudioContext().currentTime - startTime) * 1e3) + "ms");
          }
          resolve({
            status: "ok",
            seconds: 0
          });
        });
      };
      self.start = function() {
        if (self.pausedTimeSec) {
          self.resume();
          return;
        }
        if (!self.audioBufferPossible)
          throw new Error(notSupportedMessage);
        if (self.debugCallback)
          self.debugCallback("start called");
        self._kickOffSound(0);
        self.startTimeSec = activeAudioContext().currentTime;
        self.pausedTimeSec = void 0;
        if (self.debugCallback)
          self.debugCallback("MIDI STARTED", self.startTimeSec);
      };
      self.pause = function() {
        if (!self.audioBufferPossible)
          throw new Error(notSupportedMessage);
        if (self.debugCallback)
          self.debugCallback("pause called");
        if (!self.pausedTimeSec) {
          self.stop();
          self.pausedTimeSec = activeAudioContext().currentTime;
        }
      };
      self.resume = function() {
        if (!self.audioBufferPossible)
          throw new Error(notSupportedMessage);
        if (self.debugCallback)
          self.debugCallback("resume called");
        var offset = self.pausedTimeSec - self.startTimeSec;
        self.startTimeSec = activeAudioContext().currentTime - offset;
        self.pausedTimeSec = void 0;
        self._kickOffSound(offset);
      };
      self.seek = function(percent) {
        var offset = self.duration * percent;
        if (!self.audioBufferPossible)
          throw new Error(notSupportedMessage);
        if (self.debugCallback)
          self.debugCallback("seek called sec=" + offset);
        if (self.isRunning) {
          self.stop();
          self._kickOffSound(offset);
        }
        var pauseDistance = self.pausedTimeSec ? self.pausedTimeSec - self.startTimeSec : void 0;
        self.startTimeSec = activeAudioContext().currentTime - offset;
        if (self.pausedTimeSec)
          self.pausedTimeSec = self.startTimeSec + pauseDistance;
      };
      self.stop = function() {
        self.isRunning = false;
        self.pausedTimeSec = void 0;
        self.directSource.forEach(function(source) {
          try {
            source.stop();
          } catch (error) {
            console.log("direct source didn't stop:", error);
          }
        });
        self.directSource = [];
      };
      self.download = function() {
        return downloadBuffer(self);
      };
      self._deviceCapable = function() {
        if (!supportsAudio()) {
          console.warn(notSupportedMessage);
          if (self.debugCallback)
            self.debugCallback(notSupportedMessage);
          return false;
        }
        return true;
      };
      self._kickOffSound = function(seconds) {
        self.isRunning = true;
        self.directSource = [];
        self.audioBuffers.forEach(function(audioBuffer, trackNum) {
          self.directSource[trackNum] = activeAudioContext().createBufferSource();
          self.directSource[trackNum].buffer = audioBuffer;
          self.directSource[trackNum].connect(activeAudioContext().destination);
        });
        self.directSource.forEach(function(source) {
          source.start(0, seconds);
        });
        if (self.onEnded) {
          self.directSource[0].onended = function() {
            self.onEnded(self.callbackContext);
          };
        }
      };
      self._placeNote = function(chanData, note, tempoMultiplier, soundsCache2) {
        var start = Math.floor(note.start * activeAudioContext().sampleRate * tempoMultiplier);
        var numBeats = note.end - note.start;
        var noteTimeSec = numBeats * tempoMultiplier;
        var noteName = pitchToNoteName[note.pitch + 60];
        if (noteName) {
          var pitch = soundsCache2[note.instrument][noteName].getChannelData(0);
          var duration = Math.min(pitch.length, Math.floor(noteTimeSec * activeAudioContext().sampleRate));
          for (var i = 0; i < duration; i++) {
            var thisSample = pitch[i] * note.volume / 128;
            if (chanData[start + i])
              chanData[start + i] = (chanData[start + i] + thisSample) * 0.75;
            else
              chanData[start + i] = thisSample;
          }
        }
      };
    }
    module.exports = CreateSynth;
  }
});

// node_modules/abcjs/src/synth/synth-sequence.js
var require_synth_sequence = __commonJS({
  "node_modules/abcjs/src/synth/synth-sequence.js"(exports, module) {
    var SynthSequence = function() {
      var self = this;
      self.tracks = [];
      self.totalDuration = 0;
      self.addTrack = function() {
        self.tracks.push([]);
        return self.tracks.length - 1;
      };
      self.setInstrument = function(trackNumber, instrumentNumber) {
        self.tracks[trackNumber].push({
          channel: 0,
          cmd: "program",
          instrument: instrumentNumber
        });
      };
      self.appendNote = function(trackNumber, pitch, durationInMeasures, volume) {
        self.tracks[trackNumber].push({
          cmd: "start",
          pitch: pitch - 60,
          volume
        });
        self.tracks[trackNumber].push({
          cmd: "move",
          duration: durationInMeasures
        });
        self.tracks[trackNumber].push({
          cmd: "stop",
          pitch: pitch - 60
        });
        var duration = 0;
        self.tracks[trackNumber].forEach(function(event) {
          if (event.duration)
            duration += event.duration;
        });
        self.totalDuration = Math.max(self.totalDuration, duration);
      };
    };
    module.exports = SynthSequence;
  }
});

// node_modules/abcjs/src/synth/create-synth-control.js
var require_create_synth_control = __commonJS({
  "node_modules/abcjs/src/synth/create-synth-control.js"(exports, module) {
    var supportsAudio = require_supports_audio();
    var registerAudioContext = require_register_audio_context();
    var activeAudioContext = require_active_audio_context();
    var parseCommon = require_abc_common();
    var loopImage = '<svg version="1.0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 700 700" preserveAspectRatio="xMidYMid meet">\n<g transform="translate(0,700) scale(0.1,-0.1)" >\n<path d="M3111 6981 c-20 -37 -90 -55 -364 -96 -120 -18 -190 -33 -244 -55 -42 -17 -124 -42 -182 -56 -78 -18 -119 -34 -157 -60 -28 -19 -86 -46 -128 -60 -43 -13 -107 -42 -144 -64 -37 -23 -84 -46 -106 -52 -21 -7 -56 -29 -79 -50 -22 -22 -61 -50 -86 -63 -26 -13 -67 -40 -91 -60 -24 -20 -65 -47 -90 -60 -25 -13 -53 -31 -61 -41 -8 -9 -32 -30 -54 -46 -75 -54 -486 -460 -512 -507 -15 -25 -48 -69 -75 -98 -26 -28 -48 -57 -48 -63 0 -6 -18 -29 -39 -53 -21 -23 -56 -71 -77 -107 -20 -36 -50 -80 -65 -97 -16 -18 -33 -52 -40 -75 -12 -47 -47 -115 -84 -166 -13 -18 -30 -56 -38 -83 -8 -27 -34 -80 -56 -118 -33 -53 -46 -91 -62 -167 -12 -63 -34 -127 -59 -179 -42 -84 -60 -166 -60 -270 0 -90 26 -122 125 -154 54 -17 96 -19 430 -20 305 -1 381 2 430 14 82 22 140 51 153 78 6 12 22 47 37 77 14 30 38 77 54 103 15 27 34 73 40 103 7 30 28 78 48 107 19 28 44 74 55 101 10 28 34 67 53 87 18 20 49 61 68 90 19 30 44 63 57 74 13 11 36 40 52 65 59 94 232 270 306 313 20 11 57 37 82 58 25 20 70 52 100 72 30 19 66 47 79 61 13 14 49 35 80 46 30 12 80 37 111 56 31 19 95 45 143 58 48 12 110 37 139 55 63 40 127 55 323 76 83 9 208 28 279 41 156 29 165 29 330 4 453 -71 514 -84 606 -130 31 -16 83 -36 116 -45 32 -9 84 -34 115 -56 31 -21 82 -48 113 -60 32 -11 72 -33 89 -48 18 -16 59 -45 92 -65 33 -21 74 -51 90 -66 17 -15 49 -40 73 -54 52 -32 65 -61 50 -113 -8 -31 -61 -90 -277 -308 -300 -303 -361 -382 -369 -481 -2 -29 0 -66 6 -81 13 -40 88 -138 115 -151 12 -6 54 -26 92 -44 l70 -33 945 -2 c520 -1 975 2 1012 7 64 8 191 50 231 76 11 7 33 34 50 60 22 34 42 51 65 58 l32 9 0 1101 0 1102 -32 9 c-21 7 -44 26 -64 55 -60 84 -77 97 -140 110 -44 9 -76 10 -127 2 -59 -9 -77 -17 -134 -62 -37 -28 -172 -155 -301 -281 -129 -127 -249 -237 -267 -245 -25 -10 -41 -11 -71 -2 -58 15 -112 45 -124 69 -6 11 -35 35 -64 54 -28 18 -58 41 -66 50 -8 9 -41 35 -75 58 -33 22 -77 56 -99 75 -21 18 -64 46 -95 61 -31 14 -73 39 -93 55 -20 15 -70 40 -110 55 -40 15 -97 44 -127 64 -29 21 -78 44 -107 53 -30 8 -77 31 -105 51 -42 28 -73 39 -173 60 -68 14 -154 39 -196 58 -95 43 -131 51 -343 76 -209 24 -242 32 -279 70 l-30 29 -328 0 c-312 0 -330 -1 -339 -19z"></path>\n<path d="M254 2875 c-89 -16 -107 -26 -145 -78 -32 -44 -62 -66 -91 -67 -17 0 -18 -61 -18 -1140 l0 -1140 24 0 c16 0 41 -17 72 -50 40 -42 61 -55 117 -72 l69 -21 82 23 c44 12 96 30 114 39 18 9 148 132 290 272 141 141 267 261 279 268 51 26 86 14 176 -61 32 -26 62 -48 66 -48 5 0 36 -25 70 -55 34 -30 74 -61 89 -69 15 -8 37 -28 50 -45 12 -17 50 -45 84 -62 34 -17 78 -44 98 -60 19 -16 61 -37 93 -48 32 -11 81 -37 107 -56 27 -20 76 -45 109 -56 33 -12 75 -31 93 -44 62 -45 93 -58 191 -82 54 -12 130 -37 168 -54 68 -29 180 -58 226 -59 62 0 183 -64 183 -96 0 -12 88 -14 639 -14 l639 0 12 30 c18 44 76 66 233 89 89 14 160 30 200 47 34 15 106 42 159 60 54 18 112 44 130 57 47 35 85 52 146 67 29 7 76 28 105 48 29 20 77 48 107 63 30 15 66 39 80 54 14 15 50 40 81 56 31 15 78 46 104 69 26 22 61 46 79 54 17 7 43 26 56 42 14 16 41 41 60 56 64 48 380 362 408 405 15 23 40 51 55 63 15 12 36 38 46 58 11 21 37 57 58 82 22 25 49 62 62 83 13 20 38 56 57 78 19 23 50 74 69 113 19 39 46 86 59 104 14 18 34 62 46 98 12 36 32 77 45 92 31 38 60 97 80 167 9 33 26 76 37 95 29 50 47 103 68 206 10 52 32 117 51 155 29 56 33 74 34 140 0 94 -10 108 -101 138 -61 20 -83 21 -463 21 -226 0 -421 -4 -451 -10 -63 -12 -86 -30 -110 -85 -10 -22 -33 -63 -52 -92 -21 -31 -42 -80 -53 -123 -11 -44 -32 -93 -56 -128 -20 -32 -47 -83 -59 -115 -12 -32 -37 -77 -56 -100 -19 -23 -50 -65 -69 -94 -19 -29 -44 -57 -54 -63 -11 -5 -29 -27 -42 -47 -52 -85 -234 -277 -300 -315 -25 -15 -53 -38 -62 -51 -9 -14 -42 -39 -74 -57 -32 -18 -75 -48 -95 -66 -21 -18 -59 -44 -85 -58 -26 -13 -72 -40 -100 -59 -35 -24 -78 -41 -128 -52 -47 -11 -99 -31 -139 -56 -69 -42 -94 -49 -391 -110 -245 -51 -425 -66 -595 -50 -168 16 -230 27 -330 61 -47 16 -123 35 -170 44 -98 17 -123 25 -172 58 -20 14 -71 37 -114 53 -44 15 -95 40 -115 56 -20 16 -70 42 -110 59 -40 16 -88 45 -108 63 -20 19 -55 46 -78 61 -24 14 -49 35 -55 47 -7 11 -34 33 -60 49 -50 31 -65 61 -53 102 4 13 130 147 281 298 236 238 277 283 299 335 15 32 35 71 46 86 12 18 19 44 19 76 0 42 -8 63 -53 138 -92 151 11 139 -1207 141 -798 2 -1030 0 -1086 -11z"></path>\n</g>\n</svg>\n';
    var playImage = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" class="abcjs-play-svg">\n    <g>\n    <polygon points="4 0 23 12.5 4 25"/>\n    </g>\n</svg>';
    var pauseImage = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" class="abcjs-pause-svg">\n  <g>\n    <rect width="8.23" height="25"/>\n    <rect width="8.23" height="25" x="17"/>\n  </g>\n</svg>';
    var loadingImage = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="abcjs-loading-svg">\n    <circle cx="50" cy="50" fill="none" stroke-width="20" r="35" stroke-dasharray="160 55"></circle>\n</svg>';
    var resetImage = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25">\n  <g>\n    <polygon points="5 12.5 24 0 24 25"/>\n    <rect width="3" height="25" x="0" y="0"/>\n  </g>\n</svg>';
    function CreateSynthControl(parent, options) {
      var self = this;
      if (typeof parent === "string") {
        var selector = parent;
        parent = document.querySelector(selector);
        if (!parent)
          throw new Error('Cannot find element "' + selector + '" in the DOM.');
      } else if (!(parent instanceof HTMLElement))
        throw new Error("The first parameter must be a valid element or selector in the DOM.");
      self.parent = parent;
      self.options = {};
      if (options)
        self.options = parseCommon.clone(options);
      if (self.options.ac)
        registerAudioContext(self.options.ac);
      buildDom(self.parent, self.options);
      attachListeners(self);
      self.setTempo = function(tempo) {
        var el = self.parent.querySelector(".abcjs-midi-current-tempo");
        if (el)
          el.innerHTML = tempo;
      };
      self.resetAll = function() {
        var pushedButtons = self.parent.querySelectorAll(".abcjs-pushed");
        for (var i = 0; i < pushedButtons.length; i++) {
          var button = pushedButtons[i];
          button.classList.remove("abcjs-pushed");
        }
      };
      self.pushPlay = function(push) {
        var startButton = self.parent.querySelector(".abcjs-midi-start");
        if (!startButton)
          return;
        if (push)
          startButton.classList.add("abcjs-pushed");
        else
          startButton.classList.remove("abcjs-pushed");
      };
      self.pushLoop = function(push) {
        var loopButton = self.parent.querySelector(".abcjs-midi-loop");
        if (!loopButton)
          return;
        if (push)
          loopButton.classList.add("abcjs-pushed");
        else
          loopButton.classList.remove("abcjs-pushed");
      };
      self.setProgress = function(percent, totalTime) {
        var progressBackground = self.parent.querySelector(".abcjs-midi-progress-background");
        var progressThumb = self.parent.querySelector(".abcjs-midi-progress-indicator");
        if (!progressBackground || !progressThumb)
          return;
        var width = progressBackground.clientWidth;
        var left = width * percent;
        progressThumb.style.left = left + "px";
        var clock = self.parent.querySelector(".abcjs-midi-clock");
        if (clock) {
          var totalSeconds = totalTime * percent / 1e3;
          var minutes = Math.floor(totalSeconds / 60);
          var seconds = Math.floor(totalSeconds % 60);
          var secondsFormatted = seconds < 10 ? "0" + seconds : seconds;
          clock.innerHTML = minutes + ":" + secondsFormatted;
        }
      };
      if (self.options.afterResume) {
        var isResumed = false;
        if (self.options.ac) {
          isResumed = self.options.ac.state !== "suspended";
        } else if (activeAudioContext()) {
          isResumed = activeAudioContext().state !== "suspended";
        }
        if (isResumed)
          self.options.afterResume();
      }
    }
    function buildDom(parent, options) {
      var hasLoop = !!options.loopHandler;
      var hasRestart = !!options.restartHandler;
      var hasPlay = !!options.playHandler || !!options.playPromiseHandler;
      var hasProgress = !!options.progressHandler;
      var hasWarp = !!options.warpHandler;
      var hasClock = options.hasClock !== false;
      var html = '<div class="abcjs-inline-audio">\n';
      if (hasLoop) {
        var repeatTitle = options.repeatTitle ? options.repeatTitle : "Click to toggle play once/repeat.";
        var repeatAria = options.repeatAria ? options.repeatAria : repeatTitle;
        html += '<button type="button" class="abcjs-midi-loop abcjs-btn" title="' + repeatTitle + '" aria-label="' + repeatAria + '">' + loopImage + "</button>\n";
      }
      if (hasRestart) {
        var restartTitle = options.restartTitle ? options.restartTitle : "Click to go to beginning.";
        var restartAria = options.restartAria ? options.restartAria : restartTitle;
        html += '<button type="button" class="abcjs-midi-reset abcjs-btn" title="' + restartTitle + '" aria-label="' + restartAria + '">' + resetImage + "</button>\n";
      }
      if (hasPlay) {
        var playTitle = options.playTitle ? options.playTitle : "Click to play/pause.";
        var playAria = options.playAria ? options.playAria : playTitle;
        html += '<button type="button" class="abcjs-midi-start abcjs-btn" title="' + playTitle + '" aria-label="' + playAria + '">' + playImage + pauseImage + loadingImage + "</button>\n";
      }
      if (hasProgress) {
        var randomTitle = options.randomTitle ? options.randomTitle : "Click to change the playback position.";
        var randomAria = options.randomAria ? options.randomAria : randomTitle;
        html += '<button type="button" class="abcjs-midi-progress-background" title="' + randomTitle + '" aria-label="' + randomAria + '"><span class="abcjs-midi-progress-indicator"></span></button>\n';
      }
      if (hasClock) {
        html += '<span class="abcjs-midi-clock"></span>\n';
      }
      if (hasWarp) {
        var warpTitle = options.warpTitle ? options.warpTitle : "Change the playback speed.";
        var warpAria = options.warpAria ? options.warpAria : warpTitle;
        var bpm = options.bpm ? options.bpm : "BPM";
        html += '<span class="abcjs-tempo-wrapper"><label><input class="abcjs-midi-tempo" type="number" min="1" max="300" value="100" title="' + warpTitle + '" aria-label="' + warpAria + '">%</label><span>&nbsp;(<span class="abcjs-midi-current-tempo"></span> ' + bpm + ")</span></span>\n";
      }
      html += "</div>\n";
      parent.innerHTML = html;
    }
    function acResumerMiddleWare(next, ev, playBtn, afterResume, isPromise) {
      var needsInit = true;
      if (!activeAudioContext()) {
        registerAudioContext();
      } else {
        needsInit = activeAudioContext().state === "suspended";
      }
      if (!supportsAudio()) {
        throw { status: "NotSupported", message: "This browser does not support audio." };
      }
      if ((needsInit || isPromise) && playBtn)
        playBtn.classList.add("abcjs-loading");
      if (needsInit) {
        activeAudioContext().resume().then(function() {
          if (afterResume) {
            afterResume().then(function(response) {
              doNext(next, ev, playBtn, isPromise);
            });
          } else {
            doNext(next, ev, playBtn, isPromise);
          }
        });
      } else {
        doNext(next, ev, playBtn, isPromise);
      }
    }
    function doNext(next, ev, playBtn, isPromise) {
      if (isPromise) {
        next(ev).then(function() {
          if (playBtn)
            playBtn.classList.remove("abcjs-loading");
        });
      } else {
        next(ev);
        if (playBtn)
          playBtn.classList.remove("abcjs-loading");
      }
    }
    function attachListeners(self) {
      var hasLoop = !!self.options.loopHandler;
      var hasRestart = !!self.options.restartHandler;
      var hasPlay = !!self.options.playHandler || !!self.options.playPromiseHandler;
      var hasProgress = !!self.options.progressHandler;
      var hasWarp = !!self.options.warpHandler;
      var playBtn = self.parent.querySelector(".abcjs-midi-start");
      if (hasLoop)
        self.parent.querySelector(".abcjs-midi-loop").addEventListener("click", function(ev) {
          acResumerMiddleWare(self.options.loopHandler, ev, playBtn, self.options.afterResume);
        });
      if (hasRestart)
        self.parent.querySelector(".abcjs-midi-reset").addEventListener("click", function(ev) {
          acResumerMiddleWare(self.options.restartHandler, ev, playBtn, self.options.afterResume);
        });
      if (hasPlay)
        playBtn.addEventListener("click", function(ev) {
          acResumerMiddleWare(
            self.options.playPromiseHandler || self.options.playHandler,
            ev,
            playBtn,
            self.options.afterResume,
            !!self.options.playPromiseHandler
          );
        });
      if (hasProgress)
        self.parent.querySelector(".abcjs-midi-progress-background").addEventListener("click", function(ev) {
          acResumerMiddleWare(self.options.progressHandler, ev, playBtn, self.options.afterResume);
        });
      if (hasWarp)
        self.parent.querySelector(".abcjs-midi-tempo").addEventListener("change", function(ev) {
          acResumerMiddleWare(self.options.warpHandler, ev, playBtn, self.options.afterResume);
        });
    }
    module.exports = CreateSynthControl;
  }
});

// node_modules/abcjs/src/synth/play-event.js
var require_play_event = __commonJS({
  "node_modules/abcjs/src/synth/play-event.js"(exports, module) {
    var SynthSequence = require_synth_sequence();
    var CreateSynth = require_create_synth();
    function playEvent(midiPitches, midiGracePitches, millisecondsPerMeasure) {
      var sequence = new SynthSequence();
      for (var i = 0; i < midiPitches.length; i++) {
        var note = midiPitches[i];
        var trackNum = sequence.addTrack();
        sequence.setInstrument(trackNum, note.instrument);
        if (i === 0 && midiGracePitches) {
          for (var j = 0; j < midiGracePitches.length; j++) {
            var grace = midiGracePitches[j];
            sequence.appendNote(trackNum, grace.pitch, 1 / 64, grace.volume);
          }
        }
        sequence.appendNote(trackNum, note.pitch, note.durationInMeasures, note.volume);
      }
      var buffer = new CreateSynth();
      return buffer.init({
        sequence,
        millisecondsPerMeasure
      }).then(function() {
        return buffer.prime();
      }).then(function() {
        return buffer.start();
      });
    }
    module.exports = playEvent;
  }
});

// node_modules/abcjs/src/synth/synth-controller.js
var require_synth_controller = __commonJS({
  "node_modules/abcjs/src/synth/synth-controller.js"(exports, module) {
    var CreateSynthControl = require_create_synth_control();
    var CreateSynth = require_create_synth();
    var TimingCallbacks = require_abc_timing_callbacks();
    function SynthController() {
      var self = this;
      self.warp = 100;
      self.cursorControl = null;
      self.visualObj = null;
      self.timer = null;
      self.midiBuffer = null;
      self.options = null;
      self.currentTempo = null;
      self.control = null;
      self.isLooping = false;
      self.isStarted = false;
      self.isLoaded = false;
      self.load = function(selector, cursorControl, visualOptions) {
        if (!visualOptions)
          visualOptions = {};
        self.control = new CreateSynthControl(selector, {
          loopHandler: visualOptions.displayLoop ? self.toggleLoop : void 0,
          restartHandler: visualOptions.displayRestart ? self.restart : void 0,
          playPromiseHandler: visualOptions.displayPlay ? self.play : void 0,
          progressHandler: visualOptions.displayProgress ? self.randomAccess : void 0,
          warpHandler: visualOptions.displayWarp ? self.onWarp : void 0,
          afterResume: self.init
        });
        self.cursorControl = cursorControl;
      };
      self.setTune = function(visualObj, userAction, audioParams) {
        self.isLoaded = false;
        self.visualObj = visualObj;
        self.options = audioParams;
        if (self.control) {
          self.pause();
          self.setProgress(0, 1);
          self.control.resetAll();
          self.restart();
          self.isStarted = false;
        }
        self.isLooping = false;
        if (userAction)
          return self.go();
        else {
          return Promise.resolve({ status: "no-audio-context" });
        }
      };
      self.go = function() {
        var millisecondsPerMeasure = self.visualObj.millisecondsPerMeasure() * 100 / self.warp;
        self.currentTempo = Math.round(self.visualObj.getBeatsPerMeasure() / millisecondsPerMeasure * 6e4);
        if (self.control)
          self.control.setTempo(self.currentTempo);
        self.percent = 0;
        if (!self.midiBuffer)
          self.midiBuffer = new CreateSynth();
        return self.midiBuffer.init({
          visualObj: self.visualObj,
          options: self.options,
          millisecondsPerMeasure
        }).then(function() {
          return self.midiBuffer.prime();
        }).then(function() {
          var subdivisions = 16;
          if (self.cursorControl && self.cursorControl.beatSubdivisions !== void 0 && parseInt(self.cursorControl.beatSubdivisions, 10) >= 1 && parseInt(self.cursorControl.beatSubdivisions, 10) <= 64)
            subdivisions = parseInt(self.cursorControl.beatSubdivisions, 10);
          self.timer = new TimingCallbacks(self.visualObj, {
            beatCallback: self.beatCallback,
            eventCallback: self.eventCallback,
            lineEndCallback: self.lineEndCallback,
            qpm: self.currentTempo,
            extraMeasuresAtBeginning: self.cursorControl ? self.cursorControl.extraMeasuresAtBeginning : void 0,
            lineEndAnticipation: self.cursorControl ? self.cursorControl.lineEndAnticipation : void 0,
            beatSubdivisions: subdivisions
          });
          if (self.cursorControl && self.cursorControl.onReady && typeof self.cursorControl.onReady === "function")
            self.cursorControl.onReady(self);
          self.isLoaded = true;
          return Promise.resolve({ status: "created" });
        });
      };
      self.destroy = function() {
        if (self.timer) {
          self.timer.reset();
          self.timer.stop();
          self.timer = null;
        }
        if (self.midiBuffer) {
          self.midiBuffer.stop();
          self.midiBuffer = null;
        }
        self.setProgress(0, 1);
        if (self.control)
          self.control.resetAll();
      };
      self.play = function() {
        if (!self.isLoaded) {
          return self.go().then(function() {
            return self._play();
          });
        } else
          return self._play();
      };
      self._play = function() {
        self.isStarted = !self.isStarted;
        if (self.isStarted) {
          if (self.cursorControl && self.cursorControl.onStart && typeof self.cursorControl.onStart === "function")
            self.cursorControl.onStart();
          self.midiBuffer.start();
          self.timer.start();
          if (self.control)
            self.control.pushPlay(true);
        } else {
          self.pause();
        }
        return Promise.resolve({ status: "ok" });
      };
      self.pause = function() {
        if (self.timer) {
          self.timer.pause();
          self.midiBuffer.pause();
          if (self.control)
            self.control.pushPlay(false);
        }
      };
      self.toggleLoop = function() {
        self.isLooping = !self.isLooping;
        if (self.control)
          self.control.pushLoop(self.isLooping);
      };
      self.restart = function() {
        if (self.timer) {
          self.timer.setProgress(0);
          self.midiBuffer.seek(0);
        }
      };
      self.randomAccess = function(ev) {
        if (!self.isLoaded) {
          return self.go().then(function() {
            return self._randomAccess(ev);
          });
        } else
          return self._randomAccess(ev);
      };
      self._randomAccess = function(ev) {
        var background = ev.target.classList.contains("abcjs-midi-progress-indicator") ? ev.target.parentNode : ev.target;
        var percent = (ev.x - background.offsetLeft) / background.offsetWidth;
        if (percent < 0)
          percent = 0;
        if (percent > 100)
          percent = 100;
        self.timer.setProgress(percent);
        self.midiBuffer.seek(percent);
      };
      self.onWarp = function(ev) {
        var newWarp = ev.target.value;
        if (parseInt(newWarp, 10) > 0) {
          self.warp = parseInt(newWarp, 10);
          var wasPlaying = self.isStarted;
          var startPercent = self.percent;
          self.destroy();
          self.isStarted = false;
          self.go().then(function() {
            self.setProgress(startPercent, self.midiBuffer.duration * 1e3);
            if (wasPlaying) {
              self.play();
            }
            self.timer.setProgress(startPercent);
            self.midiBuffer.seek(startPercent);
          });
        }
      };
      self.setProgress = function(percent, totalTime) {
        self.percent = percent;
        if (self.control)
          self.control.setProgress(percent, totalTime);
      };
      self.finished = function() {
        self.timer.reset();
        if (self.isLooping) {
          self.timer.start();
          self.midiBuffer.start();
        } else {
          self.timer.stop();
          if (self.isStarted) {
            if (self.control)
              self.control.pushPlay(false);
            self.isStarted = false;
            if (self.cursorControl && self.cursorControl.onFinished && typeof self.cursorControl.onFinished === "function")
              self.cursorControl.onFinished();
            self.setProgress(0, 1);
          }
        }
      };
      self.beatCallback = function(beatNumber, totalBeats, totalTime) {
        var percent = beatNumber / totalBeats;
        self.setProgress(percent, totalTime);
        if (self.cursorControl && self.cursorControl.onBeat && typeof self.cursorControl.onBeat === "function")
          self.cursorControl.onBeat(beatNumber, totalBeats, totalTime);
      };
      self.eventCallback = function(event) {
        if (event) {
          if (self.cursorControl && self.cursorControl.onEvent && typeof self.cursorControl.onEvent === "function")
            self.cursorControl.onEvent(event);
        } else {
          self.finished();
        }
      };
      self.lineEndCallback = function(data) {
        if (self.cursorControl && self.cursorControl.onLineEnd && typeof self.cursorControl.onLineEnd === "function")
          self.cursorControl.onLineEnd(data);
      };
      self.getUrl = function() {
        return self.midiBuffer.download();
      };
      self.download = function(fileName) {
        var url = self.getUrl();
        var link = document.createElement("a");
        document.body.appendChild(link);
        link.setAttribute("style", "display: none;");
        link.href = url;
        link.download = fileName ? fileName : "output.wav";
        link.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(link);
      };
    }
    module.exports = SynthController;
  }
});

// node_modules/abcjs/src/transform/abc2abc_write.js
var require_abc2abc_write = __commonJS({
  "node_modules/abcjs/src/transform/abc2abc_write.js"(exports, module) {
    var TextPrinter = function(elem, reposition) {
      this.elem = elem;
      this.text = "";
      this.l = 1 / 8;
      this.reposition = reposition || false;
    };
    TextPrinter.prototype.printString = function(str, elem) {
      if (this.reposition && elem) elem.startChar = this.text.length;
      this.text += str;
      if (this.reposition && elem) elem.endChar = this.text.length;
    };
    TextPrinter.prototype.printNewLine = function() {
      this.text += "\n";
    };
    TextPrinter.prototype.printSpace = function() {
      if (this.text[this.text.length - 1].match(/\s/)) return;
      this.text += " ";
    };
    TextPrinter.prototype.printABC = function(abctune) {
      this.text = "";
      this.abctune = abctune;
      this.printHeader();
      this.printBody();
      this.elem.value = this.text;
    };
    TextPrinter.prototype.printHeader = function() {
      this.printHeaderLine("x", "X", "1");
      this.printHeaderLine("title", "T");
      this.printHeaderLine("composer", "C");
      this.printHeaderLine("history", "H");
      this.printHeaderLine("author", "A");
      this.printHeaderLine("book", "B");
      this.printHeaderLine("discography", "D");
      this.printHeaderLine("url", "F");
      this.printHeaderLine("group", "G");
      this.printHeaderLine("instruction", "I");
      this.printHeaderLine("notes", "N");
      this.printHeaderLine("origin", "O");
      this.printHeaderLine("rhythm", "R");
      this.printHeaderLine("source", "S");
      this.printHeaderLine("unalignedwords", "W");
      this.printHeaderLine("transcription", "Z");
      this.printHeaderLine("NULL", "L", "1/8");
      this.printHeaderLine("NULL", "M", this.getMeterString(this.abctune.lines[0].staff[0].meter));
      this.printHeaderLine("NULL", "K", this.getKeyString(this.abctune.lines[0].staff[0].key));
    };
    TextPrinter.prototype.getKeyString = function(key) {
      return key.root + key.acc + key.mode;
    };
    TextPrinter.prototype.getMeterString = function(meter) {
      switch (meter.type) {
        case "cut_time":
          return "C|";
        case "common_time":
          return "C";
        case "specified":
          if (meter.value[0].den)
            return meter.value[0].num + "/" + meter.value[0].den;
          else
            return meter.value[0].num;
      }
      return "";
    };
    TextPrinter.prototype.printHeaderLine = function(fieldname, abcfield, defaut) {
      var val = this.abctune.metaText[fieldname] || defaut;
      if (val !== void 0) {
        var valarray = val.split("\n");
        for (var i = 0; i < valarray.length; i++) {
          this.printString(abcfield + ": " + valarray[i]);
          this.printNewLine();
        }
      }
    };
    TextPrinter.prototype.getElem = function() {
      if (this.abcline.length <= this.pos)
        return null;
      return this.abcline[this.pos];
    };
    TextPrinter.prototype.getNextElem = function() {
      if (this.abcline.length <= this.pos + 1)
        return null;
      return this.abcline[this.pos + 1];
    };
    TextPrinter.prototype.printBody = function() {
      for (var line = 0; line < this.abctune.lines.length; line++) {
        var abcline = this.abctune.lines[line];
        if (abcline.staff) {
          this.printABCLine(abcline.staff);
        } else if (abcline.subtitle && line !== 0) {
        } else if (abcline.text) {
        }
      }
    };
    TextPrinter.prototype.printABCLine = function(staffs) {
      for (this.s = 0; this.s < staffs.length; this.s++) {
        this.printABCStaff(staffs[this.s]);
      }
    };
    TextPrinter.prototype.printABCStaff = function(abcstaff) {
      for (this.v = 0; this.v < abcstaff.voices.length; this.v++) {
        this.printABCVoice(abcstaff.voices[this.v]);
      }
    };
    TextPrinter.prototype.printABCVoice = function(abcline) {
      this.abcline = abcline;
      for (this.pos = 0; this.pos < this.abcline.length; this.pos++) {
        this.printABCElement();
      }
      this.printNewLine();
    };
    TextPrinter.prototype.printABCElement = function() {
      var elem = this.getElem();
      switch (elem.el_type) {
        case "note":
          this.printBeam();
          break;
        case "bar":
          this.printBarLine(elem);
          break;
        case "meter":
          break;
        case "clef":
          break;
        case "key":
        //TODO this.printKeySignature(elem);
        case "stem":
          break;
        case "part":
          break;
        default:
      }
    };
    TextPrinter.prototype.printBeam = function() {
      this.printSpace();
      if (this.getElem().startBeam && !this.getElem().endBeam) {
        while (this.getElem()) {
          this.printNote(this.getElem());
          if (this.getElem().endBeam) {
            break;
          }
          this.pos++;
        }
      } else {
        this.printNote(this.getElem());
      }
      this.printSpace();
    };
    TextPrinter.prototype.printNote = function(elem) {
      var str = "";
      var i;
      if (elem.chord !== void 0) {
        for (i = 0; i < elem.chord.length; i++) {
          str += '"' + elem.chord[i].name + '"';
        }
      }
      var decorations = {
        "staccato": ".",
        "upbow": "u",
        "downbow": "v",
        "roll": "~",
        "fermata": "H",
        "slide": "J",
        "accent": "L",
        "mordent": "M",
        "pralltriller": "P",
        "trill": "T",
        "lower": "."
      };
      if (elem.decoration !== void 0) {
        for (i = 0; i < elem.decoration.length; i++) {
          var dec = elem.decoration[i];
          if (decorations[dec]) {
            str += decorations[dec];
          } else {
            str += "!";
            str += dec;
            str += "!";
          }
        }
      }
      if (elem.gracenotes !== void 0) {
        str += "{";
        for (i = 0; i < elem.gracenotes.length; i++) {
          str += this.getNoteString(elem.gracenotes[i]);
        }
        str += "}";
      }
      var ignoreslur = false;
      if (elem.pitches.length === 1 && elem.pitches[0].startSlur) {
        ignoreslur = true;
        str += this.multiplyString("(", elem.pitches[0].startSlur.length);
      }
      if (elem.startSlur) {
        str += this.multiplyString("(", elem.startSlur.length);
      }
      if (elem.pitches.length === 1 && elem.pitches[0].endSlur || elem.endSlur) {
        ignoreslur = true;
      }
      if (elem.startTriplet) {
        str += "(3";
      }
      if (elem.pitches) {
        if (elem.pitches.length > 1) str += "[";
        for (i = 0; i < elem.pitches.length; i++) {
          elem.pitches[i].duration = elem.duration;
          str += this.getNoteString(elem.pitches[i], ignoreslur);
        }
        if (elem.pitches.length > 1) str += "]";
      }
      if (elem.pitches.length === 1 && elem.pitches[0].endSlur) {
        str += this.multiplyString(")", elem.pitches[0].endSlur.length);
      }
      if (elem.endSlur) {
        str += this.multiplyString(")", elem.endSlur.length);
      }
      this.printString(str, elem);
    };
    TextPrinter.prototype.getNoteString = function(pitchelem, ignoreslur) {
      var str = "";
      if (!ignoreslur && pitchelem.startSlur) {
        str += "(";
      }
      var symb = "";
      switch (pitchelem.accidental) {
        case "quartersharp":
          symb = "^/";
          break;
        case "dblsharp":
          symb = "^^";
          break;
        case "sharp":
          symb = "^";
          break;
        case "quarterflat":
          symb = "_/";
          break;
        case "flat":
          symb = "_";
          break;
        case "dblflat":
          symb = "__";
          break;
        case "natural":
          symb = "=";
      }
      str += symb;
      var pitches = ["C", "D", "E", "F", "G", "A", "B"];
      var pitchstr = pitches[this.extractNote(pitchelem.pitch)];
      var octave = this.extractOctave(pitchelem.pitch);
      if (octave > 0) {
        pitchstr = pitchstr.toLowerCase();
        octave--;
        while (octave > 0) {
          pitchstr += "'";
          octave--;
        }
      } else {
        while (octave < 0) {
          pitchstr += ",";
          octave++;
        }
      }
      str += pitchstr;
      if (pitchelem.duration) {
        str += this.getDurationString(pitchelem.duration);
      }
      if (!ignoreslur && pitchelem.endSlur) {
        str += ")";
      }
      if (pitchelem.startTie) {
        str += "-";
      }
      return str;
    };
    TextPrinter.prototype.getDurationString = function(duration) {
      if (duration / this.l > 1) {
        return duration / this.l;
      }
      var ret = "";
      if (this.l / duration > 1) {
        ret += "/";
        if (this.l / duration > 2) {
          ret += this.l / duration;
        }
      }
      return ret;
    };
    TextPrinter.prototype.extractNote = function(pitch) {
      var pitch2 = pitch % 7;
      if (pitch2 < 0) pitch2 += 7;
      return pitch2;
    };
    TextPrinter.prototype.extractOctave = function(pitch) {
      return Math.floor(pitch / 7);
    };
    TextPrinter.prototype.printBarLine = function(elem) {
      var barstr = "";
      switch (elem.type) {
        case "bar_thin":
          barstr += "|";
          break;
        case "bar_thin_thick":
          barstr += "|]";
          break;
        case "bar_thin_thin":
          barstr += "||";
          break;
        case "bar_thick_thin":
          barstr += "[|";
          break;
        case "bar_dbl_repeat":
          barstr += ":||:";
          break;
        case "bar_left_repeat":
          barstr += "|:";
          break;
        case "bar_right_repeat":
          barstr += ":|";
          break;
        case "bar_invisible":
          barstr += "";
          break;
      }
      this.printString(barstr, elem);
    };
    TextPrinter.prototype.multiplyString = function(s, n) {
      var ret = "";
      for (; n > 0; n--) ret += s;
      return ret;
    };
    module.exports = TextPrinter;
  }
});

// node_modules/abcjs/src/edit/abc_editor.js
var require_abc_editor = __commonJS({
  "node_modules/abcjs/src/edit/abc_editor.js"(exports, module) {
    var TuneBook = require_abc_tunebook().TuneBook;
    var parseCommon = require_abc_common();
    var Parse = require_abc_parse();
    var TextPrinter = require_abc2abc_write();
    var EngraverController = require_abc_engraver_controller();
    var SynthController = require_synth_controller();
    var supportsAudio = require_supports_audio();
    if (typeof window.CustomEvent !== "function") {
      CustomEvent = function(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: void 0 };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      };
      CustomEvent.prototype = window.Event.prototype;
      window.CustomEvent = CustomEvent;
    }
    var CustomEvent;
    var EditArea = function(textareaid) {
      this.textarea = document.getElementById(textareaid);
      this.initialText = this.textarea.value;
      this.isDragging = false;
    };
    EditArea.prototype.addSelectionListener = function(listener) {
      this.textarea.onmousemove = function(ev) {
        if (this.isDragging)
          listener.fireSelectionChanged();
      };
    };
    EditArea.prototype.addChangeListener = function(listener) {
      this.changelistener = listener;
      this.textarea.onkeyup = function() {
        listener.fireChanged();
      };
      this.textarea.onmousedown = function() {
        this.isDragging = true;
        listener.fireSelectionChanged();
      };
      this.textarea.onmouseup = function() {
        this.isDragging = false;
        listener.fireChanged();
      };
      this.textarea.onchange = function() {
        listener.fireChanged();
      };
    };
    EditArea.prototype.getSelection = function() {
      return { start: this.textarea.selectionStart, end: this.textarea.selectionEnd };
    };
    EditArea.prototype.setSelection = function(start, end) {
      if (this.textarea.setSelectionRange)
        this.textarea.setSelectionRange(start, end);
      else if (this.textarea.createTextRange) {
        var e = this.textarea.createTextRange();
        e.collapse(true);
        e.moveEnd("character", end);
        e.moveStart("character", start);
        e.select();
      }
      this.textarea.focus();
    };
    EditArea.prototype.getString = function() {
      return this.textarea.value;
    };
    EditArea.prototype.setString = function(str) {
      this.textarea.value = str;
      this.initialText = this.getString();
      if (this.changelistener) {
        this.changelistener.fireChanged();
      }
    };
    EditArea.prototype.getElem = function() {
      return this.textarea;
    };
    var Editor = function(editarea, params) {
      this.abcjsParams = {};
      var key;
      if (params.abcjsParams) {
        for (key in params.abcjsParams) {
          if (params.abcjsParams.hasOwnProperty(key)) {
            this.abcjsParams[key] = params.abcjsParams[key];
          }
        }
      }
      if (params.midi_options) {
        for (key in params.midi_options) {
          if (params.midi_options.hasOwnProperty(key)) {
            this.abcjsParams[key] = params.midi_options[key];
          }
        }
      }
      if (params.parser_options) {
        for (key in params.parser_options) {
          if (params.parser_options.hasOwnProperty(key)) {
            this.abcjsParams[key] = params.parser_options[key];
          }
        }
      }
      if (params.render_options) {
        for (key in params.render_options) {
          if (params.render_options.hasOwnProperty(key)) {
            this.abcjsParams[key] = params.render_options[key];
          }
        }
      }
      if (params.indicate_changed)
        this.indicate_changed = true;
      if (typeof editarea === "string") {
        this.editarea = new EditArea(editarea);
      } else {
        this.editarea = editarea;
      }
      this.editarea.addSelectionListener(this);
      this.editarea.addChangeListener(this);
      if (params.canvas_id) {
        this.div = document.getElementById(params.canvas_id);
      } else if (params.paper_id) {
        this.div = document.getElementById(params.paper_id);
      } else {
        this.div = document.createElement("DIV");
        this.editarea.getElem().parentNode.insertBefore(this.div, this.editarea.getElem());
      }
      if (params.selectionChangeCallback) {
        this.selectionChangeCallback = params.selectionChangeCallback;
      }
      if (params.synth) {
        if (supportsAudio()) {
          this.synth = {
            el: params.synth.el,
            cursorControl: params.synth.cursorControl,
            options: params.synth.options
          };
        }
      }
      if (params.generate_midi) {
        this.generate_midi = params.generate_midi;
        if (this.abcjsParams.generateDownload) {
          if (typeof params.midi_download_id === "string")
            this.downloadMidi = document.getElementById(params.midi_download_id);
          else if (params.midi_download_id)
            this.downloadMidi = params.midi_download_id;
        }
        if (this.abcjsParams.generateInline !== false) {
          if (typeof params.midi_id === "string")
            this.inlineMidi = document.getElementById(params.midi_id);
          else if (params.midi_id)
            this.inlineMidi = params.midi_id;
        }
      }
      if (params.generate_warnings || params.warnings_id) {
        if (params.warnings_id) {
          this.warningsdiv = document.getElementById(params.warnings_id);
        } else {
          this.warningsdiv = this.div;
        }
      }
      this.onchangeCallback = params.onchange;
      if (params.gui) {
        this.target = document.getElementById(editarea);
        this.abcjsParams.editable = true;
      }
      this.oldt = "";
      this.bReentry = false;
      this.parseABC();
      this.modelChanged();
      this.addClassName = function(element, className) {
        var hasClassName = function(element2, className2) {
          var elementClassName = element2.className;
          return elementClassName.length > 0 && (elementClassName === className2 || new RegExp("(^|\\s)" + className2 + "(\\s|$)").test(elementClassName));
        };
        if (!hasClassName(element, className))
          element.className += (element.className ? " " : "") + className;
        return element;
      };
      this.removeClassName = function(element, className) {
        element.className = parseCommon.strip(element.className.replace(
          new RegExp("(^|\\s+)" + className + "(\\s+|$)"),
          " "
        ));
        return element;
      };
      this.setReadOnly = function(readOnly) {
        var readonlyClass = "abc_textarea_readonly";
        var el = this.editarea.getElem();
        if (readOnly) {
          el.setAttribute("readonly", "yes");
          this.addClassName(el, readonlyClass);
        } else {
          el.removeAttribute("readonly");
          this.removeClassName(el, readonlyClass);
        }
      };
    };
    Editor.prototype.renderTune = function(abc, params, div) {
      var tunebook = new TuneBook(abc);
      var abcParser = Parse();
      abcParser.parse(tunebook.tunes[0].abc, params, tunebook.tunes[0].startPos - tunebook.header.length);
      var tune = abcParser.getTune();
      var engraver_controller = new EngraverController(div, this.abcjsParams);
      engraver_controller.engraveABC(tune);
    };
    Editor.prototype.redrawMidi = function() {
      if (this.generate_midi && !this.midiPause) {
        var event = new window.CustomEvent("generateMidi", {
          detail: {
            tunes: this.tunes,
            abcjsParams: this.abcjsParams,
            downloadMidiEl: this.downloadMidi,
            inlineMidiEl: this.inlineMidi,
            engravingEl: this.div
          }
        });
        window.dispatchEvent(event);
      }
      if (this.synth) {
        if (!this.synth.synthControl) {
          this.synth.synthControl = new SynthController();
          this.synth.synthControl.load(this.synth.el, this.synth.cursorControl, this.synth.options);
        }
        this.synth.synthControl.setTune(this.tunes[0], false);
      }
    };
    Editor.prototype.modelChanged = function() {
      if (this.tunes === void 0) {
        if (this.downloadMidi !== void 0)
          this.downloadMidi.innerHTML = "";
        if (this.inlineMidi !== void 0)
          this.inlineMidi.innerHTML = "";
        this.div.innerHTML = "";
        return;
      }
      if (this.bReentry)
        return;
      this.bReentry = true;
      this.timerId = null;
      this.div.innerHTML = "";
      this.engraver_controller = new EngraverController(this.div, this.abcjsParams);
      this.engraver_controller.engraveABC(this.tunes);
      this.tunes[0].engraver = this.engraver_controller;
      this.redrawMidi();
      if (this.warningsdiv) {
        this.warningsdiv.innerHTML = this.warnings ? this.warnings.join("<br />") : "No errors";
      }
      if (this.target) {
        var textprinter = new TextPrinter(this.target, true);
        textprinter.printABC(this.tunes[0]);
      }
      this.engraver_controller.addSelectListener(this.highlight.bind(this));
      this.updateSelection();
      this.bReentry = false;
    };
    Editor.prototype.paramChanged = function(engraverParams) {
      if (engraverParams) {
        for (var key in engraverParams) {
          if (engraverParams.hasOwnProperty(key)) {
            this.abcjsParams[key] = engraverParams[key];
          }
        }
      }
      this.oldt = "";
      this.fireChanged();
    };
    Editor.prototype.parseABC = function() {
      var t = this.editarea.getString();
      if (t === this.oldt) {
        this.updateSelection();
        return false;
      }
      this.oldt = t;
      if (t === "") {
        this.tunes = void 0;
        this.warnings = "";
        return true;
      }
      var tunebook = new TuneBook(t);
      this.tunes = [];
      this.startPos = [];
      this.warnings = [];
      for (var i = 0; i < tunebook.tunes.length; i++) {
        var abcParser = new Parse();
        abcParser.parse(tunebook.tunes[i].abc, this.abcjsParams, tunebook.tunes[i].startPos - tunebook.header.length);
        this.tunes[i] = abcParser.getTune();
        this.startPos[i] = tunebook.tunes[i].startPos;
        var warnings = abcParser.getWarnings() || [];
        for (var j = 0; j < warnings.length; j++) {
          this.warnings.push(warnings[j]);
        }
      }
      return true;
    };
    Editor.prototype.updateSelection = function() {
      var selection = this.editarea.getSelection();
      try {
        this.engraver_controller.rangeHighlight(selection.start, selection.end);
      } catch (e) {
      }
      if (this.selectionChangeCallback)
        this.selectionChangeCallback(selection.start, selection.end);
    };
    Editor.prototype.fireSelectionChanged = function() {
      this.updateSelection();
    };
    Editor.prototype.setDirtyStyle = function(isDirty) {
      if (this.indicate_changed === void 0)
        return;
      var addClassName = function(element, className) {
        var hasClassName = function(element2, className2) {
          var elementClassName = element2.className;
          return elementClassName.length > 0 && (elementClassName === className2 || new RegExp("(^|\\s)" + className2 + "(\\s|$)").test(elementClassName));
        };
        if (!hasClassName(element, className))
          element.className += (element.className ? " " : "") + className;
        return element;
      };
      var removeClassName = function(element, className) {
        element.className = parseCommon.strip(element.className.replace(
          new RegExp("(^|\\s+)" + className + "(\\s+|$)"),
          " "
        ));
        return element;
      };
      var readonlyClass = "abc_textarea_dirty";
      var el = this.editarea.getElem();
      if (isDirty) {
        addClassName(el, readonlyClass);
      } else {
        removeClassName(el, readonlyClass);
      }
    };
    Editor.prototype.fireChanged = function() {
      if (this.bIsPaused)
        return;
      if (this.parseABC()) {
        var self = this;
        if (this.timerId)
          clearTimeout(this.timerId);
        this.timerId = setTimeout(function() {
          self.modelChanged();
        }, 300);
        var isDirty = this.isDirty();
        if (this.wasDirty !== isDirty) {
          this.wasDirty = isDirty;
          this.setDirtyStyle(isDirty);
        }
        if (this.onchangeCallback)
          this.onchangeCallback(this);
      }
    };
    Editor.prototype.setNotDirty = function() {
      this.editarea.initialText = this.editarea.getString();
      this.wasDirty = false;
      this.setDirtyStyle(false);
    };
    Editor.prototype.isDirty = function() {
      if (this.indicate_changed === void 0)
        return false;
      return this.editarea.initialText !== this.editarea.getString();
    };
    Editor.prototype.highlight = function(abcelem, tuneNumber, classes) {
      this.editarea.setSelection(abcelem.startChar, abcelem.endChar);
      if (this.selectionChangeCallback)
        this.selectionChangeCallback(abcelem.startChar, abcelem.endChar);
    };
    Editor.prototype.pause = function(shouldPause) {
      this.bIsPaused = shouldPause;
      if (!shouldPause)
        this.fireChanged();
    };
    Editor.prototype.millisecondsPerMeasure = function() {
      return this.synth.synthControl.visualObj.millisecondsPerMeasure();
    };
    Editor.prototype.pauseMidi = function(shouldPause) {
      this.midiPause = shouldPause;
      if (!shouldPause)
        this.redrawMidi();
    };
    module.exports = Editor;
  }
});

// node_modules/abcjs/index.js
var require_abcjs = __commonJS({
  "node_modules/abcjs/index.js"(exports, module) {
    var version = require_version();
    var animation = require_abc_animation();
    var tuneBook = require_abc_tunebook();
    var abcjs = {};
    abcjs.signature = "abcjs-basic v" + version;
    Object.keys(animation).forEach(function(key) {
      abcjs[key] = animation[key];
    });
    Object.keys(tuneBook).forEach(function(key) {
      abcjs[key] = tuneBook[key];
    });
    abcjs.renderAbc = require_abc_tunebook_svg();
    abcjs.TimingCallbacks = require_abc_timing_callbacks();
    var glyphs = require_abc_glyphs();
    abcjs.setGlyph = glyphs.setSymbol;
    var CreateSynth = require_create_synth();
    var instrumentIndexToName = require_instrument_index_to_name();
    var pitchToNoteName = require_pitch_to_note_name();
    var SynthSequence = require_synth_sequence();
    var CreateSynthControl = require_create_synth_control();
    var registerAudioContext = require_register_audio_context();
    var activeAudioContext = require_active_audio_context();
    var supportsAudio = require_supports_audio();
    var playEvent = require_play_event();
    var SynthController = require_synth_controller();
    abcjs.synth = {
      CreateSynth,
      instrumentIndexToName,
      pitchToNoteName,
      SynthController,
      SynthSequence,
      CreateSynthControl,
      registerAudioContext,
      activeAudioContext,
      supportsAudio,
      playEvent
    };
    var editor = require_abc_editor();
    abcjs["Editor"] = editor;
    module.exports = abcjs;
  }
});
export default require_abcjs();
//# sourceMappingURL=abcjs.js.map
